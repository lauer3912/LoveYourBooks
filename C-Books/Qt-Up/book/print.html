<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Qt 技能提升</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/custom.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="qmake/read.html"><strong aria-hidden="true">1.</strong> QMake</a></li><li><ol class="section"><li><a href="qmake/how_edit_qt_pro_file.html"><strong aria-hidden="true">1.1.</strong> Qt 的 Pro 文件如何编写？</a></li><li><ol class="section"><li><a href="qmake/quick_start.html"><strong aria-hidden="true">1.1.1.</strong> 快速入门</a></li><li><a href="qmake/pro-projects-template.html"><strong aria-hidden="true">1.1.2.</strong> Pro 工程模板</a></li><li><a href="qmake/advanced-useful-contents.html"><strong aria-hidden="true">1.1.3.</strong> Qmake 高级概念</a></li><li><a href="qmake/qmake-variable-reference.html"><strong aria-hidden="true">1.1.4.</strong> Qmake 变量</a></li><li><a href="qmake/qmake-function-reference.html"><strong aria-hidden="true">1.1.5.</strong> Qmake 函数</a></li><li><a href="qmake/qmake-test-function-reference.html"><strong aria-hidden="true">1.1.6.</strong> Qmake 测试函数</a></li><li><a href="qmake/command_console.html"><strong aria-hidden="true">1.1.7.</strong> Qmake 命令行</a></li><li><a href="qmake/demo1.html"><strong aria-hidden="true">1.1.8.</strong> Pro 文件示例 1</a></li><li><a href="qmake/demo2.html"><strong aria-hidden="true">1.1.9.</strong> Pro 文件示例 2</a></li><li><ol class="section"><li><a href="qmake/create_static_library.html"><strong aria-hidden="true">1.1.9.1.</strong> static library</a></li><li><a href="qmake/create_dynamic_library.html"><strong aria-hidden="true">1.1.9.2.</strong> dynamic library</a></li><li><a href="qmake/create_framework.html"><strong aria-hidden="true">1.1.9.3.</strong> framework</a></li></ol></li><li><a href="qmake/create_plugin.html"><strong aria-hidden="true">1.1.10.</strong> 创建 Plugin</a></li></ol></li><li><a href="qmake/create_static_library_on_mac.html"><strong aria-hidden="true">1.2.</strong> (MacOS)创建静态库?</a></li><li><a href="qmake/create_dynamic_library_on_mac.html"><strong aria-hidden="true">1.3.</strong> (MacOS)创建动态库?</a></li><li><a href="qmake/create_framework_on_mac.html"><strong aria-hidden="true">1.4.</strong> (MacOS)创建 Framework?</a></li><li><a href="qmake/create_static_library_on_win.html"><strong aria-hidden="true">1.5.</strong> (Windows)创建静态库?</a></li><li><a href="qmake/create_dynamic_library_on_win.html"><strong aria-hidden="true">1.6.</strong> (Windows)创建动态库?</a></li><li><a href="qmake/create_static_library_on_linux.html"><strong aria-hidden="true">1.7.</strong> (Linux)创建静态库?</a></li><li><a href="qmake/create_dynamic_library_on_linux.html"><strong aria-hidden="true">1.8.</strong> (Linux)创建动态库?</a></li></ol></li><li><a href="dependence/index.html"><strong aria-hidden="true">2.</strong> Qt 库依赖如何导出</a></li><li><ol class="section"><li><a href="dependence/some_libraries.html"><strong aria-hidden="true">2.1.</strong> Qt 库的用途</a></li><li><a href="dependence/some_plugins.html"><strong aria-hidden="true">2.2.</strong> Qt 插件的用途</a></li><li><a href="dependence/export_on_windows.html"><strong aria-hidden="true">2.3.</strong> Qt Windows 开发，导出依赖</a></li><li><a href="dependence/export_on_linux.html"><strong aria-hidden="true">2.4.</strong> Qt Linux 开发，导出依赖</a></li><li><a href="dependence/export_on_mac.html"><strong aria-hidden="true">2.5.</strong> Qt Mac 开发，导出依赖</a></li></ol></li><li><a href="make_setup/index.html"><strong aria-hidden="true">3.</strong> Qt 制作安装包</a></li><li><ol class="section"><li><a href="make_setup/make_package_on_windows.html"><strong aria-hidden="true">3.1.</strong> Qt Windows 安装包制作</a></li><li><a href="make_setup/make_package_on_linux.html"><strong aria-hidden="true">3.2.</strong> Qt Linux 安装包制作</a></li><li><a href="make_setup/make_package_on_linux.html"><strong aria-hidden="true">3.3.</strong> Qt Mac 安装包制作</a></li></ol></li><li><a href="submit_product/index.html"><strong aria-hidden="true">4.</strong> Qt 产品提交到应用商店</a></li><li><ol class="section"><li><a href="submit_product/appstore_windows.html"><strong aria-hidden="true">4.1.</strong> Windows 应用商店</a></li><li><a href="submit_product/appstore_mac.html"><strong aria-hidden="true">4.2.</strong> 苹果 MacOS 应用 商店</a></li></ol></li><li><a href="win_platform/intro.html"><strong aria-hidden="true">5.</strong> Windows平台技巧</a></li><li><ol class="section"><li><a href="win_platform/winbase/load_library.html"><strong aria-hidden="true">5.1.</strong> 如何加载动态库？</a></li><li><a href="win_platform/winbase/find_load_library.html"><strong aria-hidden="true">5.2.</strong> Windows加载动态库的搜索路径问题</a></li><li><a href="win_platform/winbase/diff_load_library.html"><strong aria-hidden="true">5.3.</strong> LoadLibrary 与 LoadLibraryW 与 LoadLibraryA 的区别</a></li><li><a href="win_platform/winbase/errors_load_library.html"><strong aria-hidden="true">5.4.</strong> 加载动态库出错的错误编码，原因有哪些？</a></li><li><a href="win_platform/winbase/tchar_to_const_char.html"><strong aria-hidden="true">5.5.</strong> TCHAR 转换成const char*</a></li></ol></li><li><a href="qt_skills/qt-core/intro.html"><strong aria-hidden="true">6.</strong> Qt Core 技巧</a></li><li><ol class="section"><li><a href="qt_skills/qt-core/q_object_macro.html"><strong aria-hidden="true">6.1.</strong> 宏 Q_OBJECT, 应用到所有继承 QObject 的类</a></li><li><a href="qt_skills/qt-core/class_define_use_q_object_macro_must_inheritance_qobject.html"><strong aria-hidden="true">6.2.</strong> 使用宏 Q_OBJECT, 类必须继承 QObject 或 QObject 子类</a></li><li><a href="qt_skills/qt-core/qt_version_macro_and_qt_version_check_macro.html"><strong aria-hidden="true">6.3.</strong> 宏 QT_VERSION 与 QT_VERSION_CHECK 如何使用?</a></li><li><a href="qt_skills/qt-core/q_class_info_macro.html"><strong aria-hidden="true">6.4.</strong> 添加类 ClassInfo 信息</a></li><li><a href="qt_skills/qt-core/get_q_class_info.html"><strong aria-hidden="true">6.5.</strong> 获取类 ClassInfo 信息</a></li><li><a href="qt_skills/qt-core/qobject_rw_properties.html"><strong aria-hidden="true">6.6.</strong> 类 Property 属性读写封装</a></li><li><a href="qt_skills/qt-core/qobject_manager_properties.html"><strong aria-hidden="true">6.7.</strong> QObject 对象动态增加属性</a></li><li><a href="qt_skills/qt-core/incomplete_return_type_of_QMetaClassInfo.html"><strong aria-hidden="true">6.8.</strong> incomplete return type 'QMetaClassInfo'</a></li><li><a href="qt_skills/qt-core/incomplete_return_type_of_QMetaProperty.html"><strong aria-hidden="true">6.9.</strong> incomplete return type 'QMetaProperty'</a></li><li><a href="qt_skills/qt-core/qobject_cast.html"><strong aria-hidden="true">6.10.</strong> QObject 对象指针类型的动态转换 qobject_cast&lt;&gt;</a></li><li><a href="qt_skills/qt-core/qobject_enums.html"><strong aria-hidden="true">6.11.</strong> QObject 对象枚举类型封装</a></li><li><a href="qt_skills/qt-core/class_define_use_general_not_supported.html"><strong aria-hidden="true">6.12.</strong> QObject 子类不支持模类定义板泛型</a></li><li><a href="qt_skills/qt-core/multiple_inheritance_with_qobject_be_first.html"><strong aria-hidden="true">6.13.</strong> 多继承 QObject 必须放在前面</a></li><li><a href="qt_skills/qt-core/virtual_inheritance_with_qobject_not_supported.html"><strong aria-hidden="true">6.14.</strong> 虚拟继承 QObject 不支持</a></li><li><a href="qt_skills/qt-core/nested_classes_cannot_have_signals_and_slots.html"><strong aria-hidden="true">6.15.</strong> 嵌套类中的类不能有信号和槽机制</a></li><li><a href="qt_skills/qt-core/nested_classes_cannot_use_q_object_macro.html"><strong aria-hidden="true">6.16.</strong> 嵌套 QObject 子类中的类不能使用宏 Q_OBJECT</a></li><li><a href="qt_skills/qt-core/function_cannot_apply_to_single_and_slot.html"><strong aria-hidden="true">6.17.</strong> 函数指针不能作为信号和槽的参数</a></li><li><a href="qt_skills/qt-core/enums_must_be_fully_qualified_for_single_and_slot.html"><strong aria-hidden="true">6.18.</strong> 信号和槽中的枚举参数，必须是完全限定</a></li><li><a href="qt_skills/qt-core/order_about_singles_and_slots.html"><strong aria-hidden="true">6.19.</strong> 信号和槽被激活的调用次序是随机的吗？</a></li><li><a href="qt_skills/qt-core/function_pointer_about_singles_and_slots.html"><strong aria-hidden="true">6.20.</strong> 信号和槽可以使用函数指针吗？</a></li><li><a href="qt_skills/qt-core/lambdas_about_singles_and_slots.html"><strong aria-hidden="true">6.21.</strong> 槽支持 C++11 的 lambdas 表达式吗？</a></li><li><a href="qt_skills/qt-core/blocking_queued_connect_about_singles_and_slots.html"><strong aria-hidden="true">6.22.</strong> 什么时候使用 Blocking Queued Connection?</a></li><li><a href="qt_skills/qt-core/qvariant.html"><strong aria-hidden="true">6.23.</strong> 宏 Q_DECLARE_METATYPE 与 QVariant 如何结合使用？</a></li><li><a href="qt_skills/qt-core/q_declare_metatype.html"><strong aria-hidden="true">6.24.</strong> 如何构建自定义 Qt 数据类型？</a></li><li><a href="qt_skills/qt-core/qvariant_save_pointer.html"><strong aria-hidden="true">6.25.</strong> 用 QVariant 来保存指针</a></li><li><a href="qt_skills/qt-core/qvariant_can_convert.html"><strong aria-hidden="true">6.26.</strong> 判断 QVariant 类型是否可以转换？</a></li><li><a href="qt_skills/qt-core/qt_iterating.html"><strong aria-hidden="true">6.27.</strong> Qt 的迭代器接口如何使用？</a></li><li><a href="qt_skills/qt-core/qt_qpointer.html"><strong aria-hidden="true">6.28.</strong> 如何使用保护机制指针 QPointer，增强程序健壮性？</a></li><li><a href="qt_skills/qt-core/qt_qsharedpointer.html"><strong aria-hidden="true">6.29.</strong> 如何使用强引用计数指针 QSharedPointer？</a></li><li><a href="qt_skills/qt-core/qt_qweakpointer.html"><strong aria-hidden="true">6.30.</strong> 如何使用弱引用计数指针 QWeakPointer？</a></li><li><a href="qt_skills/qt-core/qt_qobject_cleanup_handler.html"><strong aria-hidden="true">6.31.</strong> 怎么监视 QObject 对象的生命周期？</a></li><li><a href="qt_skills/qt-core/qt_signal_blocker.html"><strong aria-hidden="true">6.32.</strong> 如何暂时阻止发射信号？</a></li><li><a href="qt_skills/qt-core/qt_debug.html"><strong aria-hidden="true">6.33.</strong> 如何使用 QDebug 打印调试信息</a></li><li><a href="qt_skiils/qt-core/qt_qbytearray.html"><strong aria-hidden="true">6.34.</strong> 二进制数据编辑器需要QByteArray数据类型</a></li><li><a href="qt_skills/qt-core/qt_date_and_time.html"><strong aria-hidden="true">6.35.</strong> 如何获取当前时间?</a></li></ol></li><li><a href="qt_skills/qt-gui/intro.html"><strong aria-hidden="true">7.</strong> Qt GUI 技巧</a></li><li><a href="qt_skills/qt-widgets/intro.html"><strong aria-hidden="true">8.</strong> Qt Widgets 技巧</a></li><li><ol class="section"><li><a href="qt_skills/qt-widgets/undo_command.html"><strong aria-hidden="true">8.1.</strong> 如何为应用添加撤销操作?</a></li><li><a href="qt_skills/qt-widgets/message_box.html"><strong aria-hidden="true">8.2.</strong> 如何使用消息对话框QMessageBox?</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <!-- START - Rust Cookbook customization -->
                            <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit" aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                                <i class="fa fa-edit">Edit</i>
                            </button>
                            <!-- END - Rust Cookbook customization -->
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Qt 技能提升</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });

                   // START - Rust Cookbook customization
                   document.getElementById("edit-button").addEventListener("click", function(){
                       var editWindow = window.open("https://github.com/rust-lang-nursery/rust-cookbook/edit/master/src/print.md");
                   });
                   // END - Rust Cookbook customization
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#qmake" id="qmake"><h1>QMake</h1></a>
<a class="header" href="print.html#a简介" id="a简介"><h2>简介</h2></a>
<p><code>qmake</code> 是 Qt 附带的工具之一 。</p>
<p><code>qmake</code>工具有助于简化跨不同平台的开发项目的构建过程。它自动生成<code>Makefile</code>，因此只需要几行信息就可以创建每个<code>Makefile</code>。您可以在任何软件项目中使用<code>qmake</code>，<strong>不管它是用 Qt 编写的还是不用 Qt 编写的</strong>。</p>
<p>如何使用 qmake?</p>
<a class="header" href="print.html#a特点" id="a特点"><h2>特点</h2></a>
<p>手写 <code>Makefile</code> 是比较困难而且容易出错，尤其在进行跨平台开发时必须针对不同平台分别撰写 <code>Makefile</code>，会增加跨平台开发复杂性与困难度。<code>qmake</code> 会根据专案文件（<code>.pro</code>）里面的信息自动生成适合平台的 <code>Makefile</code>。开发者能够自行撰写专案文件或是由 <code>qmake</code> 本身产生。<code>qmake</code> 包含额外的功能来方便 Qt 开发，如自动的包含 <code>moc</code> 和 <code>uic</code> 的编译规则。</p>
<a class="header" href="print.html#qt-的-pro-文件如何编写" id="qt-的-pro-文件如何编写"><h1>Qt 的 Pro 文件如何编写？</h1></a>
<a class="header" href="print.html#a快速入门" id="a快速入门"><h1>快速入门</h1></a>
<p><a href="http://doc.qt.io/qt-5/qmake-tutorial.html">http://doc.qt.io/qt-5/qmake-tutorial.html</a></p>
<p>Getting Started</p>
<p>This tutorial teaches you the basics of qmake. The other topics in this manual contain more detailed information about using qmake.
Starting Off Simple</p>
<p>Let's assume that you have just finished a basic implementation of your application, and you have created the following files:</p>
<pre><code class="language-text">    hello.cpp
    hello.h
    main.cpp
</code></pre>
<p>You will find these files in the examples/qmake/tutorial directory of the Qt distribution. The only other thing you know about the setup of the application is that it's written in Qt. First, using your favorite plain text editor, create a file called hello.pro in examples/qmake/tutorial. The first thing you need to do is add the lines that tell qmake about the source and header files that are part of your development project.</p>
<p>We'll add the source files to the project file first. To do this you need to use the SOURCES variable. Just start a new line with SOURCES += and put hello.cpp after it. You should have something like this:</p>
<pre><code class="language-pro">SOURCES += hello.cpp
</code></pre>
<p>We repeat this for each source file in the project, until we end up with the following:</p>
<pre><code class="language-pro">SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>If you prefer to use a Make-like syntax, with all the files listed in one go you can use the newline escaping like this:</p>
<pre><code class="language-pro">SOURCES = hello.cpp \
          main.cpp
</code></pre>
<p>Now that the source files are listed in the project file, the header files must be added. These are added in exactly the same way as source files, except that the variable name we use is HEADERS.</p>
<p>Once you have done this, your project file should look something like this:</p>
<pre><code class="language-pro">HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>The target name is set automatically. It is the same as the project filename, but with the suffix appropriate for the platform. For example, if the project file is called hello.pro, the target will be hello.exe on Windows and hello on Unix. If you want to use a different name you can set it in the project file:</p>
<pre><code class="language-pro">TARGET = helloworld
</code></pre>
<p>The finished project file should look like this:</p>
<pre><code class="language-pro">HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>You can now use qmake to generate a Makefile for your application. On the command line, in your project directory, type the following:</p>
<pre><code class="language-bash">qmake -o Makefile hello.pro
</code></pre>
<p>Then type make or nmake depending on the compiler you use.</p>
<p>For Visual Studio users, qmake can also generate Visual Studio project files. For example:</p>
<pre><code class="language-bash">qmake -tp vc hello.pro
</code></pre>
<p>Making an Application Debuggable</p>
<p>The release version of an application does not contain any debugging symbols or other debugging information. During development, it is useful to produce a debugging version of the application that has the relevant information. This is easily achieved by adding debug to the CONFIG variable in the project file.</p>
<p>For example:</p>
<pre><code class="language-pro">CONFIG += debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>Use qmake as before to generate a Makefile. You will now obtain useful information about your application when running it in a debugging environment.
Adding Platform-Specific Source Files</p>
<p>After a few hours of coding, you might have made a start on the platform-specific part of your application, and decided to keep the platform-dependent code separate. So you now have two new files to include into your project file: hellowin.cpp and hellounix.cpp. We cannot just add these to the SOURCES variable since that would place both files in the Makefile. So, what we need to do here is to use a scope which will be processed depending on which platform we are building for.</p>
<p>A simple scope that adds the platform-dependent file for Windows looks like this:</p>
<pre><code class="language-pro">win32 {
    SOURCES += hellowin.cpp
}
</code></pre>
<p>When building for Windows, qmake adds hellowin.cpp to the list of source files. When building for any other platform, qmake simply ignores it. Now all that is left to be done is to create a scope for the Unix-specific file.</p>
<p>When you have done that, your project file should look something like this:</p>
<pre><code class="language-pro">CONFIG += debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
win32 {
    SOURCES += hellowin.cpp
}
unix {
    SOURCES += hellounix.cpp
}
</code></pre>
<p>Use qmake as before to generate a Makefile.
Stopping qmake If a File Does Not Exist</p>
<p>You may not want to create a Makefile if a certain file does not exist. We can check if a file exists by using the exists() function. We can stop qmake from processing by using the error() function. This works in the same way as scopes do. Simply replace the scope condition with the function. A check for a file called main.cpp looks like this:</p>
<pre><code class="language-pro">!exists( main.cpp ) {
    error( &quot;No main.cpp file found&quot; )
}
</code></pre>
<p>The ! symbol is used to negate the test. That is, exists( main.cpp ) is true if the file exists, and !exists( main.cpp ) is true if the file does not exist.</p>
<pre><code class="language-pro">CONFIG += debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
win32 {
    SOURCES += hellowin.cpp
}
unix {
    SOURCES += hellounix.cpp
}
!exists( main.cpp ) {
    error( &quot;No main.cpp file found&quot; )
}
```pro

Use qmake as before to generate a makefile. If you rename main.cpp temporarily, you will see the message and qmake will stop processing.
Checking for More than One Condition

Suppose you use Windows and you want to be able to see statement output with qDebug() when you run your application on the command line. To see the output, you must build your application with the appropriate console setting. We can easily put console on the CONFIG line to include this setting in the Makefile on Windows. However, let's say that we only want to add the CONFIG line when we are running on Windows and when debug is already on the CONFIG line. This requires using two nested scopes. First create one scope, then create the other inside it. Put the settings to be processed inside the second scope, like this:

```pro
win32 {
    debug {
        CONFIG += console
    }
}
</code></pre>
<p>Nested scopes can be joined together using colons, so the final project file looks like this:</p>
<pre><code class="language-pro">CONFIG += debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
win32 {
    SOURCES += hellowin.cpp
}
unix {
    SOURCES += hellounix.cpp
}
!exists( main.cpp ) {
    error( &quot;No main.cpp file found&quot; )
}
win32:debug {
    CONFIG += console
}
</code></pre>
<p>That's it! You have now completed the tutorial for qmake, and are ready to write project files for your development projects.</p>
<p>qmake 教程介绍
这个教程可以教会你如何使用 qmake。我们建议你看完这个教程之后读一下 qmake 手册。</p>
<p>开始很简单
让我们假设你已经完成了你的应用程序的一个基本实现，并且你已经创建了下述文件：</p>
<p>hello.cpp</p>
<p>hello.h</p>
<p>main.cpp</p>
<p>你可以在 qt/qmake/example 中发现这些文件。你对这个应用程序的配置仅仅知道的另一件事是它是用 Qt 写的。首先，使用你所喜欢的纯文本编辑器，在 qt/qmake/tutorial 中创建一个叫做 hello.pro 的文件。你所要做的第一件事是添加一些行来告诉 qmake 关于你所开发的项目中的源文件和头文件这一部分。</p>
<p>我们先把源文件添加到项目文件中。为了做到这点，你需要使用 SOURCES 变量。只要用 SOURCES +=来开始一行，并且把 hello.cpp 放到它后面。你需要写成这样：</p>
<pre><code>SOURCES += hello.cpp
</code></pre>
<p>我们对项目中的每一个源文件都这样做，直到结束：</p>
<pre><code>SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>如果你喜欢使用像 Make 一样风格的语法，你也可以写成这样，一行写一个源文件，并用反斜线结尾，然后再起新的一行：</p>
<pre><code>SOURCES = hello.cpp \
      main.cpp
</code></pre>
<p>现在源文件已经被列到项目文件中了，头文件也必须添加。添加的方式和源文件一样，除了变量名是 HEADERS。</p>
<p>当你做完这些时，你的项目文件就像现在这样：</p>
<pre><code>HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>目标名称是自动设置的，它被设置为和项目文件一样的名称，但是为了适合平台所需要的后缀。举例来说，加入项目文件叫做“hello.pro”，在 Windows 上的目标名称应该是“hello.exe”，在 Unix 上应该是“hello”。如果你想设置一个不同的名字，你可以在项目文件中设置它：</p>
<pre><code>TARGET = helloworld
</code></pre>
<p>最后一步是设置 CONFIG 变量。因为这是一个 Qt 应用程序，我们需要把“qt”放到 CONFIG 这一行中，这样 qmake 才会在连接的时候添加相关的库，并且保证 moc 和 uic 的连编行也被包含到 Makefile 中。</p>
<p>最终完成的项目文件应该是这样的：</p>
<pre><code>CONFIG += qt
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>你现在可以使用 qmake 来为你的应用程序生成 Makefile。在你的应用程序目录中，在命令行下输入：</p>
<pre><code>qmake -o Makefile hello.pro
</code></pre>
<p>然后根据你所使用的编译器输入 make 或者 nmake。</p>
<p>使应用程序可以调试
应用程序的发布版本不包含任何调试符号或者其它调试信息。在开发过程中，生成一个含有相关信息的应用程序的调试版本是很有用处的。通过在项目文件的 CONFIG 变量中添加“debug”就可以很简单地实现。</p>
<p>例如：</p>
<pre><code>CONFIG += qt debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
</code></pre>
<p>像前面一样使用 qmake 来生成一个 Makefile 并且你就能够调试你的应用程序了。</p>
<p>添加特定平台的源文件
在编了几个小时的程序之后，你也许开始为你的应用程序编写与平台相关的部分，并且决定根据平台的不同编写不同的代码。所以现在你有两个信文件要包含到你的项目文件中－hello_win.cpp 和 hello_x11.cpp。我们不能仅仅把这两个文件放到 SOURCES 变量中，因为那样的话会把这两个文件都加到 Makefile 中。所以我们在这里需要做的是根据 qmake 所运行的平台来使用相应的作用域来进行处理。</p>
<p>为 Windows 平台添加的依赖平台的文件的简单的作用域看起来就像这样：</p>
<pre><code>win32 {
SOURCES += hello_win.cpp
}
</code></pre>
<p>所以如果 qmake 运行在 Windows 上的时候，它就会把 hello_win.cpp 添加到源文件列表中。如果 qmake 运行在其它平台上的时候，它会很简单地把这部分忽略。现在接下来我们要做的就是添加一个 X11 依赖文件的作用域。</p>
<p>当你做完了这部分，你的项目文件应该和这样差不多：</p>
<pre><code>CONFIG += qt debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
win32 {
SOURCES += hello_win.cpp
}
x11 {
SOURCES += hello_x11.cpp
}
</code></pre>
<p>像前面一样使用 qmake 来生成 Makefile。</p>
<p>如果一个文件不存在，停止 qmake
如果某一个文件不存在的时候，你也许不想生成一个 Makefile。我们可以通过使用 exists()函数来检查一个文件是否存在。我们可以通过使用 error()函数把正在运行的 qmake 停下来。这和作用域的工作方式一样。只要很简单地用这个函数来替换作用域条件。对 main.cpp 文件的检查就像这样：</p>
<pre><code>!exists( main.cpp ) {
error( &quot;No main.cpp file found&quot; )
}
</code></pre>
<p>“!”用来否定这个测试，比如，如果文件存在，exists( main.cpp )是真，如果文件不存在，!exists( main.cpp )是真。</p>
<pre><code>CONFIG += qt debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
win32 {
SOURCES += hello_win.cpp
}
x11 {
SOURCES += hello_x11.cpp
}
!exists( main.cpp ) {
error( &quot;No main.cpp file found&quot; )
}
</code></pre>
<p>像前面一样使用 qmake 来生成 Makefile。如果你临时改变 main.cpp 的名称，你会看到信息，并且 qmake 会停止处理。</p>
<p>检查多于一个的条件
假设你使用 Windows 并且当你在命令行运行你的应用程序的时候你想能够看到 qDebug()语句。除非你在连编你的程序的时候使用 console 设置，你不会看到输出。我们可以很容易地把 console 添加到 CONFIG 行中，这样在 Windows 下，Makefile 就会有这个设置。但是如果告诉你我们只是想在当我们的应用程序运行在 Windows 下并且当 debug 已经在 CONFIG 行中的时候，添加 console。这需要两个嵌套的作用域；只要生成一个作用域，然后在它里面再生成另一个。把设置放在最里面的作用域里，就像这样：</p>
<pre><code>win32 {
debug {
    CONFIG += console
}
}
</code></pre>
<p>嵌套的作用域可以使用冒号连接起来，所以最终的项目文件看起来像这样：</p>
<pre><code>CONFIG += qt debug
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
win32 {
SOURCES += hello_win.cpp
}
x11 {
SOURCES += hello_x11.cpp
}
!exists( main.cpp ) {
error( &quot;No main.cpp file found&quot; )
}
win32:debug {
CONFIG += console
}
</code></pre>
<p>就这些了！你现在已经完成了 qmake 的教程，并且已经准备好为你的开发项目写项目文件了。</p>
<a class="header" href="print.html#pro-工程模板" id="pro-工程模板"><h1>Pro 工程模板</h1></a>
<p>模板文件，用于更明确的说明，编码用途</p>
<table><thead><tr><th> Template  </th><th> qmake Output                                                      </th></tr></thead><tbody>
<tr><td> app       </td><td> Makefile to build an application.                                 </td></tr>
<tr><td> lib       </td><td> Makefile to build a library.                                      </td></tr>
<tr><td> vcapp     </td><td> Visual Studio Project file to build an application.               </td></tr>
<tr><td> vclib     </td><td> Visual Studio Project file to build a library.                    </td></tr>
<tr><td> vcsubdirs </td><td> Visual Studio Solution file to build projects in sub-directories. </td></tr>
</tbody></table>
<p>具体详细部分：参照 <a href="http://doc.qt.io/qt-5/qmake-project-files.html">doc.qt.io/qt-5/qmake-project-files.html</a></p>
<p>关于以 QT 为前缀的变量有</p>
<p>具体详细部分：参照 <a href="http://doc.qt.io/qt-5/qmake-variable-reference.html#qt">http://doc.qt.io/qt-5/qmake-variable-reference.html#qt</a></p>
<p>介绍 qmake
qmake 是用来为不同的平台的开发项目创建 makefile 的 Trolltech 开发一个易于使用的工具。qmake 简化了 makefile 的生成，所以为了创建一个 makefile 只需要一个只有几行信息的文件。qmake 可以供任何一个软件项目使用，而不用管它是不是用 Qt 写的，尽管它包含了为支持 Qt 开发所拥有的额外的特征。</p>
<p>qmake 基于一个项目文件这样的信息来生成 makefile。项目文件可以由开发者生成。项目文件通常很简单，但是如果需要它是非常完善的。不用修改项目文件，qmake 也可以为为 Microsoft Visual Studio 生成项目。</p>
<p>qmake 的概念
QMAKESPEC 环境变量
举例来说，如果你在 Windows 下使用 Microsoft Visual Studio，然后你需要把 QMAKESPEC 环境变量设置为 win32-msvc。如果你在 Solaris 上使用 gcc，你需要把 QMAKESPEC 环境变量设置为 solaris-g++。</p>
<p>在 qt/mkspecs 中的每一个目录里面，都有一个包含了平台和编译器特定信息的 qmake.conf 文件。这些设置适用于你要使用 qmake 的任何项目，请不要修改它，除非你是一个专家。例如，假如你所有的应用程序都必须和一个特定的库连接，你可以把这个信息添加到相应的 qmake.conf 文件中。</p>
<p>项目(.pro)文件
一个项目文件是用来告诉 qmake 关于为这个应用程序创建 makefile 所需要的细节。例如，一个源文件和头文件的列表、任何应用程序特定配置、例如一个必需要连接的额外库、或者一个额外的包含路径，都应该放到项目文件中。</p>
<p>“#”注释
你可以为项目文件添加注释。注释由“#”符号开始，一直到这一行的结束。</p>
<p>模板
模板变量告诉 qmake 为这个应用程序生成哪种 makefile。下面是可供使用的选择：</p>
<p>app - 建立一个应用程序的 makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</p>
<p>lib - 建立一个库的 makefile。</p>
<p>vcapp - 建立一个应用程序的 Visual Studio 项目文件。</p>
<p>vclib - 建立一个库的 Visual Studio 项目文件。</p>
<p>subdirs - 这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成 makefile 并且为它调用 make 的 makefile。</p>
<p>“app”模板
“app”模板告诉 qmake 为建立一个应用程序生成一个 makefile。当使用这个模板时，下面这些 qmake 系统变量是被承认的。你应该在你的.pro 文件中使用它们来为你的应用程序指定特定信息。</p>
<p>HEADERS - 应用程序中的所有头文件的列表。</p>
<p>SOURCES - 应用程序中的所有源文件的列表。</p>
<p>FORMS - 应用程序中的所有.ui 文件（由 Qt 设计器生成）的列表。</p>
<p>LEXSOURCES - 应用程序中的所有 lex 源文件的列表。</p>
<p>YACCSOURCES - 应用程序中的所有 yacc 源文件的列表。</p>
<p>TARGET - 可执行应用程序的名称。默认值为项目文件的名称。（如果需要扩展名，会被自动加上。）</p>
<p>DESTDIR - 放置可执行程序目标的目录。</p>
<p>DEFINES - 应用程序所需的额外的预处理程序定义的列表。</p>
<p>INCLUDEPATH - 应用程序所需的额外的包含路径的列表。</p>
<p>DEPENDPATH - 应用程序所依赖的搜索路径。</p>
<p>VPATH - 寻找补充文件的搜索路径。</p>
<p>DEF_FILE - 只有 Windows 需要：应用程序所要连接的.def 文件。</p>
<p>RC_FILE - 只有 Windows 需要：应用程序的资源文件。</p>
<p>RES_FILE - 只有 Windows 需要：应用程序所要连接的资源文件。</p>
<p>你只需要使用那些你已经有值的系统变量，例如，如果你不需要任何额外的 INCLUDEPATH，那么你就不需要指定它，qmake 会为所需的提供默认值。例如，一个实例项目文件也许就像这样：</p>
<p>TEMPLATE = app
DESTDIR = c:\helloapp
HEADERS += hello.h
SOURCES += hello.cpp
SOURCES += main.cpp
DEFINES += QT_DLL
CONFIG += qt warn_on release
如果条目是单值的，比如 template 或者目的目录，我们是用“=”，但如果是多值条目，我们使用“+=”来为这个类型添加现有的条目。使用“=”会用新值替换原有的值，例如，如果我们写了 DEFINES=QT_DLL，其它所有的定义都将被删除。</p>
<p>“lib”模板
“lib”模板告诉 qmake 为建立一个库而生成 makefile。当使用这个模板时，除了“app”模板中提到系统变量，还有一个 VERSION 是被支持的。你需要在为库指定特定信息的.pro 文件中使用它们。</p>
<p>VERSION - 目标库的版本号，比如，2.3.1。</p>
<p>“subdirs”模板
“subdirs”模板告诉 qmake 生成一个 makefile，它可以进入到特定子目录并为这个目录中的项目文件生成 makefile 并且为它调用 make。</p>
<p>在这个模板中只有一个系统变量 SUBDIRS 可以被识别。这个变量中包含了所要处理的含有项目文件的子目录的列表。这个项目文件的名称是和子目录同名的，这样 qmake 就可以发现它。例如，如果子目里是“myapp”，那么在这个目录中的项目文件应该被叫做 myapp.pro。</p>
<p>CONFIG 变量
配置变量指定了编译器所要使用的选项和所需要被连接的库。配置变量中可以添加任何东西，但只有下面这些选项可以被 qmake 识别。</p>
<p>下面这些选项控制着使用哪些编译器标志：</p>
<p>release - 应用程序将以 release 模式连编。如果“debug”被指定，它将被忽略。</p>
<p>debug - 应用程序将以 debug 模式连编。</p>
<p>warn_on - 编译器会输出尽可能多的警告信息。如果“warn_off”被指定，它将被忽略。</p>
<p>warn_off - 编译器会输出尽可能少的警告信息。</p>
<p>下面这些选项定义了所要连编的库/应用程序的类型：</p>
<p>qt - 应用程序是一个 Qt 应用程序，并且 Qt 库将会被连接。</p>
<p>thread - 应用程序是一个多线程应用程序。</p>
<p>x11 - 应用程序是一个 X11 应用程序或库。</p>
<p>windows - 只用于“app”模板：应用程序是一个 Windows 下的窗口应用程序。</p>
<p>console - 只用于“app”模板：应用程序是一个 Windows 下的控制台应用程序。</p>
<p>dll - 只用于“lib”模板：库是一个共享库（dll）。</p>
<p>staticlib - 只用于“lib”模板：库是一个静态库。</p>
<p>plugin - 只用于“lib”模板：库是一个插件，这将会使 dll 选项生效。</p>
<p>例如，如果你的应用程序使用 Qt 库，并且你想把它连编为一个可调试的多线程的应用程序，你的项目文件应该会有下面这行：</p>
<pre><code>CONFIG += qt thread debug
</code></pre>
<p>注意，你必须使用“+=”，不要使用“=”，否则 qmake 就不能正确使用连编 Qt 的设置了，比如没法获得所编译的 Qt 库的类型了。</p>
<a class="header" href="print.html#qmake-高级概念" id="qmake-高级概念"><h1>Qmake 高级概念</h1></a>
<p><a href="http://doc.qt.io/qt-5/qmake-language.html">英文部分 http://doc.qt.io/qt-5/qmake-language.html</a>
qmake 高级概念
迄今为止，我们见到的 qmake 项目文件都非常简单，仅仅是一些 name = value 和 name += value 的列表行。qmake 提供了很多更强大的功能，比如你可以使用一个简单的项目文件来为多个平台生成 makefile。</p>
<p>操作符
到目前为止，你已经看到在项目文件中使用的=操作符和+=操作符。这里能够提供更多的可供使用的操作符，但是其中的一些需要谨慎地使用，因为它们也许会比你期待的改变的更多。</p>
<p>“=”操作符
这个操作符简单分配一个值给一个变量。使用方法如下：</p>
<pre><code>TARGET = myapp
</code></pre>
<p>这将会设置 TARGET 变量为 myapp。这将会删除原来对 TARGET 的任何设置。</p>
<p>“+=”操作符
这个操作符将会向一个变量的值的列表中添加一个值。使用方法如下：</p>
<pre><code>DEFINES += QT_DLL
</code></pre>
<p>这将会把 QT_DLL 添加到被放到 makefile 中的预处理定义的列表中。</p>
<p>“-=”操作符
这个操作符将会从一个变量的值的列表中移去一个值。使用方法如下：</p>
<pre><code>DEFINES -= QT_DLL
</code></pre>
<p>这将会从被放到 makefile 中的预处理定义的列表中移去 QT_DLL。</p>
<p>“*=”操作符
这个操作符仅仅在一个值不存在于一个变量的值的列表中的时候，把它添加进去。使用方法如下：</p>
<pre><code>DEFINES *= QT_DLL
</code></pre>
<p>只用在 QT_DLL 没有被定义在预处理定义的列表中时，它才会被添加进去。</p>
<p>“~=”操作符
这个操作符将会替换任何与指定的值的正则表达式匹配的任何值。使用方法如下：</p>
<pre><code>DEFINES ~= s/QT_[DT].+/QT
</code></pre>
<p>这将会用 QT 来替代任何以 QT_D 或 QT_T 开头的变量中的 QT_D 或 QT_T。</p>
<p>作用域
作用域和“if”语句很相似，如果某个条件为真，作用域中的设置就会被处理。作用域使用方法如下：</p>
<pre><code>win32 {
    DEFINES += QT_DLL
}
</code></pre>
<p>上面的代码的作用是，如果在 Windows 平台上使用 qmake，QT_DLL 定义就会被添加到 makefile 中。如果在 Windows 平台以外的平台上使用 qmake，这个定义就会被忽略。你也可以使用 qmake 执行一个单行的条件/任务，就像这样：</p>
<pre><code>win32:DEFINES += QT_DLL
</code></pre>
<p>比如，假设我们想在除了 Windows 平台意外的所有平台处理些什么。我们想这样使用作用域来达到这种否定效果：</p>
<pre><code>!win32 {
    DEFINES += QT_DLL
}
</code></pre>
<p>CONFIG 行中的任何条目也都是一个作用域。比如，你这样写：</p>
<pre><code>CONFIG += warn_on
</code></pre>
<p>你将会得到一个称作“warn_on”的作用域。这样将会使在不丢失特定条件下可能所需的所有自定义设置的条件下，很容易地修改项目中的配置。因为你可能把你自己的值放到 CONFIG 行中，这将会为你的 makefile 而提供给你一个非常强大的配置工具。比如：</p>
<pre><code>CONFIG += qt warn_on debug
debug {
    TARGET = myappdebug
}
release {
    TARGET = myapp
}
</code></pre>
<p>在上面的代码中，两个作用域被创建，它们依赖于 CONFIG 行中设置的是什么。在这个例子中，debug 在 CONFIG 行中，所以 TARGET 变量被设置为 myappdebug。如果 release 在 CONFIG 行中，那么 TARGET 变量将会被设置为 myapp。</p>
<p>当然也可以在处理一些设置之前检查两个事物。例如，如果你想检查平台是否是 Windows 并且线程设置是否被设定，你可以这样写：</p>
<pre><code>win32 {
    thread {
        DEFINES += QT_THREAD_SUPPORT
    }
}
</code></pre>
<p>为了避免写出许多嵌套作用域，你可以这样使用冒号来嵌套作用域：</p>
<pre><code>win32:thread {
    DEFINES += QT_THREAD_SUPPORT
}
</code></pre>
<p>一旦一个测试被执行，你也许也要做 else/elseif 操作。这种情况下，你可以很容易地写出复杂的测试。这需要使用特殊的“else”作用域，它可以和其它作用域进行组合（也可以向上面一样使用冒号），比如：</p>
<pre><code>win32:thread {
    DEFINES += QT_THREAD_SUPPORT
} else:debug {
    DEFINES += QT_NOTHREAD_DEBUG
} else {
    warning(&quot;Unknown configuration&quot;)
}
</code></pre>
<p>变量
到目前为止我们遇到的变量都是系统变量，比如 DEFINES、SOURCES 和 HEADERS。你也可以为你自己创建自己的变量，这样你就可以在作用域中使用它们了。创建自己的变量很容易，只要命名它并且分配一些东西给它。比如：</p>
<pre><code>MY_VARIABLE = value
</code></pre>
<p>现在你对你自己的变量做什么是没有限制的，同样地，qmake 将会忽略它们，除非需要在一个作用域中考虑它们。</p>
<p>你也可以通过在其它任何一个变量的变量名前加$$来把这个变量的值分配给当前的变量。例如：</p>
<pre><code>MY_DEFINES = $$DEFINES
</code></pre>
<p>现在 MY_DEFINES 变量包含了项目文件在这点时 DEFINES 变量的值。这也和下面的语句一样：</p>
<pre><code>MY_DEFINES = $${DEFINES}
</code></pre>
<p>第二种方法允许你把一个变量和其它变量连接起来，而不用使用空格。qmake 将允许一个变量包含任何东西（包括$(VALUE)，可以直接在makefile中直接放置，并且允许它适当地扩张，通常是一个环境变量）。无论如何，如果你需要立即设置一个环境变量，然后你就可以使用$$()方法。比如：</p>
<pre><code>MY_DEFINES = $$(ENV_DEFINES)
</code></pre>
<p>这将会设置 MY_DEFINES 为环境变量 ENV_DEFINES 传递给.pro 文件地值。另外你可以在替换的变量里调用内置函数。这些函数（不会和下一节中列举的测试函数混淆）列出如下：</p>
<p>join( variablename, glue, before, after )
这将会在 variablename 的各个值中间加入 glue。如果这个变量的值为非空，那么就会在值的前面加一个前缀 before 和一个后缀 after。只有 variablename 是必须的字段，其它默认情况下为空串。如果你需要在 glue、before 或者 after 中使用空格的话，你必须提供它们。</p>
<p>member( variablename, position )
这将会放置 variablename 的列表中的 position 位置的值。如果 variablename 不够长，这将会返回一个空串。variablename 是唯一必须的字段，如果没有指定位置，则默认为列表中的第一个值。</p>
<p>find( variablename, substr )
这将会放置 variablename 中所有匹配 substr 的值。substr 也可以是正则表达式，而因此将被匹配。</p>
<pre><code>MY_VAR = one two three four
MY_VAR2 = $$join(MY_VAR, &quot; -L&quot;, -L) -Lfive
MY_VAR3 = $$member(MY_VAR, 2) $$find(MY_VAR, t.*)
</code></pre>
<p>MY_VAR2 将会包含“-Lone -Ltwo -Lthree -Lfour -Lfive”，并且 MYVAR3 将会包含“three two three”。</p>
<p>system( program_and_args )
这将会返回程序执行在标准输出/标准错误输出的内容，并且正像平时所期待地分析它。比如你可以使用这个来询问有关平台的信息。</p>
<pre><code>UNAME = $$system(uname -s)
contains( UNAME, [lL]inux ):message( This looks like Linux ($$UNAME) to me )
</code></pre>
<p>测试函数
qmake 提供了可以简单执行，但强大测试的内置函数。这些测试也可以用在作用域中（就像上面一样），在一些情况下，忽略它的测试值，它自己使用测试函数是很有用的。</p>
<p>contains( variablename, value )
如果 value 存在于一个被叫做 variablename 的变量的值的列表中，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>contains( CONFIG, thread ) {
    DEFINES += QT_THREAD_SUPPORT
}
</code></pre>
<p>如果 thread 存在于 CONFIG 变量的值的列表中时，那么 QT_THREAD_SUPPORT 将会被加入到 DEFINES 变量的值的列表中。</p>
<p>count( variablename, number )
如果 number 与一个被叫做 variablename 的变量的值的数量一致，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>count( DEFINES, 5 ) {
    CONFIG += debug
}
</code></pre>
<p>error( string )
这个函数输出所给定的字符串，然后会使 qmake 退出。例如：</p>
<pre><code>error( &quot;An error has occured&quot; )
</code></pre>
<p>文本“An error has occured”将会被显示在控制台上并且 qmake 将会退出。</p>
<p>exists( filename )
如果指定文件存在，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>exists( /local/qt/qmake/main.cpp ) {
    SOURCES += main.cpp
}
</code></pre>
<p>如果/local/qt/qmake/main.cpp 存在，那么 main.cpp 将会被添加到源文件列表中。</p>
<p>注意可以不用考虑平台使用“/”作为目录的分隔符。</p>
<p>include( filename )
项目文件在这一点时包含这个文件名的内容，所以指定文件中的任何设置都将会被处理。例如：</p>
<pre><code>include( myotherapp.pro )
</code></pre>
<p>myotherapp.pro 项目文件中的任何设置现在都会被处理。</p>
<p>isEmpty( variablename )
这和使用 count( variablename, 0 )是一样的。如果叫做 variablename 的变量没有任何元素，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>isEmpty( CONFIG ) {
    CONFIG += qt warn_on debug
}
</code></pre>
<p>message( string )
这个函数只是简单地在控制台上输出消息。</p>
<pre><code>message( &quot;This is a message&quot; )
</code></pre>
<p>文本“This is a message”被输出到控制台上并且对于项目文件的处理将会继续进行。</p>
<p>system( command )
特定指令被执行并且如果它返回一个 1 的退出值，那么这个作用域中的设置将会被处理。例如：</p>
<pre><code>system( ls /bin ) {
    SOURCES += bin/main.cpp
    HEADERS += bin/main.h
}
</code></pre>
<p>所以如果命令 ls /bin 返回 1，那么 bin/main.cpp 将被添加到源文件列表中并且 bin/main.h 将被添加到头文件列表中。</p>
<p>infile( filename, var, val )
如果 filename 文件（当它被 qmake 自己解析时）包含一个值为 val 的变量 var，那么这个函数将会返回成功。你也可以不传递第三个参数（val），这时函数将只测试文件中是否分配有这样一个变量 var。</p>
<a class="header" href="print.html#qmake-变量大全" id="qmake-变量大全"><h1>Qmake 变量大全</h1></a>
<p>具体内容：<a href="http://doc.qt.io/qt-5/qmake-variable-reference.html#">doc.qt.io/qt-5/qmake-variable-reference.html#</a></p>
<a class="header" href="print.html#qmake-函数大全" id="qmake-函数大全"><h1>Qmake 函数大全</h1></a>
<p>参见：<a href="http://doc.qt.io/qt-5/qmake-function-reference.html">doc.qt.io/qt-5/qmake-function-reference.html</a></p>
<a class="header" href="print.html#qmake-测试函数" id="qmake-测试函数"><h1>Qmake 测试函数</h1></a>
<p>参见：<a href="http://doc.qt.io/qt-5/qmake-test-function-reference.html">doc.qt.io/qt-5/qmake-test-function-reference.html</a></p>
<a class="header" href="print.html#qmake-命令行" id="qmake-命令行"><h1>Qmake 命令行</h1></a>
<p><a href="http://doc.qt.io/qt-5/qmake-running.html">http://doc.qt.io/qt-5/qmake-running.html</a></p>
<p>Running qmake</p>
<p>The behavior of qmake can be customized when it is run by specifying various options on the command line. These allow the build process to be fine-tuned, provide useful diagnostic information, and can be used to specify the target platform for your project.
Command Syntax</p>
<p>The syntax used to run qmake takes the following simple form:</p>
<p>qmake [mode][options] files</p>
<p>Operating Modes</p>
<p>qmake supports two different modes of operation. In the default mode, qmake uses the information in a project file to generate a Makefile, but it is also possible to use qmake to generate project files. If you want to explicitly set the mode, you must specify it before all other options. The mode can be either of the following two values:</p>
<pre><code>-makefile
qmake output will be a Makefile.
-project
qmake output will be a project file.

Note: It is likely that the created file will need to be edited. For example, adding the QT variable to suit what modules are required for the project.
</code></pre>
<p>You can use the options to specify both general and mode-specific settings. Options that only apply to the Makefile mode are described in the Makefile Mode Options section, whereas options that influence the creation of project files are described in the Project Mode Options section.
Files</p>
<p>The files argument represents a list of one or more project files, separated by spaces.
General Options</p>
<p>A wide range of options can be specified on the command line to qmake in order to customize the build process, and to override default settings for your platform. The following basic options provide help on using qmake, specify where qmake writes the output file, and control the level of debugging information that will be written to the console:</p>
<pre><code>-help
qmake will go over these features and give some useful help.
-o file
qmake output will be directed to file. If this option is not specified, qmake will try to use a suitable file name for its output, depending on the mode it is running in.
If '-' is specified, output is directed to stdout.
-d
qmake will output debugging information. Adding -d more than once increases verbosity.
</code></pre>
<p>The template used for the project is usually specified by the TEMPLATE variable in the project file. You can override or modify this by using the following options:</p>
<pre><code>-t tmpl
qmake will override any set TEMPLATE variables with tmpl, but only after the .pro file has been processed.
-tp prefix
qmake will add prefix to the TEMPLATE variable.
</code></pre>
<p>The level of warning information can be fine-tuned to help you find problems in your project file:</p>
<pre><code>-Wall
qmake will report all known warnings.
-Wnone
No warning information will be generated by qmake.
-Wparser
qmake will only generate parser warnings. This will alert you to common pitfalls and potential problems in the parsing of your project files.
-Wlogic
qmake will warn of common pitfalls and potential problems in your project file. For example, qmake will report multiple occurrences of files in lists and missing files.
</code></pre>
<p>Makefile Mode Options</p>
<p>qmake -makefile [options] files</p>
<p>In Makefile mode, qmake will generate a Makefile that is used to build the project. Additionally, the following options may be used in this mode to influence the way the project file is generated:</p>
<pre><code>-after
qmake will process assignments given on the command line after the specified files.
-nocache
qmake will ignore the .qmake.cache file.
-nodepend
qmake will not generate any dependency information.
-cache file
qmake will use file as the cache file, ignoring any other .qmake.cache files found.
-spec spec
qmake will use spec as a path to platform and compiler information, and ignore the value of QMAKESPEC.
</code></pre>
<p>You may also pass qmake assignments on the command line. They are processed before all of the files specified. For example, the following command generates a Makefile from test.pro:</p>
<p>qmake -makefile -o Makefile &quot;CONFIG+=test&quot; test.pro</p>
<p>However, some of the specified options can be omitted as they are default values:</p>
<p>qmake &quot;CONFIG+=test&quot; test.pro</p>
<p>If you are certain you want your variables processed after the files specified, then you may pass the -after option. When this is specified, all assignments on the command line after the -after option will be postponed until after the specified files are parsed.
Project Mode Options</p>
<p>qmake -project [options] files</p>
<p>In project mode, qmake will generate a project file. Additionally, you may supply the following options in this mode:</p>
<pre><code>-r
qmake will look through supplied directories recursively.
-nopwd
qmake will not look in your current working directory for source code. It will only use the specified files.
</code></pre>
<p>In this mode, the files argument can be a list of files or directories. If a directory is specified, it will be included in the DEPENDPATH variable, and relevant code from there will be included in the generated project file. If a file is given, it will be appended to the correct variable, depending on its extension. For example, UI files are added to FORMS, and C++ files are added to SOURCES.</p>
<p>You may also pass assignments on the command line in this mode. When doing so, these assignments will be placed last in the generated project file.</p>
<a class="header" href="print.html#pro-示例-1" id="pro-示例-1"><h1>Pro 示例 1</h1></a>
<pre><code class="language-pro">#-------------------------------------------------
#
# Project created by QtCreator 2013-05-20T13:22:23
#
#-------------------------------------------------

##
## Pre-defined global variables
##

CONFIG(debug, debug|release) {
    DIR_SUFFIX = d
} else {
    DIR_SUFFIX =
}

!contains(QMAKE_HOST.arch, x86_64) {
    X64_BIN_DIR = ../../bin/x32$${DIR_SUFFIX}      # Relative BIN path, 32-bit
    X64_GEN_DIR = ../gui_build/out32$${DIR_SUFFIX} # QMake temporary generated files, placed inside the build folder. (OBJ, UI, MOC)
    TARGET = x32gui                  # Build x32gui
} else {
    X64_BIN_DIR = ../../bin/x64$${DIR_SUFFIX}      # Relative BIN path, 64-bit
    X64_GEN_DIR = ../gui_build/out64$${DIR_SUFFIX} # QMake temporary generated files, placed inside the build folder. (OBJ, UI, MOC)
    TARGET = x64gui                  # Build x64gui
}

##
## QMake output directories
##
DESTDIR = $${X64_BIN_DIR}
OBJECTS_DIR = $${X64_GEN_DIR}
MOC_DIR = $${X64_GEN_DIR}
RCC_DIR = $${X64_GEN_DIR}
UI_DIR = $${X64_GEN_DIR}

##
## QT libraries
##
QT += core gui network

# QT5 requires widgets
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

##
## Build flags
##
# Generate debug symbols in release mode
QMAKE_CXXFLAGS_RELEASE += -Zi   # Compiler
QMAKE_LFLAGS_RELEASE += /DEBUG  # Linker

# Build as a library
DEFINES += BUILD_LIB NOMINMAX
TEMPLATE = lib

##
## Includes
##
INCLUDEPATH += \
    ../ \
    Src \
    Src/Gui \
    Src/BasicView \
    Src/Disassembler \
    Src/Memory \
    Src/Bridge \
    Src/Global \
    Src/Utils \
    Src/ThirdPartyLibs/snowman \
    Src/ThirdPartyLibs/ldconvert \
    ../zydis_wrapper \
    ../zydis_wrapper/zydis/include

# Resources, sources, headers, and forms
RESOURCES += \
    resource.qrc

SOURCES += \
    Src/main.cpp \
    Src/Gui/MainWindow.cpp \
    Src/Gui/CPUWidget.cpp \
    Src/Gui/CommandLineEdit.cpp \
    Src/BasicView/Disassembly.cpp \
    Src/BasicView/HexDump.cpp \
    Src/BasicView/AbstractTableView.cpp \
    Src/Disassembler/QBeaEngine.cpp \
    Src/Disassembler/ZydisTokenizer.cpp \
    Src/Memory/MemoryPage.cpp \
    Src/Bridge/Bridge.cpp \
    Src/BasicView/StdTable.cpp \
    Src/Gui/MemoryMapView.cpp \
    Src/Gui/LogView.cpp \
    Src/Gui/GotoDialog.cpp \
    Src/Gui/WordEditDialog.cpp \
    Src/Gui/CPUDisassembly.cpp \
    Src/Gui/LineEditDialog.cpp \
    Src/Gui/BreakpointsView.cpp \
    Src/Utils/Breakpoints.cpp \
    Src/Gui/CPUInfoBox.cpp \
    Src/Gui/CPUDump.cpp \
    Src/Gui/ScriptView.cpp \
    Src/Gui/CPUStack.cpp \
    Src/Gui/SymbolView.cpp \
    Src/Gui/RegistersView.cpp \
    Src/BasicView/SearchListView.cpp \
    Src/BasicView/ReferenceView.cpp \
    Src/Gui/ThreadView.cpp \
    Src/Gui/SettingsDialog.cpp \
    Src/Gui/ExceptionRangeDialog.cpp \
    Src/Utils/RichTextPainter.cpp \
    Src/Gui/TabBar.cpp \
    Src/Gui/TabWidget.cpp \
    Src/BasicView/HistoryLineEdit.cpp \
    Src/Utils/Configuration.cpp \
    Src/Gui/CPUSideBar.cpp \
    Src/Gui/AppearanceDialog.cpp \
    Src/Gui/CloseDialog.cpp \
    Src/Gui/HexEditDialog.cpp \
    Src/Gui/HexLineEdit.cpp \
    Src/QHexEdit/ArrayCommand.cpp \
    Src/QHexEdit/QHexEdit.cpp \
    Src/QHexEdit/QHexEditPrivate.cpp \
    Src/QHexEdit/XByteArray.cpp \
    Src/Gui/PatchDialog.cpp \
    Src/Gui/PatchDialogGroupSelector.cpp \
    Src/Utils/UpdateChecker.cpp \
    Src/Gui/CallStackView.cpp \
    Src/Gui/ShortcutsDialog.cpp \
    Src/BasicView/ShortcutEdit.cpp \
    Src/Gui/CalculatorDialog.cpp \
    Src/Gui/AttachDialog.cpp \
    Src/Gui/PageMemoryRights.cpp \
    Src/Gui/SelectFields.cpp \
    Src/Gui/ReferenceManager.cpp \
    Src/Bridge/BridgeResult.cpp \
    Src/Gui/YaraRuleSelectionDialog.cpp \
    Src/Gui/SourceViewerManager.cpp \
    Src/Gui/SourceView.cpp \
    Src/Utils/ValidateExpressionThread.cpp \
    Src/Utils/MainWindowCloseThread.cpp \
    Src/Gui/TimeWastedCounter.cpp \
    Src/Utils/FlickerThread.cpp \
    Src/QEntropyView/QEntropyView.cpp \
    Src/Gui/EntropyDialog.cpp \
    Src/Gui/NotesManager.cpp \
    Src/Gui/NotepadView.cpp \
    Src/Gui/CPUMultiDump.cpp \
    Src/Gui/AssembleDialog.cpp \
    Src/Utils/StringUtil.cpp \
    Src/Gui/SEHChainView.cpp \
    Src/Gui/EditBreakpointDialog.cpp \
    Src/Gui/CPUArgumentWidget.cpp \
    Src/Gui/HandlesView.cpp \
    Src/Gui/EditFloatRegister.cpp \
    Src/Utils/HexValidator.cpp \
    Src/Utils/LongLongValidator.cpp \
    Src/Utils/MiscUtil.cpp \
    Src/Gui/XrefBrowseDialog.cpp \
    Src/Gui/CodepageSelectionDialog.cpp \
    Src/Gui/ColumnReorderDialog.cpp \
    Src/Utils/EncodeMap.cpp \
    Src/Utils/CodeFolding.cpp \
    Src/Gui/WatchView.cpp \
    Src/Gui/FavouriteTools.cpp \
    Src/Gui/BrowseDialog.cpp \
    Src/Gui/DisassemblerGraphView.cpp \
    Src/Gui/DisassemblyPopup.cpp \
    Src/Gui/VirtualModDialog.cpp \
    Src/BasicView/LabeledSplitter.cpp \
    Src/BasicView/LabeledSplitterDetachedWindow.cpp \
    Src/Gui/LogStatusLabel.cpp \
    Src/Gui/DebugStatusLabel.cpp \
    Src/Utils/MenuBuilder.cpp \
    Src/Gui/StructWidget.cpp \
    Src/Gui/CustomizeMenuDialog.cpp \
    Src/Gui/SimpleTraceDialog.cpp \
    Src/Utils/MRUList.cpp \
    Src/Gui/LocalVarsView.cpp \
    Src/Gui/MessagesBreakpoints.cpp \
    Src/Gui/AboutDialog.cpp \
    Src/Gui/BreakpointMenu.cpp \
    Src/Gui/ComboBoxDialog.cpp \
    Src/Utils/SymbolAutoCompleteModel.cpp \
    Src/Tracer/TraceBrowser.cpp \
    Src/Tracer/TraceFileReader.cpp \
    Src/Tracer/TraceFileSearch.cpp \
    Src/Gui/MultiItemsSelectWindow.cpp \
    Src/BasicView/AbstractStdTable.cpp \
    Src/Gui/ZehSymbolTable.cpp \
    Src/BasicView/StdSearchListView.cpp


HEADERS += \
    Src/main.h \
    Src/Gui/MainWindow.h \
    Src/Gui/CPUWidget.h \
    Src/Gui/CommandLineEdit.h \
    Src/BasicView/Disassembly.h \
    Src/BasicView/HexDump.h \
    Src/BasicView/AbstractTableView.h \
    Src/Disassembler/QBeaEngine.h \
    Src/Disassembler/ZydisTokenizer.h \
    Src/Memory/MemoryPage.h \
    Src/Bridge/Bridge.h \
    Src/Exports.h \
    Src/Imports.h \
    Src/BasicView/StdTable.h \
    Src/Gui/MemoryMapView.h \
    Src/Gui/LogView.h \
    Src/Gui/GotoDialog.h \
    Src/Gui/RegistersView.h \
    Src/Gui/WordEditDialog.h \
    Src/Gui/CPUDisassembly.h \
    Src/Gui/LineEditDialog.h \
    Src/Gui/BreakpointsView.h \
    Src/Utils/Breakpoints.h \
    Src/Gui/CPUInfoBox.h \
    Src/Gui/CPUDump.h \
    Src/Gui/ScriptView.h \
    Src/Gui/CPUStack.h \
    Src/Gui/SymbolView.h \
    Src/BasicView/SearchListView.h \
    Src/BasicView/ReferenceView.h \
    Src/Gui/ThreadView.h \
    Src/Gui/SettingsDialog.h \
    Src/Gui/ExceptionRangeDialog.h \
    Src/Utils/RichTextPainter.h \
    Src/Gui/TabBar.h \
    Src/Gui/TabWidget.h \
    Src/BasicView/HistoryLineEdit.h \
    Src/Utils/Configuration.h \
    Src/Gui/CPUSideBar.h \
    Src/Gui/AppearanceDialog.h \
    Src/Gui/CloseDialog.h \
    Src/Gui/HexEditDialog.h \
    Src/Gui/HexLineEdit.h \
    Src/QHexEdit/ArrayCommand.h \
    Src/QHexEdit/QHexEdit.h \
    Src/QHexEdit/QHexEditPrivate.h \
    Src/QHexEdit/XByteArray.h \
    Src/Gui/PatchDialog.h \
    Src/Gui/PatchDialogGroupSelector.h \
    Src/Utils/UpdateChecker.h \
    Src/Gui/CallStackView.h \
    Src/Gui/ShortcutsDialog.h \
    Src/BasicView/ShortcutEdit.h \
    Src/Gui/CalculatorDialog.h \
    Src/Gui/AttachDialog.h \
    Src/Gui/PageMemoryRights.h \
    Src/Gui/SelectFields.h \
    Src/Gui/ReferenceManager.h \
    Src/Bridge/BridgeResult.h \
    Src/Gui/YaraRuleSelectionDialog.h \
    Src/Gui/SourceViewerManager.h \
    Src/Gui/SourceView.h \
    Src/Utils/StringUtil.h \
    Src/Utils/ValidateExpressionThread.h \
    Src/Utils/MainWindowCloseThread.h \
    Src/Gui/TimeWastedCounter.h \
    Src/Utils/FlickerThread.h \
    Src/QEntropyView/Entropy.h \
    Src/QEntropyView/QEntropyView.h \
    Src/Gui/EntropyDialog.h \
    Src/Gui/NotesManager.h \
    Src/Gui/NotepadView.h \
    Src/Utils/MenuBuilder.h \
    Src/Gui/CPUMultiDump.h \
    Src/Gui/AssembleDialog.h \
    Src/Gui/SEHChainView.h \
    Src/Gui/EditBreakpointDialog.h \
    Src/Gui/CPUArgumentWidget.h \
    Src/Gui/HandlesView.h \
    Src/Gui/EditFloatRegister.h \
    Src/Utils/HexValidator.h \
    Src/Utils/LongLongValidator.h \
    Src/Utils/MiscUtil.h \
    Src/Gui/XrefBrowseDialog.h \
    Src/Gui/CodepageSelectionDialog.h \
    Src/Utils/CachedFontMetrics.h \
    Src/Gui/ColumnReorderDialog.h \
    Src/Utils/EncodeMap.h \
    Src/Utils/CodeFolding.h \
    Src/Gui/WatchView.h \
    Src/Gui/FavouriteTools.h \
    Src/Gui/BrowseDialog.h \
    Src/Gui/DisassemblerGraphView.h \
    Src/Utils/ActionHelpers.h \
    Src/Gui/DisassemblyPopup.h \
    Src/Gui/VirtualModDialog.h \
    Src/BasicView/LabeledSplitter.h \
    Src/BasicView/LabeledSplitterDetachedWindow.h \
    Src/Gui/LogStatusLabel.h \
    Src/Gui/DebugStatusLabel.h \
    Src/Gui/CustomizeMenuDialog.h \
    Src/Gui/StructWidget.h \
    Src/Gui/SimpleTraceDialog.h \
    Src/Utils/MRUList.h \
    Src/Gui/LocalVarsView.h \
    Src/Gui/MessagesBreakpoints.h \
    Src/Gui/AboutDialog.h \
    Src/Gui/BreakpointMenu.h \
    Src/Gui/ComboBoxDialog.h \
    Src/Utils/VaHistory.h \
    Src/Utils/SymbolAutoCompleteModel.h \
    Src/Tracer/TraceBrowser.h \
    Src/Tracer/TraceFileReader.h \
    Src/Tracer/TraceFileReaderInternal.h \
    Src/Tracer/TraceFileSearch.h \
    Src/Gui/MultiItemsSelectWindow.h \
    Src/BasicView/AbstractStdTable.h \
    Src/Gui/ZehSymbolTable.h \
    Src/BasicView/AbstractSearchList.h \
    Src/BasicView/StdSearchListView.h


FORMS += \
    Src/Gui/MainWindow.ui \
    Src/Gui/CPUWidget.ui \
    Src/Gui/GotoDialog.ui \
    Src/Gui/WordEditDialog.ui \
    Src/Gui/LineEditDialog.ui \
    Src/Gui/SymbolView.ui \
    Src/Gui/SettingsDialog.ui \
    Src/Gui/ExceptionRangeDialog.ui \
    Src/Gui/AppearanceDialog.ui \
    Src/Gui/CloseDialog.ui \
    Src/Gui/HexEditDialog.ui \
    Src/Gui/HexLineEdit.ui \
    Src/Gui/PatchDialog.ui \
    Src/Gui/PatchDialogGroupSelector.ui \
    Src/Gui/ShortcutsDialog.ui \
    Src/Gui/CalculatorDialog.ui \
    Src/Gui/AttachDialog.ui \
    Src/Gui/PageMemoryRights.ui \
    Src/Gui/SelectFields.ui \
    Src/Gui/YaraRuleSelectionDialog.ui \
    Src/Gui/EntropyDialog.ui \
    Src/Gui/AssembleDialog.ui \
    Src/Gui/EditBreakpointDialog.ui \
    Src/Gui/CPUArgumentWidget.ui \
    Src/Gui/EditFloatRegister.ui \
    Src/Gui/XrefBrowseDialog.ui \
    Src/Gui/CodepageSelectionDialog.ui \
    Src/Gui/ColumnReorderDialog.ui \
    Src/Gui/FavouriteTools.ui \
    Src/Gui/BrowseDialog.ui \
    Src/Gui/VirtualModDialog.ui \
    Src/Gui/CustomizeMenuDialog.ui \
    Src/Gui/StructWidget.ui \
    Src/Gui/SimpleTraceDialog.ui \
    Src/Gui/MessagesBreakpoints.ui \
    Src/Gui/AboutDialog.ui \
    Src/Gui/ComboBoxDialog.ui

##
## Libraries
##
LIBS += -luser32 -ladvapi32 -lwinmm -lshell32

!contains(QMAKE_HOST.arch, x86_64) {
    # Windows x86 (32bit) specific build
    LIBS += -L&quot;$$PWD/../zydis_wrapper/bin/x32$${DIR_SUFFIX}&quot; -lzydis_wrapper
    LIBS += -L&quot;$$PWD/Src/ThirdPartyLibs/snowman&quot; -lsnowman_x86
    LIBS += -L&quot;$$PWD/Src/ThirdPartyLibs/ldconvert&quot; -lldconvert_x86
    LIBS += -L&quot;$${X64_BIN_DIR}&quot; -lx32bridge
} else {
    # Windows x64 (64bit) specific build
    LIBS += -L&quot;$$PWD/../zydis_wrapper/bin/x64$${DIR_SUFFIX}&quot; -lzydis_wrapper
    LIBS += -L&quot;$$PWD/Src/ThirdPartyLibs/snowman&quot; -lsnowman_x64
    LIBS += -L&quot;$$PWD/Src/ThirdPartyLibs/ldconvert&quot; -lldconvert_x64
    LIBS += -L&quot;$${X64_BIN_DIR}&quot; -lx64bridge
}

</code></pre>
<a class="header" href="print.html#pro-示例-2" id="pro-示例-2"><h1>Pro 示例 2</h1></a>
<a class="header" href="print.html#static-library" id="static-library"><h1>static library</h1></a>
<a class="header" href="print.html#dynamic-library" id="dynamic-library"><h1>dynamic library</h1></a>
<a class="header" href="print.html#framework" id="framework"><h1>framework</h1></a>
<a class="header" href="print.html#a创建-plugin" id="a创建-plugin"><h1>创建 Plugin</h1></a>
<a class="header" href="print.html#macos-如何使用-qt-创建静态库" id="macos-如何使用-qt-创建静态库"><h1>MacOS 如何使用 Qt 创建静态库?</h1></a>
<a class="header" href="print.html#a使用-qt-creator-创建静态-library-我们得到最初的pro文件" id="a使用-qt-creator-创建静态-library-我们得到最初的pro文件"><h2>使用 Qt Creator 创建静态 library, 我们得到最初的<code>pro</code>文件</h2></a>
<p><code>/code-src/for_mac/static_link_library/matrix/matrixref/matrixref.pro</code></p>
<pre><code class="language-qt.pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-26T15:05:13
#
#-------------------------------------------------

# 仅依赖QtCore
QT       -= gui

TARGET = matrixref
TEMPLATE = lib
CONFIG += staticlib

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
        matrixref.cpp

HEADERS += \
        matrixref.h
unix {
    target.path = /usr/lib
    INSTALLS += target
}

</code></pre>
<a class="header" href="print.html#a使用-qt-creator-创建一个控制台-我们得到最初的pro文件" id="a使用-qt-creator-创建一个控制台-我们得到最初的pro文件"><h2>使用 Qt Creator 创建一个控制台, 我们得到最初的<code>pro</code>文件</h2></a>
<p><code>/code-src/for_mac/static_link_library/matrix/matrxref_console/matrxref_console.pro</code></p>
<pre><code class="language-pro">QT -= gui

CONFIG += c++11 console
CONFIG -= app_bundle

# The following define makes your compiler emit warnings if you use
# any Qt feature that has been marked deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
        main.cpp

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

</code></pre>
<a class="header" href="print.html#a修改-matrxref_consolepro-文件增加外部库的引用说明" id="a修改-matrxref_consolepro-文件增加外部库的引用说明"><h2>修改 <code>matrxref_console.pro</code> 文件，增加外部库的引用说明</h2></a>
<p>修改 <code>/code-src/for_mac/static_link_library/matrix/matrxref_console/matrxref_console.pro</code> 文件</p>
<p>增加如下代码：</p>
<pre><code class="language-pro"># 使用外部库
macx{
    LIBS += -L$$PWD/../build-matrixref-Desktop_Qt_5_12_0_clang_64bit2-Debug/ -lmatrixref
    INCLUDEPATH += $$PWD/../matrixref
    DEPENDPATH += $$PWD/../matrixref
    PRE_TARGETDEPS += $$PWD/../build-matrixref-Desktop_Qt_5_12_0_clang_64bit2-Debug/libmatrixref.a
}
</code></pre>
<a class="header" href="print.html#a看看源码的调用" id="a看看源码的调用"><h2>看看源码的调用</h2></a>
<p>发现几个有意思的问题：
（1）Mac 版本的静态库 matrixref 没有显示定义任何一个导出函数，不知道 Windows 版本上如何？</p>
<pre><code class="language-C++">#if defined __cplusplus
    #include &lt;iostream&gt;
#endif

#include &lt;QCoreApplication&gt;
#include &quot;matrixref.h&quot; // 引用静态库的头文件

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    TechiDaily::Matrixref ref;

#if defined __cplusplus
    std::cout &lt;&lt; ref.hi() &lt;&lt; std::endl;
#endif

    return a.exec();
}
</code></pre>
<a class="header" href="print.html#macos-如何使用-qt-创建动态库" id="macos-如何使用-qt-创建动态库"><h1>MacOS 如何使用 Qt 创建动态库?</h1></a>
<a class="header" href="print.html#a使用-qt-creator-创建动态-library-我们得到最初的pro文件" id="a使用-qt-creator-创建动态-library-我们得到最初的pro文件"><h2>使用 Qt Creator 创建动态 library, 我们得到最初的<code>pro</code>文件</h2></a>
<p><img src="qmake/images/mac-create-dynamic-library-01.png" alt="" />
<img src="qmake/images/mac-create-dynamic-library-02.png" alt="" />
<img src="qmake/images/mac-create-dynamic-library-03.png" alt="" />
<img src="qmake/images/mac-create-dynamic-library-04.png" alt="" />
<img src="qmake/images/mac-create-dynamic-library-05.png" alt="" /></p>
<p><code>/code-src/for_mac/dynamic_link_library/linear/linearRef/linearRef.pro</code> 文件内容</p>
<pre><code class="language-pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T08:58:42
#
#-------------------------------------------------

QT       -= gui

TARGET = linearRef
TEMPLATE = lib

DEFINES += LINEARREF_LIBRARY

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
        linearref.cpp

HEADERS += \
        linearref.h \
        linearref_global.h

unix {
    target.path = /usr/lib
    INSTALLS += target
}

</code></pre>
<a class="header" href="print.html#a使用-qt-creator-创建一个桌面应用-我们得到最初的pro文件" id="a使用-qt-creator-创建一个桌面应用-我们得到最初的pro文件"><h2>使用 Qt Creator 创建一个桌面应用, 我们得到最初的<code>pro</code>文件</h2></a>
<p>查看 <code>/code-src/for_mac/dynamic_link_library/linear/linearApp/linearApp.pro</code> 文件内容</p>
<pre><code class="language-toml">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T09:06:42
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = linearApp
TEMPLATE = app

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

CONFIG += c++11

SOURCES += \
        main.cpp \
        mainwindow.cpp

HEADERS += \
        mainwindow.h

FORMS += \
        mainwindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

</code></pre>
<a class="header" href="print.html#a加入引用动态库的代码" id="a加入引用动态库的代码"><h2>加入引用动态库的代码</h2></a>
<p>现在在观察一下<code>/code-src/for_mac/dynamic_link_library/linear/linearApp/linearApp.pro</code> 文件内容</p>
<pre><code class="language-Pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T09:06:42
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = linearApp
TEMPLATE = app

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

CONFIG += c++11

SOURCES += \
        main.cpp \
        mainwindow.cpp

HEADERS += \
        mainwindow.h

FORMS += \
        mainwindow.ui

# 链接外部库
macx {
    LIBS += -L$$PWD/../build-linearRef-Desktop_Qt_5_12_0_clang_64bit2-Debug/ -llinearRef.1.0.0
    INCLUDEPATH += $$PWD/../linearRef
    DEPENDPATH += $$PWD/../linearRef
}

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target



</code></pre>
<a class="header" href="print.html#a现在查看代码的变化" id="a现在查看代码的变化"><h2>现在查看代码的变化</h2></a>
<p><code>code-src/for_mac/dynamic_link_library/linear/linearRef/linearref_global.h</code></p>
<pre><code class="language-h">#ifndef LINEARREF_GLOBAL_H
#define LINEARREF_GLOBAL_H

#include &lt;QtCore/qglobal.h&gt;

#if defined(LINEARREF_LIBRARY)
#  define LINEARREFSHARED_EXPORT Q_DECL_EXPORT
#else
#  define LINEARREFSHARED_EXPORT Q_DECL_IMPORT
#endif

#endif // LINEARREF_GLOBAL_H
</code></pre>
<p><strong>注意：新建了 LINEARREFSHARED_EXPORT 宏</strong></p>
<p><code>code-src/for_mac/dynamic_link_library/linear/linearRef/linearref.h</code></p>
<pre><code class="language-h">#ifndef LINEARREF_H
#define LINEARREF_H

#include &quot;linearref_global.h&quot;

namespace TechiDaily{
class LINEARREFSHARED_EXPORT LinearRef
{

public:
    LinearRef();
    const char* getName();
};
}


#endif // LINEARREF_H

</code></pre>
<a class="header" href="print.html#macos-如何使用-qt-创建-framework" id="macos-如何使用-qt-创建-framework"><h1>MacOS 如何使用 Qt 创建 Framework?</h1></a>
<a class="header" href="print.html#linux-如何使用-qt-创建静态库" id="linux-如何使用-qt-创建静态库"><h1>Linux 如何使用 Qt 创建静态库?</h1></a>
<p><img src="qmake/images/win-create-static-library-01.jpg" alt="" />
<img src="qmake/images/win-create-static-library-02.jpg" alt="" />
<img src="qmake/images/win-create-static-library-03.jpg" alt="" />
<img src="qmake/images/win-create-static-library-04.jpg" alt="" />
<img src="qmake/images/win-create-static-library-05.jpg" alt="" /></p>
<a class="header" href="print.html#a使用qt-creator-创建windows-的静态库" id="a使用qt-creator-创建windows-的静态库"><h2>使用Qt Creator 创建Windows 的静态库</h2></a>
<p>查看 <code>\code-src\for_win\static_link_library\printor\PrintorRef\PrintorRef.pro</code> 文件内容</p>
<pre><code class="language-pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T14:06:49
#
#-------------------------------------------------

QT       -= gui

TARGET = PrintorRef
TEMPLATE = lib
CONFIG += staticlib #静态库

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
        printorref.cpp

HEADERS += \
        printorref.h
unix {
    target.path = /usr/lib
    INSTALLS += target
}
</code></pre>
<a class="header" href="print.html#a使用qt-creator-创建windows-桌面程序引用静态库" id="a使用qt-creator-创建windows-桌面程序引用静态库"><h2>使用Qt Creator 创建Windows 桌面程序，引用静态库</h2></a>
<p>查看 <code>code-src\for_win\static_link_library\printor\PrintorCall\PrintorCall.pro</code></p>
<pre><code class="language-pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T14:16:32
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = PrintorCall
TEMPLATE = app

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

CONFIG += c++11

SOURCES += \
        main.cpp \
        mainwindow.cpp

HEADERS += \
        mainwindow.h

FORMS += \
        mainwindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

</code></pre>
<p>可以使用下面的方式，添加静态库引用</p>
<p><img src="qmake/images/win-create-static-library-06.jpg" alt="" />
<img src="qmake/images/win-create-static-library-07.jpg" alt="" />
<img src="qmake/images/win-create-static-library-08.jpg" alt="" /></p>
<p>最终，我们可以查看一下<strong>整理后</strong>的<code>PrintorCall.pro</code>文件内容</p>
<pre><code class="language-pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T14:16:32
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = PrintorCall
TEMPLATE = app

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

CONFIG += c++11

SOURCES += \
        main.cpp \
        mainwindow.cpp

HEADERS += \
        mainwindow.h

FORMS += \
        mainwindow.ui

# 引用静态库
win32: LIBS += -L$$PWD/../build-PrintorRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/debug/ -lPrintorRef

INCLUDEPATH += $$PWD/../PrintorRef
DEPENDPATH += $$PWD/../PrintorRef

win32:!win32-g++: PRE_TARGETDEPS += $$PWD/../build-PrintorRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/debug/PrintorRef.lib
else:win32-g++: PRE_TARGETDEPS += $$PWD/../build-PrintorRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/debug/libPrintorRef.a


# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

</code></pre>
<p>关键代码：</p>
<pre><code class="language-pro"># 引用静态库
win32: LIBS += -L$$PWD/../build-PrintorRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/debug/ -lPrintorRef

INCLUDEPATH += $$PWD/../PrintorRef
DEPENDPATH += $$PWD/../PrintorRef

win32:!win32-g++: PRE_TARGETDEPS += $$PWD/../build-PrintorRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/debug/PrintorRef.lib
else:win32-g++: PRE_TARGETDEPS += $$PWD/../build-PrintorRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/debug/libPrintorRef.a

</code></pre>
<a class="header" href="print.html#a下面我们看一下静态库中的定义内容" id="a下面我们看一下静态库中的定义内容"><h2>下面，我们看一下静态库中的定义内容</h2></a>
<p><code>printorref.h</code> 文件</p>
<pre><code class="language-h">#ifndef PRINTORREF_H
#define PRINTORREF_H

namespace TechiDaily {
class PrintorRef
{

public:
    PrintorRef();
    const char* hi();
};
}

#endif // PRINTORREF_H
</code></pre>
<p><code>printorref.cpp</code> 文件</p>
<pre><code class="language-c++">#include &quot;printorref.h&quot;


namespace TechiDaily {
//![0]
PrintorRef::PrintorRef()
{
}

const char *PrintorRef::hi()
{
    return &quot;Hi! I'm PrintorRef&quot;;
}
//![0]
}

</code></pre>
<a class="header" href="print.html#a下面我们看一下调用者的代码" id="a下面我们看一下调用者的代码"><h2>下面我们看一下调用者的代码</h2></a>
<pre><code class="language-cpp">#if defined __cplusplus
#include &lt;iostream&gt;
#endif

#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;

#include &quot;printorref.h&quot; // 引用第三方库

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_testBtn_clicked()
{
    TechiDaily::PrintorRef ref;
#if defined __cplusplus
    std::cout &lt;&lt; ref.hi() &lt;&lt; std::endl;
#endif

}

</code></pre>
<a class="header" href="print.html#windows创建动态库" id="windows创建动态库"><h1>(Windows)创建动态库?</h1></a>
<p><img src="qmake/images/win-create-dynamic-library-01.jpg" alt="" />
<img src="qmake/images/win-create-dynamic-library-02.jpg" alt="" />
<img src="qmake/images/win-create-dynamic-library-03.jpg" alt="" />
<img src="qmake/images/win-create-dynamic-library-04.jpg" alt="" />
<img src="qmake/images/win-create-dynamic-library-05.jpg" alt="" /></p>
<a class="header" href="print.html#a使用qt-creator-创建windows-的动态库" id="a使用qt-creator-创建windows-的动态库"><h2>使用Qt Creator 创建Windows 的动态库</h2></a>
<p>查看 <code>code-src\for_win\dynamic_link_library\ExtendBest\ExtendBestRef\ExtendBestRef.pro</code> 文件内容</p>
<pre><code class="language-pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T15:36:51
#
#-------------------------------------------------

QT       -= gui

TARGET = ExtendBestRef
TEMPLATE = lib

DEFINES += EXTENDBESTREF_LIBRARY

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

SOURCES += \
        extendbestref.cpp

HEADERS += \
        extendbestref.h \
        extendbestref_global.h 

unix {
    target.path = /usr/lib
    INSTALLS += target
}

</code></pre>
<a class="header" href="print.html#a动态库源码部分" id="a动态库源码部分"><h2>动态库源码部分</h2></a>
<ol>
<li>
<p><code>extendbestref_global.h</code></p>
<pre><code class="language-h">#ifndef EXTENDBESTREF_GLOBAL_H
#define EXTENDBESTREF_GLOBAL_H

#include &lt;QtCore/qglobal.h&gt;

#if defined(EXTENDBESTREF_LIBRARY)
#  define EXTENDBESTREFSHARED_EXPORT Q_DECL_EXPORT
#else
#  define EXTENDBESTREFSHARED_EXPORT Q_DECL_IMPORT
#endif

#endif // EXTENDBESTREF_GLOBAL_H

</code></pre>
</li>
<li>
<p><code>extendbestref.h</code></p>
<pre><code class="language-h">#ifndef EXTENDBESTREF_H
#define EXTENDBESTREF_H

#include &quot;extendbestref_global.h&quot;
namespace TechiDaily {

class EXTENDBESTREFSHARED_EXPORT ExtendBestRef
{

public:
    ExtendBestRef();
    const char* hi();
};
}

#endif // EXTENDBESTREF_H
</code></pre>
</li>
<li>
<p><code>extendbestref.cpp</code></p>
</li>
</ol>
<pre><code class="language-cpp">#include &quot;extendbestref.h&quot;

namespace TechiDaily {

ExtendBestRef::ExtendBestRef()
{
}

const char* ExtendBestRef::hi()
{
    return &quot;I'm ExtendBest Ref&quot;;
}
}
</code></pre>
<a class="header" href="print.html#a使用qt-creator-创建windows-动态库引用程序" id="a使用qt-creator-创建windows-动态库引用程序"><h2>使用Qt Creator 创建Windows 动态库引用程序</h2></a>
<pre><code class="language-pro">#-------------------------------------------------
#
# Project created by QtCreator 2018-12-27T15:48:51
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = ExtendBestCall
TEMPLATE = app

# The following define makes your compiler emit warnings if you use
# any feature of Qt which has been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES += QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

CONFIG += c++11

SOURCES += \
        main.cpp \
        mainwindow.cpp

HEADERS += \
        mainwindow.h

FORMS += \
        mainwindow.ui

# Default rules for deployment.
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target

</code></pre>
<a class="header" href="print.html#a添加引用库的方式" id="a添加引用库的方式"><h2>添加引用库的方式</h2></a>
<p><img src="qmake/images/win-create-dynamic-library-06.jpg" alt="" />
<img src="qmake/images/win-create-dynamic-library-07.jpg" alt="" />
<img src="qmake/images/win-create-dynamic-library-08.jpg" alt="" /></p>
<pre><code class="language-pro"># 添加第三方库
win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../build-ExtendBestRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/release/ -lExtendBestRef
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../build-ExtendBestRef-Desktop_Qt_5_12_0_MinGW_64_bit-Debug/debug/ -lExtendBestRef

INCLUDEPATH += $$PWD/../ExtendBestRef
DEPENDPATH += $$PWD/../ExtendBestRef

INCLUDEPATH += $$PWD/../ExtendBestRef
DEPENDPATH += $$PWD/../ExtendBestRef
</code></pre>
<a class="header" href="print.html#a看一下代码中如何调用" id="a看一下代码中如何调用"><h2>看一下，代码中如何调用</h2></a>
<pre><code class="language-cpp">#if defined __cplusplus
#include &lt;iostream&gt;
#endif

#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;

#include &quot;extendbestref.h&quot; // 引用第三方库

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_testBtn_clicked()
{
    TechiDaily::ExtendBestRef ref;
#if defined __cplusplus
    std::cout &lt;&lt; ref.hi() &lt;&lt; std::endl;
#endif
}

</code></pre>
<a class="header" href="print.html#a运行的时候需要将依赖库的dll文件存放到可执行文件相同目录中" id="a运行的时候需要将依赖库的dll文件存放到可执行文件相同目录中"><h2>运行的时候，需要将依赖库的dll文件，存放到可执行文件相同目录中</h2></a>
<p><img src="qmake/images/win-create-dynamic-library-09.jpg" alt="" /></p>
<a class="header" href="print.html#linux创建静态库" id="linux创建静态库"><h1>(Linux)创建静态库?</h1></a>
<a class="header" href="print.html#linux创建动态库" id="linux创建动态库"><h1>(Linux)创建动态库?</h1></a>
<a class="header" href="print.html#qt-库依赖如何导出" id="qt-库依赖如何导出"><h1>Qt 库依赖如何导出</h1></a>
<a class="header" href="print.html#qt-库的用途" id="qt-库的用途"><h1>Qt 库的用途</h1></a>
<p>参照 <a href="http://doc.qt.io/qt-5/qtmodules.html">http://doc.qt.io/qt-5/qtmodules.html</a></p>
<a class="header" href="print.html#a主要模块" id="a主要模块"><h2>主要模块</h2></a>
<table><thead><tr><th> 模块名称              </th><th> 描述                                                                                                                                                                                                                       </th><th> 备注                </th></tr></thead><tbody>
<tr><td> Qt Core               </td><td> Core non-graphical classes used by other modules.                                                                                                                                                                          </td><td> Qt 基础             </td></tr>
<tr><td> Qt GUI                </td><td> Base classes for graphical user interface (GUI) components. Includes OpenGL.                                                                                                                                               </td><td> Qt GUI 库           </td></tr>
<tr><td> Qt Widgets            </td><td> Classes to extend Qt GUI with C++ widgets.                                                                                                                                                                                 </td><td> Qt 小部件           </td></tr>
<tr><td> Qt Multimedia         </td><td> Classes for audio, video, radio and camera functionality.                                                                                                                                                                  </td><td> Qt 多媒体库         </td></tr>
<tr><td> Qt Multimedia Widgets </td><td> Widget-based classes for implementing multimedia functionality.                                                                                                                                                            </td><td> Qt 多媒体部件库     </td></tr>
<tr><td> Qt Network            </td><td> Classes to make network programming easier and more portable.                                                                                                                                                              </td><td> Qt 的网络库         </td></tr>
<tr><td> Qt QML                </td><td> Classes for QML and JavaScript languages.                                                                                                                                                                                  </td><td> Qt QML 库           </td></tr>
<tr><td> Qt Quick              </td><td> A declarative framework for building highly dynamic applications with custom user interfaces.                                                                                                                              </td><td> Qt 声明式 GUI       </td></tr>
<tr><td> Qt Quick Controls     </td><td> Provides lightweight QML types for creating performant user interfaces for desktop, embedded, and mobile devices. These types employ a simple styling architecture and are very efficient.                                 </td><td> Qt QML 控件         </td></tr>
<tr><td> Qt Quick Dialogs      </td><td> Types for creating and interacting with system dialogs from a Qt Quick application.                                                                                                                                        </td><td> Qt QML 调用系统窗口 </td></tr>
<tr><td> Qt Quick Layouts      </td><td> Layouts are items that are used to arrange Qt Quick 2 based items in the user interface.                                                                                                                                   </td><td> Qt QML 布局         </td></tr>
<tr><td> Qt Quick Test         </td><td> A unit test framework for QML applications, where the test cases are written as JavaScript functions. Note: The binary compatibility guarantee does not apply to Qt Quick Test. However, it will remain source compatible. </td><td> Qt QML 测试架构     </td></tr>
<tr><td> Qt SQL                </td><td> Classes for database integration using SQL.                                                                                                                                                                                </td><td> Qt SQL 接口         </td></tr>
<tr><td> Qt Test               </td><td> Classes for unit testing Qt applications and libraries. Note: The binary compatibility guarantee does not apply to Qt Test. However, it will remain source compatible.                                                     </td><td> Qt Test 架构        </td></tr>
</tbody></table>
<a class="header" href="print.html#qt-附加-add-ons" id="qt-附加-add-ons"><h2>Qt 附加 Add-Ons</h2></a>
<p>Qt 附加的库比较多。具体参见：<a href="http://doc.qt.io/qt-5/qtmodules.html">http://doc.qt.io/qt-5/qtmodules.html</a></p>
<a class="header" href="print.html#qt-插件的用途" id="qt-插件的用途"><h1>Qt 插件的用途</h1></a>
<a class="header" href="print.html#qt-windows-开发导出依赖" id="qt-windows-开发导出依赖"><h1>Qt Windows 开发，导出依赖</h1></a>
<a class="header" href="print.html#qt-linux-开发导出依赖" id="qt-linux-开发导出依赖"><h1>Qt Linux 开发，导出依赖</h1></a>
<a class="header" href="print.html#qt-mac-开发导出依赖" id="qt-mac-开发导出依赖"><h1>Qt Mac 开发，导出依赖</h1></a>
<a class="header" href="print.html#qt-制作安装包" id="qt-制作安装包"><h1>Qt 制作安装包</h1></a>
<a class="header" href="print.html#qt-windows-安装包制作" id="qt-windows-安装包制作"><h1>Qt Windows 安装包制作</h1></a>
<a class="header" href="print.html#qt-mac-安装包制作" id="qt-mac-安装包制作"><h1>Qt Mac 安装包制作</h1></a>
<a class="header" href="print.html#qt-mac-安装包制作-1" id="qt-mac-安装包制作-1"><h1>Qt Mac 安装包制作</h1></a>
<a class="header" href="print.html#qt-产品提交到应用商店" id="qt-产品提交到应用商店"><h1>Qt 产品提交到应用商店</h1></a>
<a class="header" href="print.html#windows-应用商店" id="windows-应用商店"><h1>Windows 应用商店</h1></a>
<a class="header" href="print.html#a苹果-macos-应用-商店" id="a苹果-macos-应用-商店"><h1>苹果 MacOS 应用 商店</h1></a>
<a class="header" href="print.html#windows平台技巧" id="windows平台技巧"><h1>Windows平台技巧</h1></a>
<a class="header" href="print.html#a如何加载动态库" id="a如何加载动态库"><h1>如何加载动态库？</h1></a>
<p>Windows平台使用三个基本的函数可以加载动态库</p>
<p>先看源码 <code>WinBase.h</code> 文件：</p>
<pre><code class="language-cpp">WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryA(
    __in LPCSTR lpLibFileName
    );
WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryW(
    __in LPCWSTR lpLibFileName
    );
#ifdef UNICODE
#define LoadLibrary  LoadLibraryW
#else
#define LoadLibrary  LoadLibraryA
#endif // !UNICODE
</code></pre>
<a class="header" href="print.html#windows加载动态库的搜索路径问题" id="windows加载动态库的搜索路径问题"><h1>Windows加载动态库的搜索路径问题</h1></a>
<a class="header" href="print.html#a官方搜索路径" id="a官方搜索路径"><h2>官方搜索路径</h2></a>
<ol>
<li>The directory from which the application loaded. （应用程序所在的目录）</li>
<li>The system directory. Use the GetSystemDirectory function to get the path of this directory. （system32目录）</li>
<li>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. （System目录）</li>
<li>The Windows directory. Use the GetWindowsDirectory function to get the path of this directory. （Windows目录）</li>
<li>The current directory. （运行中的当前目录）</li>
<li>The directories that are listed in the PATH environment variable. Note that this does not include     the per-application path specified by the App Paths registry key. （PATH 路径）</li>
</ol>
<a class="header" href="print.html#a简单总结一下简要的dll的加载顺序" id="a简单总结一下简要的dll的加载顺序"><h2>简单总结一下简要的dll的加载顺序</h2></a>
<ul>
<li>(1)EXE所在目录；</li>
<li>(2)当前目录GetCurrentDirectory()；</li>
<li>(3)系统目录GetSystemDirectory()；</li>
<li>(4)WINDOWS目录GetWindowsDirectory()；</li>
<li>(5)环境变量 PATH 所包含的目录。</li>
</ul>
<p>所以使用loadlibrary加载dll使用的路径，但是这个函数会忽略这个路径，只会按既定规则加载dll。所以如果要加载指定目录的dll，可以用上述两个解决方案。</p>
<a class="header" href="print.html#loadlibrary-与-loadlibraryw-与-loadlibrarya-的区别" id="loadlibrary-与-loadlibraryw-与-loadlibrarya-的区别"><h1>LoadLibrary 与 LoadLibraryW 与 LoadLibraryA 的区别</h1></a>
<p>先看源码 <code>WinBase.h</code> 文件：</p>
<pre><code class="language-cpp">WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryA(
    __in LPCSTR lpLibFileName
    );
WINBASEAPI
__out_opt
HMODULE
WINAPI
LoadLibraryW(
    __in LPCWSTR lpLibFileName
    );
#ifdef UNICODE
#define LoadLibrary  LoadLibraryW
#else
#define LoadLibrary  LoadLibraryA
#endif // !UNICODE
</code></pre>
<p>说明：</p>
<ul>
<li>（1）LoadLibrary 是动态来区分UNICODE和ANSI编码的动态库的</li>
<li>（2）LoadLibraryA 是加载ANSI编码动态库的</li>
<li>（3）LoadLibraryW 是加载UNICODE编码动态库的</li>
</ul>
<a class="header" href="print.html#a加载动态库出错的错误编码原因有哪些" id="a加载动态库出错的错误编码原因有哪些"><h1>加载动态库出错的错误编码，原因有哪些？</h1></a>
<a class="header" href="print.html#a想知道加载动态库出现什么问题可以先获得错误代码" id="a想知道加载动态库出现什么问题可以先获得错误代码"><h2>想知道加载动态库出现什么问题，可以先获得错误代码.</h2></a>
<p>通过 <code>GetLastError()</code> 函数获取最后出错的代码编码</p>
<pre><code class="language-cpp">DWORD dwError = 0;
hInstance = LoadLibrary(strDllName);
if(hInstance == NULL)
{
dwError = GetLastError();
return NULL;

}
</code></pre>
<a class="header" href="print.html#a出现问题的错误编码及解析" id="a出现问题的错误编码及解析"><h2>出现问题的错误编码及解析</h2></a>
<ul>
<li>错误代码<strong>126</strong>：</li>
</ul>
<a class="header" href="print.html#tchar-转换成const-char" id="tchar-转换成const-char"><h1>TCHAR 转换成const char*</h1></a>
<a class="header" href="print.html#qt-core" id="qt-core"><h1>Qt Core</h1></a>
<ul>
<li><a href="./qt_skills/qt-core/q_object_macro.md">宏 Q_OBJECT, 应用到所有继承 QObject 的类</a></li>
<li><a href="./qt_skills/qt-core/class_define_use_q_object_macro_must_inheritance_qobject.md">使用宏 Q_OBJECT, 类必须继承 QObject 或 QObject 子类</a></li>
<li><a href="./qt_skills/qt-core/q_class_info_macro.md">添加类 ClassInfo 信息</a></li>
<li><a href="./qt_skills/qt-core/get_q_class_info.md">获取类 ClassInfo 信息</a></li>
<li><a href="./qt_skills/qt-core/qobject_rw_properties.md">类 Property 属性读写封装</a></li>
<li><a href="./qt_skills/qt-core/qobject_manager_properties.md">QObject 对象动态增加属性</a></li>
<li><a href="./qt_skills/qt-core/incomplete_return_type_of_QMetaClassInfo.md">incomplete return type 'QMetaClassInfo'</a></li>
<li><a href="./qt_skills/qt-core/incomplete_return_type_of_QMetaProperty.md">incomplete return type 'QMetaProperty'</a></li>
<li><a href="./qt_skills/qt-core/qobject_cast.md">QObject 对象指针类型的动态转换 qobject_cast&lt;&gt;</a></li>
<li><a href="./qt_skills/qt-core/qobject_enums.md">QObject 对象枚举类型封装</a></li>
<li><a href="./qt_skills/qt-core/class_define_use_general_not_supported.md">QObject 子类不支持模类定义板泛型</a></li>
<li><a href="./qt_skills/qt-core/multiple_inheritance_with_qobject_be_first.md">多继承 QObject 必须放在前面</a></li>
<li><a href="./qt_skills/qt-core/virtual_inheritance_with_qobject_not_supported.md">虚拟继承 QObject 不支持</a></li>
<li><a href="./qt_skills/qt-core/nested_classes_cannot_have_signals_and_slots.md">嵌套类中的类不能有信号和槽机制</a></li>
<li><a href="./qt_skills/qt-core/nested_classes_cannot_use_q_object_macro.md">嵌套 QObject 子类中的类不能使用宏 Q_OBJECT</a></li>
<li><a href="./qt_skills/qt-core/function_cannot_apply_to_single_and_slot.md">函数指针不能作为信号和槽的参数</a></li>
<li><a href="./qt_skills/qt-core/enums_must_be_fully_qualified_for_single_and_slot.md">信号和槽中的枚举参数，必须是完全限定</a></li>
<li><a href="./qt_skills/qt-core/order_about_singles_and_slots.md">信号和槽被激活的次序说明</a></li>
</ul>
<a class="header" href="print.html#a所有继承-qobject-的类建议对使用-q_object-宏" id="a所有继承-qobject-的类建议对使用-q_object-宏"><h1>所有继承 QObject 的类，建议对使用 Q_OBJECT 宏</h1></a>
<p>原文：</p>
<blockquote>
<p>While it is possible to use <code>QObject</code> as a base class without the <code>Q_OBJECT</code> macro and without meta-object code, neither signals and slots nor the other features described here will be available if the <code>Q_OBJECT</code> macro is not used. From the meta-object system's point of view, a QObject subclass without meta code is equivalent to its closest ancestor with meta-object code. This means for example, that <code>QMetaObject::className()</code> will not return the actual name of your class, but the class name of this ancestor.</p>
</blockquote>
<p>Therefore, we strongly recommend that all subclasses of QObject use the <code>Q_OBJECT</code> macro regardless of whether or not they actually use <code>signals, slots, and properties</code>.</p>
<p>说明：所有继承 QObject 的类，建议对使用 Q_OBJECT 宏。 如果不使用<code>Q_OBJECT</code>宏，那么子类所有的关于信号、槽、属性等等特性全部不可用。</p>
<a class="header" href="print.html#a使用宏-q_object-类必须继承-qobject-或-qobject-子类" id="a使用宏-q_object-类必须继承-qobject-或-qobject-子类"><h1>使用宏 Q_OBJECT, 类必须继承 QObject 或 QObject 子类</h1></a>
<p>// Error: Class contains Q_OBJECT macro but does not inherit from QObject</p>
<pre><code class="language-cpp">class CustomObject {
    Q_OBJECT // Error: Class contains Q_OBJECT macro but does not inherit from QObject
public:
    explicit CustomObject();
    ~CustomObject();
};
</code></pre>
<a class="header" href="print.html#a宏-qt_version-与-qt_version_check-如何使用" id="a宏-qt_version-与-qt_version_check-如何使用"><h1>宏 QT_VERSION 与 QT_VERSION_CHECK 如何使用?</h1></a>
<a class="header" href="print.html#a添加更多的类信息" id="a添加更多的类信息"><h1>添加更多的类信息</h1></a>
<p>使用<code>Q_CLASSINFO()</code>宏给类添加更多的关于类的信息，只支持 key-value 方式</p>
<blockquote>
<p>Another macro, <code>Q_CLASSINFO()</code>, allows you to attach additional name/value pairs to the class's meta-object</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-h">class MyClass : public QObject
{
    Q_OBJECT
    Q_CLASSINFO(&quot;Author&quot;, &quot;Oscar Peterson&quot;)
    Q_CLASSINFO(&quot;Status&quot;, &quot;Active&quot;)

public:
    MyClass(QObject *parent = 0);
    ~MyClass();
};
</code></pre>
<a class="header" href="print.html#a获取类-classinfo-信息" id="a获取类-classinfo-信息"><h1>获取类 ClassInfo 信息</h1></a>
<a class="header" href="print.html#a调用文件要加入如下代码" id="a调用文件要加入如下代码"><h2>调用文件要加入如下代码</h2></a>
<pre><code class="language-cpp">#include &lt;QMetaClassInfo&gt;
</code></pre>
<a class="header" href="print.html#a获取-qmetaclassinfo-的信息" id="a获取-qmetaclassinfo-的信息"><h2>获取 QMetaClassInfo 的信息</h2></a>
<pre><code class="language-cpp">const QMetaObject* metaObject = this-&gt;metaObject();

std::cout &lt;&lt; &quot;metaObject-&gt;className() = &quot; &lt;&lt; metaObject-&gt;className() &lt;&lt; std::endl;

std::cout &lt;&lt; &quot;metaObj-&gt;classInfo : = &quot; &lt;&lt; std::endl;
for(int i = metaObject-&gt;classInfoOffset(); i &lt; metaObject-&gt;classInfoCount(); ++i) {
    std::cout &lt;&lt; metaObject-&gt;classInfo(i).name() &lt;&lt; std::endl;
}
std::cout &lt;&lt; &quot;----------------------&quot;  &lt;&lt; std::endl;
</code></pre>
<a class="header" href="print.html#qt-类-property-属性读写封装" id="qt-类-property-属性读写封装"><h1>Qt 类 Property 属性读写封装</h1></a>
<a class="header" href="print.html#a简介-1" id="a简介-1"><h2>简介</h2></a>
<p>Qt 提供一个复杂属性系统，类似于其它编译器供应商所提供的（Property System）。然而，作为一个与编译器和平台无关的库，Qt 不依赖于那些非标准的编译器特性，如：_property 或[property]。Qt 的解决方案适用于 Qt 支持平台下的任何标准 C++编译器。它基于元对象系统（Meta Object Sytstem），也通过信号和槽提供对象间通讯机制。</p>
<p>Qt 的属性系统为 Qt 的类添加了更加实惠的功能。有助于 Qt 对象状态变化，变化通知、封装等等操作。</p>
<a class="header" href="print.html#a声明属性的要求" id="a声明属性的要求"><h2>声明属性的要求</h2></a>
<p>为了声明一个属性，在继承 QObject 的类中使用 <code>Q_PROPERTY()</code>宏.</p>
<pre><code class="language-cpp">Q_PROPERTY(type name
           (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction | WRITE setFunction)])
           [RESET resetFunction]
           [NOTIFY notifySignal]
           [REVISION int]
           [DESIGNABLE bool]
           [SCRIPTABLE bool]
           [STORED bool]
           [USER bool]
           [CONSTANT]
           [FINAL])
</code></pre>
<p>Here are some typical examples of property declarations taken from class QWidget.
以下是摘自 QWidget 类的典型属性声明的例子：</p>
<pre><code class="language-cpp">Q_PROPERTY(bool focus READ hasFocus)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)
</code></pre>
<p>下面的示例，展示了如何使用 MEMBER 关键字将类成员变量导出为 Qt 属性。注意：必须被指定一个 NOTIFY 信号以允许 QML 属性绑定。</p>
<pre><code class="language-cpp">    Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)
    Q_PROPERTY(qreal spacing MEMBER m_spacing NOTIFY spacingChanged)
    Q_PROPERTY(QString text MEMBER m_text NOTIFY textChanged)
    ...
signals:
    void colorChanged();
    void spacingChanged();
    void textChanged(const QString &amp;newText);

private:
    QColor  m_color;
    qreal   m_spacing;
    QString m_text;
</code></pre>
<a class="header" href="print.html#a一个属性的行为就像一个类的数据成员但它有通过元对象系统访问的附加特性" id="a一个属性的行为就像一个类的数据成员但它有通过元对象系统访问的附加特性"><h2>一个属性的行为就像一个类的数据成员，但它有通过元对象系统访问的附加特性。</h2></a>
<ul>
<li>如果没有指定 <code>MEMBER</code> 关键字，则需要一个 <code>READ</code> 访问函数。用于读取属性值。理想的情况下，一个 const 函数用于此目的，并且它必须返回属性类型或类型的 const 引用。如：<code>QWidget::focus</code> 是一个只读属性，通过 <code>READ</code> 函数 <code>QWidget::hasFocus()</code>访问。</li>
<li>一个 <code>WRITE</code> 访问函数是<strong>可选的</strong>，用于设置属性值。它必须返回 <code>void</code> 并且必须接受一个参数，该参数是属性类型，或此类型的指针，引用，例如：<code>QWidget::enabled</code> 具有 <code>WRITE</code> 函数 <code>QWidget::setEnabled()</code>。只读属性不需要 <code>WRITE</code> 函数，例如：<code>QWidget::focus</code> 没有 <code>WRITE</code> 函数</li>
<li>如果 <code>READ</code> 访问函数没有被指定，则 <code>MEMBER</code> 变量关联是必须的。这使得给定的成员变量可读可写，而不需要创建 <code>READ</code> 和 <code>WRITE</code> 访问函数。如果需要控制变量访问，除了使用 <code>MEMBER</code> 变量关联外，仍然可以使用 <code>READ</code> 和 <code>WRITE</code> 函数（但不要同时使用）</li>
<li>一个 <code>RESET</code> 函数是<strong>可选的</strong>，用于将属性设置为上下文指定的默认值。例如：<code>QWidget::cursor</code> 有典型的 <code>READ</code> 和 <code>WRITE</code> 函数，<code>QWidget::cursor()</code>和 <code>QWidget::setCursor()</code>，同时也有一个 <code>RESET</code> 函数 <code>QWidget::unsetCursor()</code>，因为没有 <code>QWidget::setCursor()</code>调用将 <code>cursor</code> 属性重置为上下文默认的值。<code>RESET</code> 函数必须返回 <code>void</code> 类型，并且不带任何参数。</li>
<li>一个 <code>NOTIFY</code> 信号是<strong>可选的</strong>。如果定义了 <code>NOTIFY</code>，则需要在类中指定一个已存在的信号，该信号在属性值改变时发射。<code>MEMBER</code> 变量的 <code>NOTIFY</code> 信号必须是 0 个或一个参数，而且必须与属性的类型相同。参数保存的是属性的新值。<code>NOTIFY</code> 信号应该仅当属性值真正的发生变化时发射，以避免绑定在 <code>QML</code> 不必要的重新评估。例如：当需要一个没有显式 <code>setter</code> 的 <code>MEMBER</code> 属性时，Qt 会自动发射信号。</li>
<li>一个 <code>REVISION</code> 数字是<strong>可选的</strong>。如果包含了该关键字，它定义了在 API 特定修订中使用的属性和通知器信号（通常是 QML）；如果没有包含，它默认为 <code>0</code>。</li>
<li><code>DESIGNABLE</code> 属性指定了该属性在 GUI 设计器（如 <code>Qt Designer</code>）的属性编辑器中是否可见。大多数的属性是 <code>DESIGNABLE</code> （默认为 true）。除了 true 或 false，还可以指定 boolean 成员函数。</li>
<li><code>SCRIPTABLE</code> 属性表明这个属性是否可以被一个脚本引擎操作（默认是 true）。除了 true 或 false，你还可以指定 boolean 成员函数。</li>
<li><code>STORED</code> 属性表明了该属性是否被认为是自己已存在的或是依赖于其它值。它也表明在保存对象状态时，是否必须保存此属性的值。大多数属性是 STORED（默认为 true）。但是例如：<code>QWidget::minmunWidth()</code>的 <code>STROED</code> 为 false，因为它的值从 <code>QWidget::minimumSize()</code>（类型为 <code>QSize</code>）中的宽度部分取得。</li>
<li><code>USER</code> 属性指定了在类中属性是否被设计为面向用户或可编辑的。通常情况下，每一个类只有一个 <code>USER</code> 属性（默认为 false）。例如： <code>QAbstractButton::checked</code> 是按钮的用户可编辑属性（checkable）。注意：<code>QItemDelegate</code> 获取和设置 <code>widget</code> 的 <code>USER</code> 属性。</li>
<li><code>CONSTANT</code> 属性的存在表明属性是一个常量值。对于给定的 object 实例，常量属性的 <code>READ</code> 函数在每次被调用时必须返回相同的值。不同的 object 实例该常量值可能会不同。一个常量属性不能具有 <code>WRITE</code> 函数或 <code>NOYIFY</code> 信号。</li>
<li><code>FINAL</code> 属性的存在表明属性不能被派生类所重写。在有些情况下，这可以用于效率优化，但不能被 moc 强制执行。必须注意不能重写一个 <code>FINAL</code> 属性。
<code>READ</code>,<code>WRITE</code>,<code>RESET</code> 函数能被继承，也能是 <code>virtual</code> 的。当多重继承时，它们必须来自第一个继承的类。</li>
</ul>
<a class="header" href="print.html#a属性类型可以是-qvariant-支持的任意类型或者是用户定义的类型在这个例子中类-qdate-被看作是一个用户定义的类型" id="a属性类型可以是-qvariant-支持的任意类型或者是用户定义的类型在这个例子中类-qdate-被看作是一个用户定义的类型"><h2>属性类型可以是 QVariant 支持的任意类型，或者是用户定义的类型。在这个例子中，类 QDate 被看作是一个用户定义的类型。</h2></a>
<pre><code class="language-cpp">Q_PROPERTY(QDate date READ getDate WRITE setDate)
</code></pre>
<p>因为 <code>QDate</code> 是用户自定义的，必须包含有属性声明的头文件。</p>
<p>由于历史原因，QMap 和 QList 作为属性类型等同于 <code>QVarinatMap</code> 和 <code>QVarintList</code>.
For historical reasons, QMap and QList as property types are synonym of QVariantMap and QVariantList.</p>
<p>对于 QMap、QList 和 QValueList 属性，属性的值是一个 QVariant，它包含整个 list 或 map。</p>
<p>注意：Q_PROPERTY 字符串不能包含逗号，因为逗号会分割宏的参数。因此，你必须使用 QVarinatMap 作为属性的类型而不是 QMap</p>
<a class="header" href="print.html#a通过元对象系统读写属性" id="a通过元对象系统读写属性"><h2>通过元对象系统读写属性</h2></a>
<p>一个属性可以使用通用函数 <code>QObject::property()</code>和 <code>QObject::setProperty()</code>进行读写，除了属性名，无需知晓属性所属类的任何细节。</p>
<p>下面的代码片断中，调用 <code>QAbstractButton::setDown()</code>和 <code>QObject::setProperty()</code>来设置属性“down”。</p>
<pre><code class="language-cpp">QPushButton *button = new QPushButton;
QObject *object = button;

button-&gt;setDown(true);
object-&gt;setProperty(&quot;down&quot;, true);
</code></pre>
<blockquote>
<p>优化建议：
通过属性的 <code>WRITE</code> 访问属性优于上述两者，因为速度更快并且在编译期间有更好的诊断。
但以这种方式设置属性你需要在编译期间了解这个类（能够访问其定义）。</p>
</blockquote>
<p>通过名称访问属性，能够让你在编译期间访问不了解的类。你可以在运行时期通过 <code>QObject</code>、<code>QMetaObject</code> 和 <code>QMetaProperties</code> 查询类属性。</p>
<pre><code class="language-cpp">QObject *object = ...
const QMetaObject *metaobject = object-&gt;metaObject();
int count = metaobject-&gt;propertyCount();
for (int i=0; i&lt;count; ++i) {
    QMetaProperty metaproperty = metaobject-&gt;property(i);
    const char *name = metaproperty.name();
    QVariant value = object-&gt;property(name);
    ...
}
</code></pre>
<p>上面的代码片段中，<code>QMetaObject::property()</code>用于获取在未知类中定义的每个属性的 <code>metadata</code>。
从 <code>metadata</code> 中获取属性名，并传递给 <code>QObject::property()</code>来获取当前对象的属性值。</p>
<a class="header" href="print.html#a一个简单的例子" id="a一个简单的例子"><h2>一个简单的例子</h2></a>
<p>假设我们有一个类 <code>MyClass</code>，它从 <code>QObject</code> 派生并且在其 <code>private</code> 区域使用了 <code>Q_OBJECT</code> 宏。
我们想在 <code>MyClass</code> 类中声明一个属性去保持一个 <code>priority</code> 值的追踪。
属性名为 <code>priority</code>，它是在 <code>MyClass</code> 中定义的 <code>Priority</code> 枚举类型。</p>
<p>我们在类的 <code>private</code> 区域使用 <code>Q_PROPERTY()</code>来声明属性。</p>
<p><code>READ</code> 函数名为 <code>priority</code>，并且包含一个名为 <code>setPriority</code> 的 <code>WRITE</code> 函数。</p>
<p>枚举类型必须使用 <code>Q_ENUM()</code>宏注册到元对象系统中。</p>
<p>注册一个枚举类型使得枚举器名可以在调用 <code>QObject::setProperty()</code>时使用。
我们还必须为 <code>READ</code> 和 <code>WRITE</code> 函数提供我们自己的声明。</p>
<p><code>MyClass</code> 的声明看起来如下：</p>
<pre><code class="language-cpp">class MyClass : public QObject
{

    Q_PROPERTY(Priority priority READ priority WRITE setPriority NOTIFY priorityChanged)

public:
    MyClass(QObject *parent = nullptr);
    ~MyClass();

    enum Priority
    {
        High,
        Low,
        VeryHigh,
        VeryLow
    };
    Q_ENUM(Priority)

    void setPriority(Priority priority) {
        m_priority = priority;
        emit priorityChanged(priority);
    }
    Priority priority() const { return m_priority; }
signals:
    void priorityChanged(Priority);

private:
    Q_OBJECT
    Priority m_priority;
};
</code></pre>
<p><code>READ</code> 函数是 <code>const</code> 的并返回属性类型。<code>WRITE</code> 函数返回 <code>void</code> 并有一个属性类型的参数。元对象编译器强制做这些事情。</p>
<p>给定一个指向 <code>MyClass</code> 实例的指针，或一个指向 <code>QObject</code> 的指针（该指针是 <code>MyClass</code> 的实例），有两种方式设置 <code>priority</code> 属性：</p>
<pre><code class="language-cpp">MyClass *myinstance = new MyClass;
QObject *object = myinstance;

myinstance-&gt;setPriority(MyClass::VeryHigh);
object-&gt;setProperty(&quot;priority&quot;, &quot;VeryHigh&quot;);
</code></pre>
<p>在此例子中，声明在 <code>MyClass</code> 中的枚举类型是属性的类型，并使用 <code>Q_ENUM()</code>宏注册在元对象系统中。这使得枚举值可以在调用 <code>setProperty()</code>时做为字符串使用。如果枚举类型在其它类中声明，那么需要使用枚举的全名（如：<code>OtherClass::Priority</code>)，且此类也必须从 QObject 派生，且使用 <code>Q_ENUM()</code>宏注册枚举类型。</p>
<p>像 <code>Q_ENUMS()</code>宏一样，类似的宏 Q_FLAG()也是可用的，它注册一个枚举类型，但是它把枚举类型作为一个 <code>flags</code> 集合，也就是，值可以用 OR 操作来合并。
一个 I/O 类可能具有枚举值 Read 和 Write 并且 <code>QObject::setProperty()</code>可以接受 <code>Read | Write</code>。应使用 <code>Q_FLAGS()</code>来注册此枚举类型。</p>
<a class="header" href="print.html#a动态属性" id="a动态属性"><h2>动态属性</h2></a>
<p>QObject::setProperty()也可以用来在运行时期向一个类的实例添加新的属性。</p>
<ul>
<li>当使用一个名称和值调用此函数时，如果 <code>QObject</code> 中一个给定名称的属性已存在，并且如果给定的值与属性的类型兼容，则值就存储到属性中，并返回 true。如果值与属性类型不兼容，属性值则不会改变，并返回 false。</li>
<li>但是如果 QObject 中一个给定名称的属性不存在（如：并没用 <code>Q_PROPERTY()</code>声明），则一个带有给定名称和值的新属性就被自动添加到 QObject 中，<strong>但是依然会返回 false</strong>。这意味着返回 false 不能用于确定一个属性是否被真的被设置了，除非你预先知道这个属性已经存在于 QObject 中。</li>
</ul>
<blockquote>
<p>注意：
动态属性是在每一个实例的基础上添加的，也就是，它们被添加到 <code>QObject</code> 中，而不是 <code>QMetaObject</code>。
可以通过传递一个属性名和一个无效的 <code>QVariant</code> 到 <code>QObject::setProperty()</code>从一个实例中移除属性。默认的 <code>QVariant</code> 构造器会构造一个无效的 <code>QVariant</code>。
动态属性可用 <code>QObject::property()</code>来查询，就像在编译期使用 <code>Q_PROPERTY()</code>声明的属性一样。</p>
</blockquote>
<a class="header" href="print.html#a属性和自定义类型" id="a属性和自定义类型"><h2>属性和自定义类型</h2></a>
<p>通过属性使用的自定义类型需要使用 <code>Q_DECLARE_METATYPE()</code>宏注册，以便它们的值能被保存在 <code>QVariant</code> 对象中。
这使得它们适用于在类定义中使用 <code>Q_PROPERTY()</code>宏声明的静态属性，以及运行时创建的动态属性。</p>
<a class="header" href="print.html#a为类添加附加信息" id="a为类添加附加信息"><h2>为类添加附加信息</h2></a>
<p>与属性系统相连接的是一个附加宏, <code>Q_CLASSINFO()</code>。用于添加额外的 <code>name-value</code> 对到类的元对象中。例如：</p>
<pre><code class="language-cpp">Q_CLASSINFO(&quot;Version&quot;, &quot;3.0.0&quot;)
</code></pre>
<p>和其它 <code>meta-data</code> 一样，类信息可以在运行时通过 <code>meta-object</code> 访问，详情见 <code>QMetaObject::classInfo()</code> 。</p>
<p>也可参考 <code>Meta-Object System</code>, <code>Signals and Slots</code>, <code>Q_DECLARE_METATYPE()</code>, <code>QMetaType</code>, <code>QVariant</code></p>
<a class="header" href="print.html#qt-对象动态增加属性" id="qt-对象动态增加属性"><h1>Qt 对象动态增加属性</h1></a>
<p>Dynamic Properties</p>
<blockquote>
<p><code>QObject::setProperty()</code> can also be used to add new properties to an instance of a class at runtime. When it is called with a name and a value, if a property with the given name exists in the QObject, and if the given value is compatible with the property's type, the value is stored in the property, and true is returned. If the value is not compatible with the property's type, the property is not changed, and false is returned. But if the property with the given name doesn't exist in the QObject (i.e., if it wasn't declared with <code>Q_PROPERTY()</code>), a new property with the given name and value is automatically added to the QObject, but false is still returned. This means that a return of false can't be used to determine whether a particular property was actually set, unless you know in advance that the property already exists in the QObject.</p>
</blockquote>
<blockquote>
<p>Note that dynamic properties are added on a per instance basis, i.e., they are added to QObject, not QMetaObject. A property can be removed from an instance by passing the property name and an invalid QVariant value to <code>QObject::setProperty()</code>. The default constructor for QVariant constructs an invalid QVariant.</p>
</blockquote>
<blockquote>
<p>Dynamic properties can be queried with <code>QObject::property()</code>, just like properties declared at compile time with <code>Q_PROPERTY()</code>.</p>
</blockquote>
<ul>
<li><code>QObject::setProperty()</code></li>
<li><code>QObject::property()</code></li>
</ul>
<p>示例代码：</p>
<pre><code class="language-cpp">MyClass *myinstance = new MyClass;
QObject *object = myinstance;

myinstance-&gt;setPriority(MyClass::VeryHigh);
object-&gt;setProperty(&quot;priority&quot;, &quot;VeryHigh&quot;);
</code></pre>
<a class="header" href="print.html#incomplete-return-type-qmetaclassinfo" id="incomplete-return-type-qmetaclassinfo"><h1>incomplete return type 'QMetaClassInfo'</h1></a>
<p>出现这一问题的原因是没有添加到调用的 CPP 源码中</p>
<pre><code class="language-cpp">#include &lt;QMetaClassInfo&gt;
</code></pre>
<a class="header" href="print.html#incomplete-return-type-qmetaproperty" id="incomplete-return-type-qmetaproperty"><h1>incomplete return type 'QMetaProperty'</h1></a>
<p>出现这一问题的原因是没有添加到调用的 CPP 源码中</p>
<pre><code class="language-cpp">#include &lt;QMetaProperty&gt;
</code></pre>
<a class="header" href="print.html#qt-对象指针类型的动态转换用法" id="qt-对象指针类型的动态转换用法"><h1>Qt 对象指针类型的动态转换用法</h1></a>
<p>Qt 对象指针类型的动态转换，使用的是 Qt 自身的<code>qobject_cast()</code> 函数</p>
<blockquote>
<p>It is also possible to perform dynamic casts using <code>qobject_cast()</code> on <code>QObject</code> classes. The <code>qobject_cast()</code> function behaves similarly to the standard C++ <code>dynamic_cast()</code>, with the advantages that it doesn't require <code>RTTI</code> support and it works across dynamic library boundaries. It attempts to cast its argument to the pointer type specified in angle-brackets, returning a non-zero pointer if the object is of the correct type (determined at run-time), or 0 if the object's type is incompatible.</p>
</blockquote>
<p>示例代码：</p>
<pre><code class="language-cpp">QObject *obj = new MyWidget;
QWidget *widget = qobject_cast&lt;QWidget *&gt;(obj); // widget is not 0
MyWidget *myWidget = qobject_cast&lt;MyWidget *&gt;(obj); // myWidget is not 0
QLabel *label = qobject_cast&lt;QLabel *&gt;(obj); // label is 0

// 可以很方便地用到判断语句中
if (QLabel *label = qobject_cast&lt;QLabel *&gt;(obj)) {
    label-&gt;setText(tr(&quot;Ping&quot;));
} else if (QPushButton *button = qobject_cast&lt;QPushButton *&gt;(obj)) {
    button-&gt;setText(tr(&quot;Pong!&quot;));
}

</code></pre>
<a class="header" href="print.html#qt-对象枚举类型封装" id="qt-对象枚举类型封装"><h1>Qt 对象枚举类型封装</h1></a>
<a class="header" href="print.html#a类不支持模类定义板泛型" id="a类不支持模类定义板泛型"><h1>类不支持模类定义板泛型</h1></a>
<blockquote>
<p>moc does not handle all of C++. The main problem is that class templates cannot have the <code>Q_OBJECT</code> macro.</p>
</blockquote>
<pre><code class="language-h">// 错误： 不支持C++的模板泛型定义
class SomeTemplate&lt;int&gt; : public QFrame
{
    Q_OBJECT
    ...

signals:
    void mySignal(int);
};
</code></pre>
<a class="header" href="print.html#a多继承-qobject-必须放在前面" id="a多继承-qobject-必须放在前面"><h1>多继承 QObject 必须放在前面</h1></a>
<blockquote>
<p>Multiple Inheritance Requires QObject to Be First</p>
</blockquote>
<blockquote>
<p>If you are using multiple inheritance, moc assumes that the first inherited class is a subclass of QObject. Also, be sure that only the first inherited class is a QObject.</p>
</blockquote>
<pre><code class="language-h">// 正确
class SomeClass : public QObject, public OtherClass
{
    ...
};

// 不正确
class SomeClass : public OtherClass, public QObject
{
    ...
};
</code></pre>
<a class="header" href="print.html#a虚拟继承-qobject-不支持" id="a虚拟继承-qobject-不支持"><h1>虚拟继承 QObject 不支持</h1></a>
<pre><code class="language-h">
</code></pre>
<a class="header" href="print.html#a嵌套类中的类不能有信号和槽机制" id="a嵌套类中的类不能有信号和槽机制"><h1>嵌套类中的类不能有信号和槽机制</h1></a>
<pre><code class="language-cpp">class A
{
public:
    class B
    {
        Q_OBJECT

    public slots:   // 错误！WRONG
        void b();
    };
};
</code></pre>
<p>以下都是正常运行的。如果，嵌套类中使用信号和槽，信号和槽就不会有效</p>
<pre><code class="language-cpp">
// 编译正常
class CustomObject {
public:
    class CustomItem {
        Q_OBJECT
    public:
        explicit CustomItem(){}
        ~ CustomItem(){}
    };
};
</code></pre>
<pre><code class="language-cpp">class CustomObject {
    Q_OBJECT // Error: Class contains Q_OBJECT macro but does not inherit from QObject
public:
    class CustomItem {
        Q_OBJECT
    public:
        explicit CustomItem(){}
        ~ CustomItem(){}
    };
};
</code></pre>
<pre><code class="language-cpp">class CustomObject : public QObject {
    Q_OBJECT
public:
    class CustomItem {
        Q_OBJECT // Error: Meta object features not supported for nested classes
    public:
        explicit CustomItem(){}
        ~ CustomItem(){}
    private slots:
        void on_clicked();
    };
};
</code></pre>
<a class="header" href="print.html#a嵌套-qojbect-子类中的类不能使用宏-q_object" id="a嵌套-qojbect-子类中的类不能使用宏-q_object"><h1>嵌套 QOjbect 子类中的类不能使用宏 Q_OBJECT</h1></a>
<pre><code class="language-cpp">class CustomObject : public QObject {
    Q_OBJECT
public:
    class CustomItem {
        Q_OBJECT // Error: Meta object features not supported for nested classes
    public:
        explicit CustomItem(){}
        ~ CustomItem(){}
    private slots:
        void on_clicked();
    };
};
</code></pre>
<a class="header" href="print.html#a函数指针不能作为信号和槽的参数" id="a函数指针不能作为信号和槽的参数"><h1>函数指针不能作为信号和槽的参数</h1></a>
<p>一般情况下，直接使用函数指针是会提示语法错误的。</p>
<pre><code class="language-cpp">class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(void (*apply)(List *, void *), char *); // 语法错误！WRONG
};
</code></pre>
<p>但可以通过以下方式绕过该机制</p>
<pre><code class="language-cpp">typedef void (*ApplyFunction)(List *, void *);

class SomeClass : public QObject
{
    Q_OBJECT

public slots:
    void apply(ApplyFunction, char *);  // 正确
};
</code></pre>
<p>建议：有时用继承和虚拟函数替换函数指针可能会更好。</p>
<a class="header" href="print.html#a信号和槽中的枚举参数必须是完全限定" id="a信号和槽中的枚举参数必须是完全限定"><h1>信号和槽中的枚举参数，必须是完全限定</h1></a>
<a class="header" href="print.html#a信号和槽被激活的次序说明" id="a信号和槽被激活的次序说明"><h1>信号和槽被激活的次序说明</h1></a>
<a class="header" href="print.html#a信号和槽可以使用函数指针吗" id="a信号和槽可以使用函数指针吗"><h1>信号和槽可以使用函数指针吗？</h1></a>
<a class="header" href="print.html#a槽支持-c11-的-lambdas-表达式吗" id="a槽支持-c11-的-lambdas-表达式吗"><h1>槽支持 C++11 的 lambdas 表达式吗？</h1></a>
<a class="header" href="print.html#a什么时候使用-blocking-queued-connection" id="a什么时候使用-blocking-queued-connection"><h1>什么时候使用 Blocking Queued Connection?</h1></a>
<a class="header" href="print.html#qtconnectiontype信号与槽的传递方式" id="qtconnectiontype信号与槽的传递方式"><h2>Qt::ConnectionType（信号与槽的传递方式）</h2></a>
<ul>
<li><strong>Qt::AutoConnection</strong> 自动连接：（默认值）如果信号在接收者所依附的线程内发射，则等同于直接连接。如果发射信号的线程和接受者所依附的线程不同，则等同于队列连接。</li>
<li><strong>Qt::DirectConnection</strong> 直接连接：当信号发射时，槽函数将直接被调用。无论槽函数所属对象在哪个线程，槽函数都在发射信号的线程内执行。</li>
<li><strong>Qt::QueuedConnection</strong> 队列连接：当控制权回到接受者所依附线程的事件循环时，槽函数被调用。槽函数在接收者所依附线程执行。也就是说：这种方式既可以在线程内传递消息，也可以跨线程传递消息</li>
<li><strong>Qt::BlockingQueuedConnection</strong> 与 Qt::QueuedConnection 类似，但是会阻塞等到关联的 slot 都被执行。这里出现了阻塞这个词，说明它是专门用来多线程间传递消息的。</li>
</ul>
<a class="header" href="print.html#a宏-q_declare_metatype-与-qvariant-如何结合使用" id="a宏-q_declare_metatype-与-qvariant-如何结合使用"><h1>宏 Q_DECLARE_METATYPE 与 QVariant 如何结合使用？</h1></a>
<a class="header" href="print.html#a前言" id="a前言"><h2>前言</h2></a>
<p><code>QVariant</code> 这个类很神奇，或者说方便。很多时候，需要几种不同的数据类型需要传递，如果用结构体，又不大方便，容器保存的也只是一种数据类型，而 QVariant 则可以统统搞定。</p>
<a class="header" href="print.html#a介绍" id="a介绍"><h2>介绍</h2></a>
<p>帮助文档上说：The <code>QVariant</code> class acts like a union for the most common Qt data types.。</p>
<p><code>QVariant</code> 这个类型充当着最常见的数据类型的联合。<code>QVariant</code> 可以保存很多 Qt 的数据类型，包括 QBrush、QColor、QCursor、QDateTime、QFont、QKeySequence、 QPalette、QPen、QPixmap、QPoint、QRect、QRegion、QSize 和 QString，并且还有 C++基本类型，如 int、float 等。</p>
<p>当然，如果支持的类型没有想要的，没关系，<code>QVariant</code> 也可以支持自定义的数据类型。<strong>被 QVariant 存储的数据类型需要有一个默认的构造函数和一个拷贝构造函数。</strong></p>
<p>为了实现这个功能，首先必须使用 <code>Q_DECLARE_METATYPE()</code>宏。通常会将这个宏放在类的声明所在头文件的下面：</p>
<p><code>Q_DECLARE_METATYPE(MyClass)</code></p>
<p>示例：</p>
<p>MyClass.h 文件</p>
<pre><code class="language-h">struct MyClass{
    int id;
    QString name;
};
Q_DECLARE_METATYPE(MyClass)
</code></pre>
<pre><code class="language-cpp">
//存储数据
MyClass myClass;
myClass.id=0;
myClass.name=QString(&quot;LiMing&quot;);

data[0]=QString(&quot;ddd&quot;);
data[1]=123;
data[3]=QVariant::fromValue(myClass);


//获取数据
QString str=data.value(0).toString();
int val=data.value(1).toInt();

if(data[3].canConvert&lt;MyClass&gt;())
{
    MyClass myClass=data[3].value&lt;MyClass&gt;();
    int id=myClass.id;
    QString name=myClass.name;
}
</code></pre>
<a class="header" href="print.html#a保存指针" id="a保存指针"><h2>保存指针</h2></a>
<pre><code class="language-cpp">//保存
QVariant var=QVariant::fromValue((void*)event);

//获取
QPaintEvent* e=(QPaintEvent*)var.value&lt;void*&gt;();

</code></pre>
<a class="header" href="print.html#a如何构建自定义-qt-数据类型" id="a如何构建自定义-qt-数据类型"><h1>如何构建自定义 Qt 数据类型？</h1></a>
<p>可以参见：<a href="http://doc.qt.io/qt-5/custom-types.html">Creating Custom Qt Types</a></p>
<p>主要具备三大因素：</p>
<ul>
<li>公共默认的构造函数(a public default constructor)</li>
<li>公共的拷贝构造函数(a public copy constructor, and)</li>
<li>公共的析构函数(a public destructor.)</li>
</ul>
<p>代码示例：</p>
<pre><code class="language-cpp">class Message
{
public:
    Message();
    Message(const Message &amp;other);
    ~Message();

    Message(const QString &amp;body, const QStringList &amp;headers);

    QString body() const;
    QStringList headers() const;

private:
    QString m_body;
    QStringList m_headers;
};
</code></pre>
<hr />
<p>参见：<code>Q_DECLARE_METATYPE</code> 宏的试用</p>
<p>为了实现这个功能，首先必须使用 <code>Q_DECLARE_METATYPE()</code>宏。通常会将这个宏放在类的声明所在头文件的下面：</p>
<p><code>Q_DECLARE_METATYPE(MyClass)</code></p>
<p>示例：</p>
<p>MyClass.h 文件</p>
<pre><code class="language-h">struct MyClass{
    int id;
    QString name;
};
Q_DECLARE_METATYPE(MyClass)
</code></pre>
<pre><code class="language-cpp">
//存储数据
MyClass myClass;
myClass.id=0;
myClass.name=QString(&quot;LiMing&quot;);

data[0]=QString(&quot;ddd&quot;);
data[1]=123;
data[3]=QVariant::fromValue(myClass);


//获取数据
QString str=data.value(0).toString();
int val=data.value(1).toInt();

if(data[3].canConvert&lt;MyClass&gt;())
{
    MyClass myClass=data[3].value&lt;MyClass&gt;();
    int id=myClass.id;
    QString name=myClass.name;
}
</code></pre>
<a class="header" href="print.html#a用-qvariant-来保存指针" id="a用-qvariant-来保存指针"><h1>用 QVariant 来保存指针</h1></a>
<a class="header" href="print.html#a保存指针-1" id="a保存指针-1"><h2>保存指针</h2></a>
<pre><code class="language-cpp">//保存
QVariant var=QVariant::fromValue((void*)event);

//获取
QPaintEvent* e=(QPaintEvent*)var.value&lt;void*&gt;();

</code></pre>
<a class="header" href="print.html#a判断-qvariant-类型是否可以转换" id="a判断-qvariant-类型是否可以转换"><h1>判断 QVariant 类型是否可以转换？</h1></a>
<pre><code class="language-h">bool QVariant::canConvert(int targetTypeId) const
</code></pre>
<p>具体参考： <a href="http://doc.qt.io/qt-5/qvariant.html">http://doc.qt.io/qt-5/qvariant.html</a></p>
<a class="header" href="print.html#a示例-1" id="a示例-1"><h2>示例 1：</h2></a>
<pre><code class="language-cpp">QDataStream out(...);
QVariant v(123);                // The variant now contains an int
int x = v.toInt();              // x = 123
out &lt;&lt; v;                       // Writes a type tag and an int to out
v = QVariant(&quot;hello&quot;);          // The variant now contains a QByteArray
v = QVariant(tr(&quot;hello&quot;));      // The variant now contains a QString
int y = v.toInt();              // y = 0 since v cannot be converted to an int
QString s = v.toString();       // s = tr(&quot;hello&quot;)  (see QObject::tr())
out &lt;&lt; v;                       // Writes a type tag and a QString to out
...
QDataStream in(...);            // (opening the previously written stream)
in &gt;&gt; v;                        // Reads an Int variant
int z = v.toInt();              // z = 123
qDebug(&quot;Type is %s&quot;,            // prints &quot;Type is int&quot;
        v.typeName());
v = v.toInt() + 100;            // The variant now hold the value 223
v = QVariant(QStringList());

QVariant v = 42;

v.canConvert&lt;int&gt;();              // returns true
v.canConvert&lt;QString&gt;();          // returns true

MyCustomStruct s;
v.setValue(s);

v.canConvert&lt;int&gt;();              // returns false
v.canConvert&lt;MyCustomStruct&gt;();   // returns true
</code></pre>
<a class="header" href="print.html#a示例-2" id="a示例-2"><h2>示例 2</h2></a>
<pre><code class="language-cpp">QHash&lt;int, QString&gt; mapping;
mapping.insert(7, &quot;Seven&quot;);
mapping.insert(11, &quot;Eleven&quot;);
mapping.insert(42, &quot;Forty-two&quot;);

QVariant variant = QVariant::fromValue(mapping);
if (variant.canConvert&lt;QVariantHash&gt;()) {
    QAssociativeIterable iterable = variant.value&lt;QAssociativeIterable&gt;();
    // Can use foreach over the values:
    foreach (const QVariant &amp;v, iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use C++11 range-for over the values:
    for (const QVariant &amp;v : iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use iterators:
    QAssociativeIterable::const_iterator it = iterable.begin();
    const QAssociativeIterable::const_iterator end = iterable.end();
    for ( ; it != end; ++it) {
        qDebug() &lt;&lt; *it; // The current value
        qDebug() &lt;&lt; it.key();
        qDebug() &lt;&lt; it.value();
    }
}
</code></pre>
<a class="header" href="print.html#qt-的迭代器接口如何使用" id="qt-的迭代器接口如何使用"><h1>Qt 的迭代器接口如何使用？</h1></a>
<ul>
<li><a href="http://doc.qt.io/qt-5/qsequentialiterable.html">QSequentialIterable</a></li>
<li><a href="http://doc.qt.io/qt-5/qassociativeiterable.html#details">QAssociativeIterable Qt 关联容器迭代器</a></li>
</ul>
<a class="header" href="print.html#qsequentialiterable" id="qsequentialiterable"><h2>QSequentialIterable</h2></a>
<p>QSequentialIterable 类是 QVariant 中容器的可迭代接口。
The QSequentialIterable class is an iterable interface <strong>for a container in a QVariant</strong>.</p>
<p>This class allows several methods of accessing the elements of a container held within a QVariant. An instance of QSequentialIterable can be extracted from a QVariant if it can be converted to a QVariantList.</p>
<pre><code class="language-cpp">QList&lt;int&gt; intList = {7, 11, 42};

QVariant variant = QVariant::fromValue(intList);
if (variant.canConvert&lt;QVariantList&gt;()) {
    QSequentialIterable iterable = variant.value&lt;QSequentialIterable&gt;();
    // Can use foreach:
    foreach (const QVariant &amp;v, iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use C++11 range-for:
    for (const QVariant &amp;v : iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use iterators:
    QSequentialIterable::const_iterator it = iterable.begin();
    const QSequentialIterable::const_iterator end = iterable.end();
    for ( ; it != end; ++it) {
        qDebug() &lt;&lt; *it;
    }
}
</code></pre>
<a class="header" href="print.html#qassociativeiterable" id="qassociativeiterable"><h2>QAssociativeIterable</h2></a>
<p>QAssociativeIterable 类是 QVariant 中关联容器的可迭代接口。
The QAssociativeIterable class is an iterable interface <strong>for an associative container in a QVariant</strong>.</p>
<pre><code class="language-cpp">QHash&lt;int, QString&gt; mapping;
mapping.insert(7, &quot;Seven&quot;);
mapping.insert(11, &quot;Eleven&quot;);
mapping.insert(42, &quot;Forty-two&quot;);

QVariant variant = QVariant::fromValue(mapping);
if (variant.canConvert&lt;QVariantHash&gt;()) {
    QAssociativeIterable iterable = variant.value&lt;QAssociativeIterable&gt;();
    // Can use foreach over the values:
    foreach (const QVariant &amp;v, iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use C++11 range-for over the values:
    for (const QVariant &amp;v : iterable) {
        qDebug() &lt;&lt; v;
    }
    // Can use iterators:
    QAssociativeIterable::const_iterator it = iterable.begin();
    const QAssociativeIterable::const_iterator end = iterable.end();
    for ( ; it != end; ++it) {
        qDebug() &lt;&lt; *it; // The current value
        qDebug() &lt;&lt; it.key();
        qDebug() &lt;&lt; it.value();
    }
}
</code></pre>
<a class="header" href="print.html#a尽量使用保护机制指针-qpointer增强程序健壮性" id="a尽量使用保护机制指针-qpointer增强程序健壮性"><h1>尽量使用保护机制指针 QPointer，增强程序健壮性</h1></a>
<p>参见：<a href="http://doc.qt.io/qt-5/qpointer.html">QPointer</a></p>
<p>QPointer is a template class that provides guarded pointers to Qt objects and behaves like a normal C++ pointer except that it is automatically set to 0 when the referenced object is destroyed and no &quot;dangling pointers&quot; are produced.
QSharedPointer class holds a strong reference to a shared pointer.
QWeakPointer class holds a weak reference to a shared pointer.</p>
<p>QSharedPointer，它很像 std::shared_ptr，都具有拷贝构造函数、重载赋值运算符。QSharedPointer 可以通过 toWeakRef 转换成 QWeakPointer，std::shared_ptr 也可以转换成 std::weak_ptr 来检查对象是否被销毁。</p>
<a class="header" href="print.html#a尽量使用强引用计数指针-qsharedpointer" id="a尽量使用强引用计数指针-qsharedpointer"><h1>尽量使用强引用计数指针 QSharedPointer</h1></a>
<p>QPointer is a template class that provides guarded pointers to Qt objects and behaves like a normal C++ pointer except that it is automatically set to 0 when the referenced object is destroyed and no &quot;dangling pointers&quot; are produced.
QSharedPointer class holds a strong reference to a shared pointer.
QWeakPointer class holds a weak reference to a shared pointer.</p>
<p>QSharedPointer，它很像 std::shared_ptr，都具有拷贝构造函数、重载赋值运算符。QSharedPointer 可以通过 toWeakRef 转换成 QWeakPointer，std::shared_ptr 也可以转换成 std::weak_ptr 来检查对象是否被销毁。</p>
<a class="header" href="print.html#a尽量使用弱引用计数指针-qweakpointer" id="a尽量使用弱引用计数指针-qweakpointer"><h1>尽量使用弱引用计数指针 QWeakPointer</h1></a>
<p>QPointer is a template class that provides guarded pointers to Qt objects and behaves like a normal C++ pointer except that it is automatically set to 0 when the referenced object is destroyed and no &quot;dangling pointers&quot; are produced.
QSharedPointer class holds a strong reference to a shared pointer.
QWeakPointer class holds a weak reference to a shared pointer.</p>
<p>QSharedPointer，它很像 std::shared_ptr，都具有拷贝构造函数、重载赋值运算符。QSharedPointer 可以通过 toWeakRef 转换成 QWeakPointer，std::shared_ptr 也可以转换成 std::weak_ptr 来检查对象是否被销毁。</p>
<a class="header" href="print.html#a监视-qobject-对象的生命周期" id="a监视-qobject-对象的生命周期"><h1>监视 QObject 对象的生命周期</h1></a>
<p>参见：<a href="http://doc.qt.io/qt-5/qobjectcleanuphandler.html">QObjectCleanupHandler</a></p>
<a class="header" href="print.html#a如何暂时阻止发射信号" id="a如何暂时阻止发射信号"><h1>如何暂时阻止发射信号？</h1></a>
<p>具体引用： <a href="http://doc.qt.io/qt-5/qsignalblocker.html">QSignalBlocker</a></p>
<blockquote>
<p>我们有一个 QCheckBox 对象，当用户检查或者删除检查，我们想要调用一个函数，以便我们将函数连接到 stateChanged ( int 状态) 信号。
另一方面，根据某些条件，我们也改变了代码中 QCheckBox 对象的状态，这导致了不需要的信号。
在某些情况下是否可以阻止发射信号？</p>
</blockquote>
<a class="header" href="print.html#a优先方案" id="a优先方案"><h2>优先方案</h2></a>
<p>Qt5.3 引入了 QSignalBlocker 类，它在异常安全的方法中确实需要。</p>
<pre><code class="language-cpp">if (something) {
 const QSignalBlocker blocker(someQObject);
//no signals here
}
</code></pre>
<p>这种方法等于下面的方式</p>
<pre><code class="language-cpp">const bool wasBlocked = someQObject-&gt;blockSignals(true);
// no signals here
someQObject-&gt;blockSignals(wasBlocked);
</code></pre>
<a class="header" href="print.html#a参考讨论方案-1" id="a参考讨论方案-1"><h2>参考讨论方案 1</h2></a>
<p>你可以使用 clicked 信号，因为只有当用户真正单击复选框时才会发出该信号，而不是使用 setChecked 控件手动检查它。
如果你不想在某个特定时间发出信号，你可以使用 QObject::blockSignals 像这样：</p>
<pre><code class="language-cpp">bool oldState = checkBox-&gt;blockSignals(true);
checkBox-&gt;setChecked(true);
checkBox-&gt;blockSignals(oldState);
</code></pre>
<p>这种方法的缺点是<strong>所有的信号都会被阻塞</strong>。 但我想这对于 QCheckBox 来说并不重要。</p>
<a class="header" href="print.html#a如何使用-qdebug-打印调试信息" id="a如何使用-qdebug-打印调试信息"><h1>如何使用 QDebug 打印调试信息</h1></a>
<p>引入 <code>#include &lt;QDebug&gt;</code></p>
<pre><code class="language-cpp">#include &lt;QDebug&gt;

void info() {
    qDebug() &lt;&lt; &quot;Date:&quot; &lt;&lt; QDate::currentDate();
    qDebug() &lt;&lt; &quot;Types:&quot; &lt;&lt; QString(&quot;String&quot;) &lt;&lt; QChar('x') &lt;&lt; QRect(0, 10, 50, 40);
    qDebug() &lt;&lt; &quot;Custom coordinate type:&quot; &lt;&lt; coordinate;
}

</code></pre>
<a class="header" href="print.html#a二进制数据编辑器需要qbytearray数据类型" id="a二进制数据编辑器需要qbytearray数据类型"><h1>二进制数据编辑器需要QByteArray数据类型</h1></a>
<p>详见内容 <a href="http://doc.qt.io/qt-5/qbytearray.html">QByteArray</a></p>
<pre><code class="language-h">#ifndef XBYTEARRAY_H
#define XBYTEARRAY_H

#include &lt;QByteArray&gt;

class XByteArray
{
public:
    explicit XByteArray();

    QByteArray &amp; data();
    void setData(const QByteArray &amp; data);
    int size();

    QByteArray &amp; insert(int i, char ch);
    QByteArray &amp; insert(int i, const QByteArray &amp; ba);

    QByteArray &amp; remove(int pos, int len);

    QByteArray &amp; replace(int index, char ch);
    QByteArray &amp; replace(int index, const QByteArray &amp; ba);
    QByteArray &amp; replace(int index, int length, const QByteArray &amp; ba);

private:
    QByteArray _data; //raw byte array
};

#endif // XBYTEARRAY_H
</code></pre>
<a class="header" href="print.html#a如何获取当前时间" id="a如何获取当前时间"><h1>如何获取当前时间?</h1></a>
<p>具体内容：参见<a href="http://doc.qt.io/qt-5/qdate.html">QDate</a></p>
<p>引用头文件</p>
<pre><code class="language-cpp">#include &lt;QDate&gt;
</code></pre>
<a class="header" href="print.html#a获取当前时间" id="a获取当前时间"><h2>获取当前时间</h2></a>
<pre><code class="language-cpp">QDate::currentDate()
</code></pre>
<a class="header" href="print.html#qt-gui" id="qt-gui"><h1>Qt GUI</h1></a>
<a class="header" href="print.html#qt-widgets" id="qt-widgets"><h1>Qt Widgets</h1></a>
<a class="header" href="print.html#a如何为应用添加撤销操作" id="a如何为应用添加撤销操作"><h1>如何为应用添加撤销操作?</h1></a>
<p>详见<a href="http://doc.qt.io/qt-5/qundocommand.html">QUndoCommand</a></p>
<a class="header" href="print.html#a如何建立这种机制" id="a如何建立这种机制"><h2>如何建立这种机制？</h2></a>
<ol>
<li>自定义命令类继承<code>QUndoCommand</code></li>
<li>重写类<code>QUndoCommand</code> 的<code>undo()</code>和<code>redo()</code>函数</li>
<li>实际操作中，创建新的命令类对象存储到 <code>QUndoStack</code> 对象中。</li>
<li>实际操作中，通过调用QUndoStack` 对象的undo() 方法，来达到撤销操作的目的</li>
<li>实际操作中，通过调用QUndoStack` 对象的redo() 方法，来达到重新操作的目的</li>
</ol>
<a class="header" href="print.html#step1-自定义命令类继承qundocommand" id="step1-自定义命令类继承qundocommand"><h3>Step1 自定义命令类继承<code>QUndoCommand</code></h3></a>
<pre><code class="language-h">class ArrayCommand : public QUndoCommand
{
public:
    enum Cmd {insert, remove, replace};
    ArrayCommand(XByteArray* xData, Cmd cmd, int baPos, QByteArray newBa = QByteArray(), int len = 0, QUndoCommand* parent = nullptr);
    void undo();
    void redo();

private:
    Cmd _cmd;
    XByteArray* _xData;
    int _baPos;
    int _len;
    QByteArray _wasChanged;
    QByteArray _newBa;
    QByteArray _oldBa;
};
</code></pre>
<a class="header" href="print.html#step2-重写类qundocommand-的undo和redo函数" id="step2-重写类qundocommand-的undo和redo函数"><h3>Step2 重写类<code>QUndoCommand</code> 的<code>undo()</code>和<code>redo()</code>函数</h3></a>
<pre><code class="language-cpp">ArrayCommand::ArrayCommand(XByteArray* xData, Cmd cmd, int baPos, QByteArray newBa, int len, QUndoCommand* parent)
    : QUndoCommand(parent)
{
    _cmd = cmd;
    _xData = xData;
    _baPos = baPos;
    _newBa = newBa;
    _len = len;
}

void ArrayCommand::undo()
{
    switch(_cmd)
    {
    case insert:
        _xData-&gt;remove(_baPos, _newBa.length());
        break;
    case replace:
        _xData-&gt;replace(_baPos, _oldBa);
        break;
    case remove:
        _xData-&gt;insert(_baPos, _oldBa);
        break;
    }
}
</code></pre>
<a class="header" href="print.html#step3-实际操作中创建新的命令类对象存储到-qundostack-对象中" id="step3-实际操作中创建新的命令类对象存储到-qundostack-对象中"><h3>Step3 实际操作中，创建新的命令类对象存储到 <code>QUndoStack</code> 对象中。</h3></a>
<pre><code class="language-cpp">    _undoDataStack = new QUndoStack(this);
    _undoMaskStack = new QUndoStack(this);
</code></pre>
<pre><code class="language-cpp">void QHexEditPrivate::replace(int index, const QByteArray &amp; ba, const QByteArray &amp; mask)
{
    _undoDataStack-&gt;push(new ArrayCommand(&amp;_xData, ArrayCommand::replace, index, ba, ba.length()));
    _undoMaskStack-&gt;push(new ArrayCommand(&amp;_xMask, ArrayCommand::replace, index, mask, mask.length()));
    resetSelection();
    emit dataChanged();
    emit dataEdited();
}

</code></pre>
<a class="header" href="print.html#a实际操作中通过调用qundostack-对象的undo-方法来达到撤销操作的目的" id="a实际操作中通过调用qundostack-对象的undo-方法来达到撤销操作的目的"><h3>实际操作中，通过调用QUndoStack` 对象的undo() 方法，来达到撤销操作的目的</h3></a>
<pre><code class="language-cpp">void QHexEditPrivate::undo()
{
    if(!_undoDataStack-&gt;canUndo() || !_undoMaskStack-&gt;canUndo())
        return;
    _undoDataStack-&gt;undo();
    _undoMaskStack-&gt;undo();
    emit dataChanged();
    emit dataEdited();
    setCursorPos(_cursorPosition);
    update();
}
</code></pre>
<a class="header" href="print.html#a实际操作中通过调用qundostack-对象的redo-方法来达到重新操作的目的" id="a实际操作中通过调用qundostack-对象的redo-方法来达到重新操作的目的"><h3>实际操作中，通过调用QUndoStack` 对象的redo() 方法，来达到重新操作的目的</h3></a>
<pre><code class="language-cpp">void QHexEditPrivate::redo()
{
    if(!_undoDataStack-&gt;canRedo() || !_undoMaskStack-&gt;canRedo())
        return;
    _undoDataStack-&gt;redo();
    _undoMaskStack-&gt;redo();
    emit dataChanged();
    emit dataEdited();
    setCursorPos(_cursorPosition);
    update();
}
</code></pre>
<a class="header" href="print.html#a如何使用消息对话框qmessagebox" id="a如何使用消息对话框qmessagebox"><h1>如何使用消息对话框QMessageBox?</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
