<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>问题:CMake 如何搜索外部库 - Packages Tools Get Start</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Choco Windows 包自动管理</a></li><li><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> vcpkg</a></li><li><ol class="section"><li><a href="vcpkg/install.html"><strong aria-hidden="true">2.1.</strong> 如何安装</a></li><li><a href="vcpkg/simple-commands.html"><strong aria-hidden="true">2.2.</strong> 常用命令</a></li><li><a href="vcpkg/advanced-commands.html"><strong aria-hidden="true">2.3.</strong> 高级命令</a></li><li><a href="vcpkg/code-with-vcpkg-cmake-on-mac.html"><strong aria-hidden="true">2.4.</strong> vcpkg,CMake,Mac</a></li><li><ol class="section"><li><a href="vcpkg/packages/code-with-vcpkg-cmake-on-mac/armadillo/code.html"><strong aria-hidden="true">2.4.1.</strong> armadillo</a></li></ol></li><li><a href="vcpkg/code-with-vcpkg-cmake-on-win.html"><strong aria-hidden="true">2.5.</strong> vcpkg,CMake,Windows</a></li><li><ol class="section"><li><a href="vcpkg/packages/code-with-vcpkg-cmake-on-win/armadillo/code.html"><strong aria-hidden="true">2.5.1.</strong> armadillo</a></li></ol></li><li><a href="vcpkg/code-with-vcpkg-cmake-on-linux.html"><strong aria-hidden="true">2.6.</strong> vcpkg,CMake,Linux</a></li><li><ol class="section"><li><a href="vcpkg/packages/code-with-vcpkg-cmake-on-linux/armadillo/code.html"><strong aria-hidden="true">2.6.1.</strong> armadillo</a></li></ol></li><li><a href="vcpkg/code-with-vcpkg-vs2017-on-win.html"><strong aria-hidden="true">2.7.</strong> vcpkg,VS2017,Windows</a></li><li><ol class="section"><li><a href="vcpkg/packages/code-with-vcpkg-vs2017-on-win/armadillo/code.html"><strong aria-hidden="true">2.7.1.</strong> armadillo</a></li></ol></li></ol></li><li><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> CMake</a></li><li><ol class="section"><li><a href="cmake/cmake-commands.html"><strong aria-hidden="true">3.1.</strong> CMake 命令</a></li><li><a href="cmake/CMakeLists-syntax.html"><strong aria-hidden="true">3.2.</strong> CMakeLists.txt 语法</a></li><li><a href="cmake/execute-examples.html"><strong aria-hidden="true">3.3.</strong> 例子: 可执行程序</a></li><li><a href="cmake/static-lib-examples.html"><strong aria-hidden="true">3.4.</strong> 例子: 静态库</a></li><li><a href="cmake/dynamic-lib-examples.html"><strong aria-hidden="true">3.5.</strong> 例子: 动态库</a></li><li><a href="cmake/all-faq/10001.html" class="active"><strong aria-hidden="true">3.6.</strong> 问题:CMake 如何搜索外部库</a></li></ol></li><li><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Brew</a></li><li><ol class="section"><li><a href="brew/install.html"><strong aria-hidden="true">4.1.</strong> 如何安装</a></li><li><a href="brew/simple-commands.html"><strong aria-hidden="true">4.2.</strong> 常用命令行参考</a></li><li><a href="brew/advanced-commands.html"><strong aria-hidden="true">4.3.</strong> 高级命令参考</a></li><li><a href="brew/env.html"><strong aria-hidden="true">4.4.</strong> 环境变量</a></li><li><a href="brew/code-with-cplus-and-cmake.html"><strong aria-hidden="true">4.5.</strong> C/C++与 CMake</a></li><li><a href="brew/code-with-xcode.html"><strong aria-hidden="true">4.6.</strong> XCode</a></li><li><a href="brew/formulas/index.html"><strong aria-hidden="true">4.7.</strong> 常用公式库</a></li><li><ol class="section"><li><a href="brew/formulas/index-maths.html"><strong aria-hidden="true">4.7.1.</strong> 数学库</a></li><li><ol class="section"><li><a href="brew/formulas/armadillo.html"><strong aria-hidden="true">4.7.1.1.</strong> Armadillo</a></li><li><a href="brew/formulas/eigen.html"><strong aria-hidden="true">4.7.1.2.</strong> Eigen</a></li><li><a href="brew/formulas/opencv.html"><strong aria-hidden="true">4.7.1.3.</strong> OpenCV</a></li><li><a href="brew/formulas/petsc.html"><strong aria-hidden="true">4.7.1.4.</strong> *PETSc</a></li></ol></li></ol></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Packages Tools Get Start</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="cmake/all-faq/10001.html#a10001-cmake-是如何找到我们程序引用的依赖库和头文件的" id="a10001-cmake-是如何找到我们程序引用的依赖库和头文件的"><h1>10001 cmake 是如何找到我们程序引用的依赖库和头文件的？</h1></a>
<a class="header" href="cmake/all-faq/10001.html#a说明" id="a说明"><h2>说明</h2></a>
<p>如果你的代码使用了外部库（external libraries），并且你事先不知道这些库的头文件和库文件在当前平台的位置。那么适当的文件夹路径和库的搜索路径就应该被添加到编译命令中去。</p>
<a class="header" href="cmake/all-faq/10001.html#a解决方法" id="a解决方法"><h2>解决方法</h2></a>
<p><strong>CMake 提供了一个非常棒的 <code>module</code> 查找机制</strong></p>
<a class="header" href="cmake/all-faq/10001.html#a应用场景" id="a应用场景"><h3>应用场景</h3></a>
<p>假设你要使用 <code>LibXML++</code>库，但是 CMake 没有提供该库的 <code>module</code>。同时，你发现网上有其他人提供了 <code>FindLibXML++.cmake</code>.
此时你可以下载该文件并把它丢到 <code>CMake module</code> 路径下。</p>
<p>CMake 本身提供了很多常用库的 module 来帮助你查找该库。使用命令 <code>cmake --help-module-list</code>
可以查看提供了哪些 module，或者到 module 的存放路径下查看，
(1)在 ubuntu Linux 上的位置通常在／usr/share/cmake/Modules/下。
(2)在 MacOS 上的位置一般在 /usr/local/opt/cmake/Modules/</p>
<a class="header" href="cmake/all-faq/10001.html#cmake-的-packagemodule-查找机制" id="cmake-的-packagemodule-查找机制"><h3>CMake 的 package/module 查找机制</h3></a>
<p>想弄清楚这个问题，就不得不提到 CMake 提供的 <code>find_package</code> 命令。</p>
<a class="header" href="cmake/all-faq/10001.html#find_package-介绍" id="find_package-介绍"><h4>FIND_PACKAGE 介绍</h4></a>
<pre><code class="language-c">FIND_PACKAGE( &lt;name&gt; [version] [EXACT] [QUIET] [NO_MODULE] [ [ REQUIRED | COMPONENTS ] [ componets... ] ] )
</code></pre>
<p>用来调用预定义在 ${CMAKE_MODULE_PATH} 下的 Find<name>.cmake 模块。
也可以自己定义 Find<name>模块，将其放入工程的某个目录中，通过 SET(CMAKE_MODULE_PATH dir)设置查找路径，供工程 FIND_PACKAGE 使用。
这条命令执行后，CMake 会到变量 CMAKE_MODULE_PATH 指示的目录中查找文件 Findname.cmake 并执行。</p>
<ul>
<li>version 参数
需要一个版本号，它是正在查找的包应该兼容的版本号（格式是 major[.minor[.patch[.tweak]]]）。</li>
<li>EXACT 选项
要求版本号必须精确匹配。如果在 find-module 内部对该命令的递归调用没有给定[version]参数，那么[version]和 EXACT 选项会自动地从外部调用前向继承。对版本的支持目前只存在于包和包之间（详见下文）。</li>
<li>QUIET 参数
会禁掉包没有被发现时的警告信息。对应于 Find<name>.cmake 模块中的 NAME_FIND_QUIETLY。</li>
<li>REQUIRED 参数
其含义是指是否是工程必须的，表示如果报没有找到的话，cmake 的过程会终止，并输出警告信息。对应于 Find<name>.cmake 模块中的 NAME_FIND_REQUIRED 变量。</li>
<li>COMPONENTS 参数
在 REQUIRED 选项之后，或者如果没有指定 REQUIRED 选项但是指定了 COMPONENTS 选项，在它们的后面可以列出一些与包相关（依赖）的部件清单（components list）</li>
</ul>
<p>示例：</p>
<pre><code class="language-c">FIND_PACKAGE( libdb_cxx REQUIRED)
# 这条命令执行后，CMake 会到变量 CMAKE_MODULE_PATH 指示的目录中查找文件 Findlibdb_cxx.cmake 并执行。
</code></pre>
<a class="header" href="cmake/all-faq/10001.html#find_package-是如何工作的" id="find_package-是如何工作的"><h4>FIND_PACKAGE 是如何工作的？</h4></a>
<p><code>find_package()</code> 命令会在模块路径中寻找 <code>Find&lt;name&gt;.cmake</code> ，这是查找库的一个典型方式。首先 CMake 查看<code>${CMAKE_MODULE_PATH}</code> 中的所有目录，然后再查看它自己的模块目录 <code>&lt;CMAKE_ROOT&gt;/share/cmake-x.y/Modules/</code> 。</p>
<p>如果没找到这样的文件，会寻找 <code>&lt;Name&gt;Config.cmake</code> 或者 <code>&lt;lower-case-name&gt;-config.cmake</code> ，它们是假定库会安装的文件（但是目前还没有多少库会安装它们）。不做检查，直接包含安装的库的固定值。</p>
<p>前面的称为模块模式，后面的称为配置模式。配置模式的文件的编写见 <a href="http://vtk.org/Wiki/CMake/Tutorials/How_to_create_a_ProjectConfig.cmake_file">这里的文档</a> 。可能还会用到 <a href="http://vtk.org/Wiki/CMake/Tutorials/Exporting_and_Importing_Targets">importing and exporting targets</a> 这篇文档。</p>
<p>模块系统好像还没有文档，所以本文主要讨论这方面的内容。</p>
<p>不管使用哪一种模式，只要找到包，就会定义下面这些变量：</p>
<pre><code class="language-c">&lt;NAME&gt;_FOUND
&lt;NAME&gt;_INCLUDE_DIRS or &lt;NAME&gt;_INCLUDES
&lt;NAME&gt;_LIBRARIES or &lt;NAME&gt;_LIBRARIES or &lt;NAME&gt;_LIBS
&lt;NAME&gt;_DEFINITIONS
</code></pre>
<p>这些都在 <code>Find&lt;name&gt;.cmake</code> 文件中。</p>
<p>现在，在你的代码（要使用库 <code>&lt;name&gt;</code> 的代码）的顶层目录中的 <code>CMakeLists.txt</code> 文件中，我们检查变量<code>&lt;NAME&gt;\_FOUND</code> 来确定包是否被找到。大部分包的这些变量中的包名是全大写的，如 <code>LIBFOO_FOUND</code> ，有些包则使用包的实际大小写，如 <code>LibFoo_FOUND</code> 。如果找到这个包，我们用 <code>&lt;NAME&gt;\_INCLUDE_DIRS</code> 调用 <code>include_directories()</code> 命令，用 &lt;<code>NAME&gt;\_LIBRARIES</code> 调用 <code>target_link_libraries()</code> 命令。</p>
<p>这些约定的文档在 CMake 模块目录中的 <code>readme.txt</code> 文件中。</p>
<p><code>REQUIRED</code> 和其他可选的 <code>find_package</code> 的参数被 <code>find_package</code> 传给模块，模块由此确定操作。</p>
<p>用户代码总体上应该使用上述的简单调用格式查询需要的包。本命令文档的剩余部分则详述了 <code>find_package</code> 的完整命令格式以及具体的查询过程。期望通过该命令查找并提供包的项目维护人员，我们鼓励你能继续读下去。</p>
<p>该命令在搜索包时有两种模式：“模块”模式和“配置”模式。当该命令是通过上述的精简格式调用的时候，用的就是模块模式。在该模式下，CMake 搜索所有名为 <code>Find&lt;package&gt;.cmake</code> 的文件，这些文件的路径由安装 CMake 时指定的 <code>CMAKE_MODULE_PATH</code> 变量指定。如果查找到了该文件，它会被 <code>CMake</code> 读取并被处理。该模式对查找包，检查版本以及生成任何别的必须信息负责。许多查找模块<code>（find-module）</code>仅仅提供了有限的，甚至根本就没有对版本化的支持；具体信息查看该模块的文档。如果没有找到任何模块，该命令会进入配置模式继续执行。</p>
<p>完整的配置模式下的命令格式是：</p>
<pre><code class="language-c">find_package(&lt;package&gt; [version] [EXACT] [QUIET]
            [[REQUIRED|COMPONENTS] [components...]] [NO_MODULE]
            [NO_POLICY_SCOPE]
            [NAMES name1 [name2 ...]]
            [CONFIGS config1 [config2 ...]]
            [HINTS path1 [path2 ... ]]
            [PATHS path1 [path2 ... ]]
            [PATH_SUFFIXES suffix1 [suffix2 ...]]
            [NO_DEFAULT_PATH]
            [NO_CMAKE_ENVIRONMENT_PATH]
            [NO_CMAKE_PATH]
            [NO_SYSTEM_ENVIRONMENT_PATH]
            [NO_CMAKE_PACKAGE_REGISTRY]
            [NO_CMAKE_BUILDS_PATH]
            [NO_CMAKE_SYSTEM_PATH]
            [CMAKE_FIND_ROOT_PATH_BOTH |
            ONLY_CMAKE_FIND_ROOT_PATH |
            NO_CMAKE_FIND_ROOT_PATH])
</code></pre>
<p><code>NO_MODULE</code> 可以用来明确地跳过模块模式。它也隐含指定了不使用在精简格式中使用的那些选项。</p>
<p>配置模式试图查找一个由待查找的包提供的配置文件的位置。包含该文件的路径会被存储在一个名为<code>&lt;package&gt;\_DIR</code> 的 <code>cache</code> 条目里。默认情况下，该命令搜索名为<code>&lt;package&gt;</code>的包。如果指定了 <code>NAMES</code> 选项，那么其后的 <code>names</code> 参数会取代<code>&lt;package&gt;</code>的角色。该命令会为每个在 <code>names</code> 中的 <code>name</code> 搜索名为<code>&lt;name&gt;Config.cmake</code> 或者<code>&lt;name 全小写&gt;-config.cmake</code> 的文件。</p>
<p>通过使用 <code>CONFIGS</code> 选项可以改变可能的配置文件的名字。以下描述搜索的过程。如果找到了配置文件，它将会被 CMake 读取并处理。由于该文件是由包自身提供的，它已经知道包中内容的位置。配置文件的完整地址存储在 cmake 的变量<code>&lt;package&gt;\_CONFIG</code> 中。</p>
<p>所有 CMake 要处理的配置文件将会搜索该包的安装信息，并且将该安装匹配的适当版本号（appropriate version）存储在 cmake 变量<code>&lt;package&gt;\_CONSIDERED_CONFIGS</code> 中，与之相关的版本号（associated version）将被存储在&lt;<code>package&gt;\_CONSIDERED_VERSIONS</code> 中。</p>
<p>如果没有找到包配置文件，CMake 将会生成一个错误描述文件，用来描述该问题——除非指定了 QUIET 选项。如果指定了 REQUIRED 选项，并且没有找到该包，将会报致命错误，然后配置步骤终止执行。如果设置了<code>&lt;package&gt;\_DIR</code> 变量被设置了，但是它没有包含配置文件信息，那么 CMake 将会直接无视它，然后重新开始查找。</p>
<p>如果给定了[version]参数，那么配置模式仅仅会查找那些在命令中请求的版本（格式是 major[.minor[.patch[.tweak]]]）与包请求的版本互相兼容的那些版本的包。如果指定了 EXACT 选项，一个包只有在它请求的版本与[version]提供的版本精确匹配时才能被找到。CMake 不会对版本数的含义做任何的转换。包版本号由包自带的版本文件来检查。对于一个备选的包配置文件&lt;config-file&gt;.cmake，对应的版本文件的位置紧挨着它，并且名字或者是&lt;config-file&gt;-version.cmake 或者是&lt;config-file&gt;Version.cmake。如果没有这个版本文件，那么配置文件就会认为不兼容任何请求的版本。当找到一个版本文件之后，它会被加载然后用来检查（find_package）请求的版本号。版本文件在一个下述变量被定义的嵌套域中被加载：</p>
<ul>
<li><code>PACKAGE_FIND_NAME</code> = <package>名字。</li>
<li><code>PACKAGE_FIND_VERSION</code> = 请求的完整版本字符串</li>
<li><code>PACKAGE_FIND_VERSION_MAJOR</code> = 如果被请求了，那么它是 major 版本号，否则是 0。</li>
<li><code>PACKAGE_FIND_VERSION_MINOR</code> = 如果被请求了，那么它是 minor 版本号，否则是 0。</li>
<li><code>PACKAGE_FIND_VERSION_PATCH</code> = 如果被请求了，那么它是 patch 版本号，否则是 0。</li>
<li><code>PACKAGE_FIND_VERSION_TWEAK</code> = 如果被请求了，那么它是 tweak 版本号，否则是 0。</li>
<li><code>PACKAGE_FIND_VERSION_COUNT</code> = 版本号包含几部分，0 到 4。</li>
</ul>
<p>版本文件会检查自身是否满足请求的版本号，然后设置了下面这些变量：</p>
<ul>
<li><code>PACKAGE_VERSION</code> = 提供的完整的版本字符串。</li>
<li><code>PACKAGE_VERSION_EXACT</code> = 如果版本号精确匹配，返回 true。</li>
<li><code>PACKAGE_VERSION_COMPATIBLE</code> = 如果版本号相兼容，返回 true。</li>
<li><code>PACKAGE_VERSION_UNSUITABLE</code> = 如果不适合任何版本，返回 true。</li>
</ul>
<p>下面这些变量将会被 <code>find_package</code> 命令检查，用以确定配置文件是否提供了可接受的版本。在 <code>find_package</code> 命令返回后，这些变量就不可用了。如果版本可接受，下述的变量会被设置：</p>
<ul>
<li><code>&lt;package&gt;\_VERSION</code> = 提供的完整的版本字符串。</li>
<li><code>&lt;package&gt;\_VERSION_MAJOR</code> = 如果被请求了，那么它是 major 版本号，否则是 0。</li>
<li><code>&lt;package&gt;\_VERSION_MINOR</code> = 如果被请求了，那么它是 minor 版本号，否则是 0。</li>
<li><code>&lt;package&gt;\_VERSION_PATCH</code> = 如果被请求了，那么它是 patch 版本号，否则是 0。</li>
<li><code>&lt;package&gt;\_VERSION_TWEAK</code> = 如果被请求了，那么它是 tweak 版本号，否则是 0。</li>
<li><code>&lt;package&gt;\_VERSION_COUNT</code> = 版本号包含几部分，0 到 4。</li>
</ul>
<p>然后，对应的包配置文件才会被加载。当多个包配置文件都可用时，并且这些包的版本文件都与请求的版本兼容，选择哪个包将会是不确定的。不应该假设 cmake 会选择最高版本或者是最低版本。（以上的若干段是对 <code>find_package</code> 中版本匹配步骤的描述，并不需要用户干预——译注。）</p>
<p>配置模式提供了一种高级接口和搜索步骤的接口。这些被提供的接口的大部分是为了完整性的要求，以及在模块模式下，包被 <code>find-module</code> 加载时供内部使用。大多数用户仅仅应该调用.</p>
<pre><code class="language-c">find_package(&lt;package&gt; [major[.minor]] [EXACT] [REQUIRED|QUIET])
</code></pre>
<p>来查找包。鼓励那些需要提供 CMake 包配置文件的包维护人员应该命名这些文件并安装它们，这样下述的整个过程将会找到它们而不需要使用附加的选项。</p>
<p>CMake 为包构造了一组可能的安装前缀。在每个前缀下，若干个目录会被搜索，用来查找配置文件。下述的表格展示了待搜索的路径。每个条目都是专门为 Windows(W)，UNIX(U)或者 Apple(A)约定的安装树指定的。</p>
<pre><code class="language-c">   &lt;prefix&gt;/                                               (W)
   &lt;prefix&gt;/(cmake|CMake)/                                 (W)
   &lt;prefix&gt;/&lt;name&gt;*/                                       (W)
   &lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/                         (W)
   &lt;prefix&gt;/(share|lib)/cmake/&lt;name&gt;*/                     (U)
   &lt;prefix&gt;/(share|lib)/&lt;name&gt;*/                           (U)
   &lt;prefix&gt;/(share|lib)/&lt;name&gt;*/(cmake|CMake)/             (U)
</code></pre>
<p>在支持 OS X 平台和 Application Bundles 的系统上，包含配置文件的框架或者 bundles 会在下述的路径中被搜索：</p>
<pre><code class="language-c">   &lt;prefix&gt;/&lt;name&gt;.framework/Resources/                    (A)
   &lt;prefix&gt;/&lt;name&gt;.framework/Resources/CMake/              (A)
   &lt;prefix&gt;/&lt;name&gt;.framework/Versions/*/Resources/         (A)
   &lt;prefix&gt;/&lt;name&gt;.framework/Versions/*/Resources/CMake/   (A)
   &lt;prefix&gt;/&lt;name&gt;.app/Contents/Resources/                 (A)
   &lt;prefix&gt;/&lt;name&gt;.app/Contents/Resources/CMake/           (A)
</code></pre>
<p>在所有上述情况下，<code>&lt;name&gt;</code>是区分大小写的，并且对应于在<code>&lt;package&gt;</code>或者由 NAMES 给定的任何一个名字。</p>
<p>这些路径集用来与那些在各自的安装树上提供了配置文件的工程协作。上述路径中被标记为(W)的是专门为 Windows 上的安装设置的，其中的<code>&lt;prefix&gt;</code>部分可能是一个应用程序的顶层安装路径。那些被标记为(U)的是专门为 UNIX 平台上的安装设置的，其中的<code>&lt;prefix&gt;</code>被多个包共用。这仅仅是个约定，因此，所有(W)和(U)路径在所有平台上都仍然会被搜索。那些被标记为(A)的路径是专门为 Apple 平台上的安装设置的。CMake 变量 <code>CMAKE_FIND_FRAMEWORK</code> 和 <code>CMAKE_FIND_APPBUNDLE</code> 确定了偏好的顺序，如下所示：</p>
<p>安装前缀是通过以下步骤被构建出来的。如果指定了 NO<em>DEFAULT_PATH 选项，所有 NO</em>*选项都会被激活。</p>
<p>1、搜索在 cmake 特有的 cache 变量中指定的搜索路径。这些变量是为了在命令行中用-DVAR=value 选项指定而设计的。通过指定 <code>NO_CMAKE_PATH</code> 选项可以跳过该搜索路径。搜索路径还包括：</p>
<pre><code class="language-c">CMAKE_PREFIX_PATH
CMAKE_FRAMEWORK_PATH
CMAKE_APPBUNDLE_PATH
</code></pre>
<p>2、搜索 cmake 特有的环境变量。这些变量是为了在用户的 shell 配置中进行配置而设计的。通过指定 NO_CMAKE_ENVIRONMENT_PATH 选项可以跳过该路径。搜索的路径包括：</p>
<pre><code class="language-c">&lt;package&gt;_DIR
CMAKE_PREFIX_PATH
CMAKE_FRAMEWORK_PATH
CMAKE_APPBUNDLE_PATH
</code></pre>
<p>3、搜索 HINTS 选项指定的路径。这些路径应该是由操作系统内省时计算产生的，比如由其它已经找到的项的位置而提供的线索。硬编码的参考路径应该在 PATHS 选项中指定。</p>
<p>4、搜索标准的系统环境变量。如果指定了 NO_SYSTEM_ENVIRONMENT_PATH 选项，这些路径会被跳过。以&quot;/bin&quot;或&quot;/sbin&quot;结尾的路径条目会被自动转换为它们的父路径。搜索的路径包括：</p>
<pre><code class="language-c">PATH
</code></pre>
<p>5、搜索在 CMake GUI 中最新配置过的工程的构建树。可以通过设置 NO_CMAKE_BUILDS_PATH 选项来跳过这些路径。这是为了在用户正在依次构建多个相互依赖的工程时而准备的。</p>
<p>6、搜索存储在 CMake 用户包注册表中的路径。通过设置 <code>NO_CMAKE_PACKAGE_REGISTRY</code> 选项可以跳过这些路径。当 CMake 嗲用 e<code>xport(PACKAGE&lt;name&gt;)</code>配置一个工程时，这些路径会被存储在注册表中。参见 export(PACKAGE)命令的文档阅读更多细节。</p>
<p>7、搜索在当前系统的平台文件中定义的 cmake 变量。可以用 <code>NO_CMAKE_SYSTEM_PATH</code> 选项跳过这些路径。</p>
<pre><code class="language-c">CMAKE_SYSTEM_PREFIX_PATH
CMAKE_SYSTEM_FRAMEWORK_PATH
CMAKE_SYSTEM_APPBUNDLE_PATH
</code></pre>
<p>8、搜索由 PATHS 选项指定的路径。这些路径一般是硬编码的参考路径。
在 Darwin 或者支持 OS X 框架的系统上，cmake 变量 <code>CMAKE_FIND_FRAMEWORK</code> 可以用来设置为空，或者下述值之一：</p>
<pre><code class="language-c">&quot;FIRST&quot;  - 在标准库或头文件之前查找框架。在Darwin系统上这是默认选项。
&quot;LAST&quot;   - 在标准库或头文件之后查找框架。
&quot;ONLY&quot;   - 仅仅查找框架。
&quot;NEVER&quot;  - 从不查找框架。
</code></pre>
<p>在 Darwin 或者支持 OS X Application Bundles 的系统，cmake 变量 CMAKE_FIND_APPBUNDLE 可以被设置为空或者下面这些值中的一个：</p>
<pre><code class="language-c">&quot;FIRST&quot;  - 在标准库或头文件之前查找application bundles。在Darwin系统上这是默认选项。
&quot;LAST&quot;   - 在标准库或头文件之后查找application bundles。
&quot;ONLY&quot;   - 仅仅查找application bundles。
&quot;NEVER&quot;  - 从不查找application bundles。
</code></pre>
<p>CMake 变量 CMAKE_FIND_ROOT_PATH 指定了一个或者多个优先于其他搜索路径的搜索路径。该变量能够有效地重新定位在给定位置下进行搜索的根路径。该变量默认为空。当使用交叉编译时，该变量十分有用：用该变量指向目标环境的根目录，然后 CMake 将会在那里查找。默认情况下，在 CMAKE_FIND_ROOT_PATH 中列出的路径会首先被搜索，然后是“非根”路径。该默认规则可以通过设置 CMAKE_FIND_ROOT_PATH_MODE_LIBRARY 做出调整。在每次调用该命令之前，都可以通过设置这个变量来手动覆盖默认行为。如果使用了 NO_CMAKE_FIND_ROOT_PATH 变量，那么只有重定位的路径会被搜索。</p>
<p>默认的搜索顺序的设计逻辑是按照使用时从最具体到最不具体。通过多次调用 find<em>library 命令以及 NO</em>*选项，可以覆盖工程的这个默认顺序：</p>
<pre><code class="language-c">find_library(&lt;VAR&gt; NAMES name PATHS paths... NO_DEFAULT_PATH)
find_library(&lt;VAR&gt; NAMES name)
</code></pre>
<p>只要这些调用中的一个成功返回，结果变量就会被设置并且被存储到 cache 中；这样随后的调用都不会再行搜索。如果那找到的库是一个框架，VAR 将会被设置为指向框架“&lt;完整路径&gt;/A.framework” 的完整路径。当一个指向框架的完整路径被用作一个库文件，CMake 将使用-framework A，以及-F&lt;完整路径&gt;这两个选项将框架连接到目标上。</p>
<p>参见 <code>cmake_policy()</code>命令的文档中关于 <code>NO_POLICY_SCOPE</code> 选项讨论。</p>
<a class="header" href="cmake/all-faq/10001.html#a使用-cmake-自带查找模块的外部库" id="a使用-cmake-自带查找模块的外部库"><h4>使用 cmake 自带查找模块的外部库</h4></a>
<p>为了能支持各种常见的库和包，CMake 自带了很多模块。可以通过命令 cmake --help-module-list （输入 cmake --help，然后双击 Tab 会有命令提示）得到你的 CMake 支持的模块的列表：</p>
<pre><code class="language-c">.......
.......
CMakeDetermineVSServicePack
CMakeExpandImportedTargets
CMakeFindFrameworks
CMakeFindPackageMode
CMakeForceCompiler
CMakeGraphVizOptions
CMakePackageConfigHelpers
CMakeParseArguments
CMakePrintHelpers
CMakePrintSystemInformation
CMakePushCheckState
......
......
</code></pre>
<p>或者直接查看模块路径。比如 Ubuntu linux 上，模块的路径是 ls /usr/share/cmake/Modules</p>
<pre><code class="language-c">.......
AddFileDependencies.cmake                                       CPackDeb.cmake                    FindOpenThreads.cmake
AutomocInfo.cmake.in                                            CPackNSIS.cmake                   FindPHP4.cmake
BasicConfigVersion-AnyNewerVersion.cmake.in                     CPackPackageMaker.cmake           FindPNG.cmake
BasicConfigVersion-ExactVersion.cmake.in                        CPackRPM.cmake                    FindPackageHandleStandardArgs.cmake
BasicConfigVersion-SameMajorVersion.cmake.in                    CPackWIX.cmake                    FindPackageMessage.cmake
FindBZip2.cmake
.......
</code></pre>
<p>让我们以 bzip2 库为例。CMake 中有个 FindBZip2.cmake 模块。只要使用 find_package(BZip2) 调用这个模块，cmake 会自动给一些变量赋值，然后就可以在 CMake 脚本中使用它们了。变量的列表可以查看 cmake 模块文件，或者使用命令 cmake --help-module FindBZip2 :</p>
<pre><code class="language-c">  FindBZip2
       Try to find BZip2

       Once done this will define

         BZIP2_FOUND - system has BZip2
         BZIP2_INCLUDE_DIR - the BZip2 include directory
         BZIP2_LIBRARIES - Link these to use BZip2
         BZIP2_NEED_PREFIX - this is set if the functions are prefixed with BZ2_
         BZIP2_VERSION_STRING - the version of BZip2 found (since CMake 2.8.8)
</code></pre>
<p>比如一个使用 bzip2 的简单程序，编译器需要知道 bzlib.h 的位置，链接器需要找到 bzip2 库（动态链接的话，Unix 上是 libbz2.so 类似的文件，Windows 上是 libbz2.dll ）。</p>
<pre><code class="language-c">cmake_minimum_required(VERSION 2.8)
project(helloworld)
add_executable(helloworld hello.c)
find_package (BZip2)
if (BZIP2_FOUND)
  include_directories(${BZIP_INCLUDE_DIRS})
  target_link_libraries (helloworld ${BZIP2_LIBRARIES})
endif (BZIP2_FOUND)
</code></pre>
<p>可以用 cmake 和 <code>make VERBOSE=1</code> 来验证传给编译器和链接器的 flag 是否正确。也可以用 ldd 或者 <code>dependency walker</code> 之类的工具在编译后验证 helloworld 链接的文件。</p>
<a class="header" href="cmake/all-faq/10001.html#a使用-cmake-没有自带-查找模块的外部库" id="a使用-cmake-没有自带-查找模块的外部库"><h4>使用 cmake 没有自带, 查找模块的外部库</h4></a>
<p>假设你想要使用 <code>LibXML++</code>库。在写本文时，CMake 还没有一个 <code>libXML++</code>的查找模块。但是可以在网上搜索到一个（ <code>FindLibXML++.cmake</code> ）。在 <code>CMakeLists.txt</code> 中写：</p>
<pre><code class="language-c">find_package(LibXML++ REQUIRED)
include_directories(${LibXML++_INCLUDE_DIRS})
set(LIBS ${LIBS} ${LibXML++_LIBRARIES})
</code></pre>
<p>如果包是可选的，可以忽略 REQUIRED 关键字，通过 LibXML++_FOUND 布尔变量来判断是否找到。检测完所有的库后，对于链接目标有：</p>
<pre><code class="language-c">target_link_libraries(exampleProgram ${LIBS})
</code></pre>
<p>为了能正常的工作，需要把 <code>FindLibXML++.cmake</code> 文件放到 CMake 的模块路径<code>（/usr/share/cmake/Modules/）</code>。因为 CMake 还不包含它，需要在项目中指定。在自己的项目根目录下创建一个 cmake/Modules/ 文件夹，并且在主 <code>CMakeLists.txt</code>中包含下面的代码：</p>
<pre><code class="language-c">set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} &quot;${CMAKE_SOURCE_DIR}/cmake/Modules/&quot;)
</code></pre>
<p>把刚才的需要用到的 CMake 模块放到这个文件夹下。</p>
<p>一般来说就是这样。有些库可能还需要些其他的什么，所以要再看一下 <code>FindSomething.cmake</code> 文件的文档。</p>
<a class="header" href="cmake/all-faq/10001.html#a包含组件的依赖包" id="a包含组件的依赖包"><h4>包含组件的依赖包</h4></a>
<p>有些库不是一个整体，还包含一些依赖的库或者组件。一个典型的例子是 Qt 库，它其中包含 QtOpenGL 和 QtXml 组件。使用下面的 find_package 命令来使用这些组件：</p>
<pre><code class="language-c">find_package(Qt COMPONENTS QtOpenGL QtXml REQUIRED)
</code></pre>
<p>如果包是可选的，这里同样可以忽略 REQUIRED 关键字。这时可以使用 <PACKAGE>_<COMPONENT>_FOUND 变量（如 Qt_QtXml_FOUND ）来检查组件是否被找到。下面的 find_package 命令是等价的</p>
<pre><code class="language-c">find_package(Qt COMPONENTS QtOpenGL QtXml REQUIRED)
find_package(Qt REQUIRED COMPONENTS QtOpenGL QtXml)
find_package(Qt REQUIRED QtOpenGL QtXml)
</code></pre>
<p>如果包中的组件有些是必需的，有些不是，可以调用 <code>find_package</code> 两次：</p>
<pre><code class="language-c">find_package(Qt COMPONENTS QtXml REQUIRED)
find_package(Qt COMPONENTS QtOpenGL)
</code></pre>
<p>或者也可以不加 REQUIRED 关键字用 find_package 同时查找全部组件，然后再显式地检查必需的组件：</p>
<pre><code class="language-c">find_package(Qt COMPONENTS QtOpenGL QtXml)
if ( NOT Qt_FOUND OR NOT QtXml_FOUND )
  message(FATAL_ERROR &quot;Package Qt and component QtXml required, but not found!&quot;)
endif( NOT Qt_FOUND OR NOT QtXml_FOUND )
</code></pre>
<a class="header" href="cmake/all-faq/10001.html#a介绍下-pkg-config" id="a介绍下-pkg-config"><h4>介绍下 pkg-config</h4></a>
<p>pkg-config 是个用来帮助构建的工具，它基于记录库文件和头文件位置的 .pc 文件。主要用在类 Unix 系统上。可以在 pkg-config 的网站 找到更多的信息。CMake 可以利用 pkg-config，可以在 CMake 的模块目录下的 FindPkgConfig.cmake 文件中找到相关的文档。这在当你处理一个没有 cmake 脚本的库的时候，或者遇到 CMake 的查找脚本失效的情况，非常有帮助。</p>
<p>但是，直接使用 pkg-config 的结果需要非常小心。一个主要原因是对于 ccmake 手动定义的库路径，可能覆盖到或者发生冲突。此外，也有可能 pkg-config 提供了错误的信息（错误的编辑器等）。对于这些情况，让 CMake 不依赖 pkg-config 做检测，而只用 pkg-config 作为查找路径的提示。</p>
<a class="header" href="cmake/all-faq/10001.html#a编写查找模块" id="a编写查找模块"><h4>编写查找模块</h4></a>
<p>首先，注意传给 <code>find_package</code> 的名字或者前缀，是用于全部变量的部分文件名和前缀。这很重要，名字必须完全匹配。不幸的是很多情况下，即使是 CMake 自带的模块，也有不匹配的名字，导致各种问题。</p>
<p>模块的基本操作应该大体按下面的顺序：</p>
<ul>
<li>使用 find_package 检测库依赖的其他的库
<ul>
<li>需要转发 QUIETLY 和 REQUIRED 参数（比如，如果当前的包是 REQUIRED 的，它的依赖也应该是）</li>
</ul>
</li>
<li>可选地使用 pkg-config 来检测 include/library 的路径（如果 pkg-config 可用的话）</li>
<li>分别使用 find_path 和 find_library 寻找头文件和库文件
<ul>
<li>pkg-config 提供的路径只用来作为查找位置的提示</li>
<li>CMake 也有很多其他查找路径是写死的</li>
<li>结果应该保存在 <name>_INCLUDE_DIR 和 <name>_LIBRARY 变量中（注意不是复数形式)</li>
</ul>
</li>
<li>设置 <name>_INCLUDE_DIRS 到 <name>_INCLUDE_DIR <dependency1>_INCLUDE_DIRS ...</li>
<li>设置 <name>_LIBRARIES 到 <name>_LIBRARY <dependency1>_LIBRARIES ...
<ul>
<li>依赖使用复数形式，包自身使用 find_path 和 find_library 定义的单数形式</li>
</ul>
</li>
<li>调用 find_package_handle_standard_args() 宏来设置 <name>_FOUND 变量，并打印一条成功或者失败的消息</li>
</ul>
<a class="header" href="cmake/all-faq/10001.html#a性能和缓存" id="a性能和缓存"><h3>性能和缓存</h3></a>
<p>CMake 的变量系统要比初看起来的要复杂得多。有些变量做了缓存。做了缓存的变量有内部的（不能用 ccmake 编辑）和外部的（可以被 ccmake 修改）。另外，外部变量只能在 ccmake 的高级模式可见。</p>
<p>默认情况下，所有变量都是不缓存的。</p>
<p>为了避免每次执行时都重复检测全部的库，更为了允许用户在 ccmake 中设置 include 目录和库，需要支持缓存。幸运的是，这已经被 find_path 和 find_library 支持，它们可以缓存它们的变量。如果变量已经设置为有效值（比如不是 -NOTFOUND 或者未定义），这些函数将什么也不做，保持旧值。类似地， pkg_check_modules 支持结果的内部缓存，因此不需要每次都再调用 pkg-config。</p>
<p>另一方面，查找模块的输出值（ <name>_FOUND, <name>_INCLUDE_DIRS 和 <name>_LIBRARIES ）不应该被缓存，否则修改其他缓存的变量就不能改变输出，这显然是不期望的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="cmake/dynamic-lib-examples.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter_4.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="cmake/dynamic-lib-examples.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="chapter_4.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
