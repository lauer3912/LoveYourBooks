# 操作符

现在的Rust资料，无论是Book还是RustByExample都没有统一而完全的介绍Rust的操作符。一个很重要的原因就是，Rust的操作符号和C++大部分都是一模一样的。

1. [一元运算](#一元操作符)

## 一元操作符

顾名思义，一元操作符是专门对一个Rust元素进行操纵的操作符，主要包括以下几个:

* `-`: 取负，专门用于数值类型。
* `*`: 解引用。这是一个很有用的符号，和`Deref`（`DerefMut`）这个trait关联密切。
* `!`: 取反。取反操作相信大家都比较熟悉了，不多说了。有意思的是，当这个操作符对数字类型使用的时候，会将其每一位都置反！也就是说，你对一个`1u8`进行`!`的话你将会得到一个`254u8`。
* `&`和`&mut`: 租借，borrow。向一个owner租借其使用权，分别是租借一个只读使用权和读写使用权。

## 二元操作符

### 算数操作符

算数运算符都有对应的trait的，他们都在`std::ops`下：

* `+`: 加法。实现了`std::ops::Add`。
* `-`: 减法。实现了`std::ops::Sub`。
* `*`: 乘法。实现了`std::ops::Mul`。
* `/`: 除法。实现了`std::ops::Div`。
* `%`: 取余。实现了`std::ops::Rem`。

### 位运算符

和算数运算符差不多的是，位运算也有对应的trait。

* `&`: 与操作。实现了`std::ops::BitAnd`。
* `|`: 或操作。实现了`std::ops::BitOr`。
* `^`: 异或。实现了`std::ops::BitXor`。
* `<<`: 左移运算符。实现了`std::ops::Shl`。
* `>>`: 右移运算符。实现了`std::ops::Shr`。

### 惰性boolean运算符

逻辑运算符有三个，分别是`&&`、`||`、`!`。其中前两个叫做惰性boolean运算符，之所以叫这个名字。是因为在Rust里也会出现其他类C语言的逻辑短路问题。所以取了这么一个高大上然并卵的名字。
其作用和C语言里的一毛一样啊！哦，对了，有点不同的是Rust里这个运算符只能用在bool类型变量上。什么 `1 && 1` 之类的表达式给我死开。

### 比较运算符

比较运算符其实也是某些trait的语法糖啦，不同的是比较运算符所实现的trait只有两个`std::cmp::PartialEq`和`std::cmp::PartialOrd`

其中， `==`和`!=`实现的是`PartialEq`。
而，`<`、`>`、`>=`、`<=`实现的是`PartialOrd`。

边看本节边翻开标准库（好习惯，鼓励）的同学一定会惊奇的发现，不对啊，`std::cmp`这个mod下明明有四个trait，而且从肉眼上来看更符合逻辑的`Ord`和`Eq`岂不是更好？其实，Rust对于这四个trait的处理是很明确的。分歧主要存在于浮点类型。
熟悉IEEE的同学一定知道浮点数有一个特殊的值叫`NaN`，这个值表示未定义的一个浮点数。在Rust中可以用`0.0f32 / 0.0f32`来求得其值。那么问题来了，这个数他是一个确定的值，但是它表示的是一个不确定的数！那么 `NaN != NaN` 的结果是啥？标准告诉我们，是 `true` 。但是这么写又不符合`Eq`的定义里`total equal`(每一位一样两个数就一样)的定义。因此有了`PartialEq`这么一个定义，我们只支持部分相等好吧，NaN这个情况我就给它特指了。

为了普适的情况，Rust的编译器选择了`PartialOrd`和`PartialEq`来作为其默认的比较符号的trait。我们也就和中央保持一致就好。
