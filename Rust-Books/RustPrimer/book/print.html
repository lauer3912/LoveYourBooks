<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Programming Language Primer - Rust 编程语言入门</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        
        <link rel="stylesheet" href="theme/edition.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="1st-glance/index.html"><strong aria-hidden="true">1.</strong> 初识Rust</a></li><li><a href="install/preface.html"><strong aria-hidden="true">2.</strong> 安装Rust</a></li><li><ol class="section"><li><a href="install/install_rust_on_linux.html"><strong aria-hidden="true">2.1.</strong> Linux</a></li><li><a href="install/install_rust_on_mac_os.html"><strong aria-hidden="true">2.2.</strong> Mac</a></li><li><a href="install/install_rust_on_windows.html"><strong aria-hidden="true">2.3.</strong> Windows</a></li><li><a href="install/use_mirrors_quickly.html"><strong aria-hidden="true">2.4.</strong> 利用科大镜像源提速</a></li><li><a href="install/rustup.html"><strong aria-hidden="true">2.5.</strong> 版本管理工具: rustup</a></li></ol></li><li><a href="editors/preface.html"><strong aria-hidden="true">3.</strong> 编辑器</a></li><li><ol class="section"><li><a href="editors/before.html"><strong aria-hidden="true">3.1.</strong> 前期准备</a></li><li><a href="editors/vim.html"><strong aria-hidden="true">3.2.</strong> Vim</a></li><li><a href="editors/emacs.html"><strong aria-hidden="true">3.3.</strong> Emacs</a></li><li><a href="editors/vscode.html"><strong aria-hidden="true">3.4.</strong> VS Code</a></li><li><a href="editors/atom.html"><strong aria-hidden="true">3.5.</strong> Atom</a></li><li><a href="editors/sublime.html"><strong aria-hidden="true">3.6.</strong> Sublime Text</a></li><li><a href="editors/visualstudio.html"><strong aria-hidden="true">3.7.</strong> Visual Studio</a></li><li><a href="editors/intellij-idea.html"><strong aria-hidden="true">3.8.</strong> Intellij IDEA</a></li><li><a href="editors/spacemacs.html"><strong aria-hidden="true">3.9.</strong> Spacemacs</a></li></ol></li><li><a href="quickstart/quickstart.html"><strong aria-hidden="true">4.</strong> 快速入门</a></li><li><ol class="section"><li><a href="quickstart/rust-travel.html"><strong aria-hidden="true">4.1.</strong> Rust旅程</a></li><li><a href="quickstart/let.html"><strong aria-hidden="true">4.2.</strong> 变量绑定</a></li><li><a href="quickstart/data-types.html"><strong aria-hidden="true">4.3.</strong> 数据类型</a></li><li><a href="quickstart/vector-string.html"><strong aria-hidden="true">4.4.</strong> 数组、动态数组和字符串</a></li><li><a href="quickstart/struct-enum.html"><strong aria-hidden="true">4.5.</strong> 结构体与枚举</a></li><li><a href="quickstart/control-flow.html"><strong aria-hidden="true">4.6.</strong> 控制流</a></li><li><a href="quickstart/function-method.html"><strong aria-hidden="true">4.7.</strong> 函数与方法</a></li><li><a href="quickstart/trait.html"><strong aria-hidden="true">4.8.</strong> 特性</a></li><li><a href="quickstart/comments-document.html"><strong aria-hidden="true">4.9.</strong> 注释与文档</a></li><li><a href="quickstart/io-stream.html"><strong aria-hidden="true">4.10.</strong> 输入输出流</a></li></ol></li><li><a href="core/overview.html"><strong aria-hidden="true">5.</strong> 深入学习</a></li><li><ol class="section"><li><a href="core/cargo-projects-manager/cargo-projects-manager.html"><strong aria-hidden="true">5.1.</strong> Cargo 项目管理</a></li><li><ol class="section"><li><a href="core/cargo-detailed-cfg/cargo-detailed-cfg.html"><strong aria-hidden="true">5.1.1.</strong> 高级参数配置</a></li></ol></li><li><a href="core/cargo-io/overview.html"><strong aria-hidden="true">5.2.</strong> Cargo.io</a></li><li><a href="core/comments/overview.html"><strong aria-hidden="true">5.3.</strong> 注释</a></li><li><a href="core/keywords/overview.html"><strong aria-hidden="true">5.4.</strong> 关键字</a></li><li><a href="core/heap-stack/overview.html"><strong aria-hidden="true">5.5.</strong> 栈(Stack)与堆(Heap)</a></li><li><a href="core/type/preface.html"><strong aria-hidden="true">5.6.</strong> 数据类型</a></li><li><ol class="section"><li><a href="core/type/primitives-types.html"><strong aria-hidden="true">5.6.1.</strong> 内置类型&lt;原生&gt;</a></li><li><ol class="section"><li><a href="core/type/bool.html"><strong aria-hidden="true">5.6.1.1.</strong> 布尔类型 (boolean)</a></li><li><a href="core/type/char.html"><strong aria-hidden="true">5.6.1.2.</strong> 字符类型 (char)</a></li><li><a href="core/type/integer.html"><strong aria-hidden="true">5.6.1.3.</strong> 整型 (integer)</a></li><li><a href="core/type/float.html"><strong aria-hidden="true">5.6.1.4.</strong> 浮点型 (float)</a></li><li><a href="core/type/array.html"><strong aria-hidden="true">5.6.1.5.</strong> 数组类型 (array)</a></li><li><a href="core/type/tuple.html"><strong aria-hidden="true">5.6.1.6.</strong> 元组类型 (tuple)</a></li></ol></li><li><a href="core/type/compound-types.html"><strong aria-hidden="true">5.6.2.</strong> 复合类型&lt;自定义&gt;</a></li><li><ol class="section"><li><a href="core/enums/overview.html"><strong aria-hidden="true">5.6.2.1.</strong> 枚举 (Enums)</a></li><li><a href="core/structs/overview.html"><strong aria-hidden="true">5.6.2.2.</strong> 结构体 (Struct)</a></li></ol></li><li><a href="core/type/macro-kernel-types.html"><strong aria-hidden="true">5.6.3.</strong> 微内核类型</a></li><li><ol class="section"><li><a href="core/type/unit.html"><strong aria-hidden="true">5.6.3.1.</strong> ☆元类型 (unit)☆</a></li><li><a href="core/type/raw-point.html"><strong aria-hidden="true">5.6.3.2.</strong> 指针类型 (raw point)</a></li><li><a href="core/type/fn.html"><strong aria-hidden="true">5.6.3.3.</strong> 函数指针类型 (reference)</a></li><li><a href="core/type/ref.html"><strong aria-hidden="true">5.6.3.4.</strong> 引用类型 (reference)</a></li></ol></li></ol></li><li><a href="core/collections/overview.html"><strong aria-hidden="true">5.7.</strong> 常用集合类型</a></li><li><ol class="section"><li><a href="core/collections/vec.html"><strong aria-hidden="true">5.7.1.</strong> 向量 Vector</a></li><li><a href="core/collections/string.html"><strong aria-hidden="true">5.7.2.</strong> 字符串 String</a></li><li><a href="core/collections/hashmap.html"><strong aria-hidden="true">5.7.3.</strong> 哈希表 Hash Map</a></li></ol></li><li><a href="core/data-structure/preface.html"><strong aria-hidden="true">5.8.</strong> 常用数据结构实现</a></li><li><ol class="section"><li><a href="core/data-structure/stack.html"><strong aria-hidden="true">5.8.1.</strong> 栈结构</a></li><li><a href="core/data-structure/queue.html"><strong aria-hidden="true">5.8.2.</strong> 队列</a></li><li><a href="core/data-structure/binary_tree.html"><strong aria-hidden="true">5.8.3.</strong> 二叉树</a></li><li><a href="core/data-structure/priority_queue.html"><strong aria-hidden="true">5.8.4.</strong> 优先队列</a></li><li><a href="core/data-structure/linked_list.html"><strong aria-hidden="true">5.8.5.</strong> 链表</a></li><li><a href="core/data-structure/graph.html"><strong aria-hidden="true">5.8.6.</strong> 图结构</a></li></ol></li><li><a href="core/variable/overview.html"><strong aria-hidden="true">5.9.</strong> 变量</a></li><li><ol class="section"><li><a href="core/variable/what-is-variable.html"><strong aria-hidden="true">5.9.1.</strong> 变量声明</a></li><li><a href="core/variable/bindings.html"><strong aria-hidden="true">5.9.2.</strong> 变量绑定</a></li><li><a href="core/variable/mutability.html"><strong aria-hidden="true">5.9.3.</strong> 变量可变性</a></li><li><a href="core/variable/scope.html"><strong aria-hidden="true">5.9.4.</strong> 变量作用域</a></li><li><a href="core/ownership-system/preface.html"><strong aria-hidden="true">5.9.5.</strong> 可变性、所有权、租借和生命期</a></li><li><ol class="section"><li><a href="core/ownership-system/what-is-ownership.html"><strong aria-hidden="true">5.9.5.1.</strong> 什么是所有权？</a></li><li><a href="core/ownership-system/example-ownership.html"><strong aria-hidden="true">5.9.5.2.</strong> 所有权练习</a></li><li><a href="core/ownership-system/borrowing_reference.html"><strong aria-hidden="true">5.9.5.3.</strong> 引用和借用</a></li><li><a href="core/ownership-system/lifetime.html"><strong aria-hidden="true">5.9.5.4.</strong> 生命周期</a></li></ol></li></ol></li><li><a href="core/constants/overview.html"><strong aria-hidden="true">5.10.</strong> 常量</a></li><li><ol class="section"><li><a href="core/constants/const-value.html"><strong aria-hidden="true">5.10.1.</strong> 常量值</a></li><li><a href="core/constants/const-function.html"><strong aria-hidden="true">5.10.2.</strong> ☆常量函数☆</a></li></ol></li><li><a href="core/operator/overview.html"><strong aria-hidden="true">5.11.</strong> 运算符</a></li><li><ol class="section"><li><a href="core/operator/base.html"><strong aria-hidden="true">5.11.1.</strong> 基础运算符</a></li><li><a href="core/operator/as.html"><strong aria-hidden="true">5.11.2.</strong> 类型转换 as 运算符</a></li><li><a href="core/operator/overloading/operator.html"><strong aria-hidden="true">5.11.3.</strong> ☆运算符重载☆</a></li></ol></li><li><a href="core/flow-control/overview.html"><strong aria-hidden="true">5.12.</strong> 流程控制</a></li><li><ol class="section"><li><a href="core/flow-control/condition/overview.html"><strong aria-hidden="true">5.12.1.</strong> 判断/条件</a></li><li><a href="core/flow-control/loop/overview.html"><strong aria-hidden="true">5.12.2.</strong> 循环</a></li></ol></li><li><a href="core/function/overview.html"><strong aria-hidden="true">5.13.</strong> 函数</a></li><li><ol class="section"><li><a href="core/function/arguement.html"><strong aria-hidden="true">5.13.1.</strong> 函数参数</a></li><li><a href="core/function/return_value.html"><strong aria-hidden="true">5.13.2.</strong> 函数返回值</a></li><li><a href="core/function/statement_expression.html"><strong aria-hidden="true">5.13.3.</strong> 语句和表达式</a></li><li><a href="core/function/higher_order_function.html"><strong aria-hidden="true">5.13.4.</strong> 高阶函数</a></li></ol></li><li><a href="core/closure/overview.html"><strong aria-hidden="true">5.14.</strong> 闭包</a></li><li><ol class="section"><li><a href="core/closure/syntax.html"><strong aria-hidden="true">5.14.1.</strong> 闭包的语法</a></li><li><a href="core/closure/implementation.html"><strong aria-hidden="true">5.14.2.</strong> 闭包的实现</a></li><li><a href="core/closure/as_argument_return_value.html"><strong aria-hidden="true">5.14.3.</strong> 闭包作为参数和返回值</a></li></ol></li><li><a href="core/match/overview.html"><strong aria-hidden="true">5.15.</strong> 模式匹配</a></li><li><ol class="section"><li><a href="core/match/match.html"><strong aria-hidden="true">5.15.1.</strong> match关键字</a></li><li><a href="core/match/pattern.html"><strong aria-hidden="true">5.15.2.</strong> 模式 pattern</a></li></ol></li><li><a href="core/iterator/overview.html"><strong aria-hidden="true">5.16.</strong> 迭代器</a></li><li><ol class="section"><li><a href="core/iterator/iterator.html"><strong aria-hidden="true">5.16.1.</strong> 迭代器、适配器、消费者</a></li></ol></li><li><a href="core/macro/macro.html"><strong aria-hidden="true">5.17.</strong> 宏 (macro)</a></li><li><a href="core/format/overview.html"><strong aria-hidden="true">5.18.</strong> 格式化</a></li><li><a href="core/oop/overview.html"><strong aria-hidden="true">5.19.</strong> 面向对象编程</a></li><li><ol class="section"><li><a href="core/oop/what-is-oo.html"><strong aria-hidden="true">5.19.1.</strong> Rust 面向对象语言特点</a></li><li><a href="core/oop/trait/overview.html"><strong aria-hidden="true">5.19.2.</strong> 特性/接口 (Trait)</a></li><li><ol class="section"><li><a href="core/oop/trait/trait.html"><strong aria-hidden="true">5.19.2.1.</strong> trait关键字</a></li><li><a href="core/oop/trait/trait-object.html"><strong aria-hidden="true">5.19.2.2.</strong> trait对象</a></li></ol></li><li><a href="core/oop/oo-design-patterns.html"><strong aria-hidden="true">5.19.3.</strong> 设计模式</a></li></ol></li><li><a href="core/generic-program/generic.html"><strong aria-hidden="true">5.20.</strong> 泛型编程</a></li><li><ol class="section"><li><a href="core/generic-program/what-is-generic.html"><strong aria-hidden="true">5.20.1.</strong> 什么是泛型?</a></li><li><a href="core/generic-program/generic-function.html"><strong aria-hidden="true">5.20.2.</strong> 泛型函数</a></li><li><a href="core/generic-program/generic-data-struct.html"><strong aria-hidden="true">5.20.3.</strong> 泛型数据结构</a></li></ol></li><li><a href="core/module/preface.html"><strong aria-hidden="true">5.21.</strong> 模块和包系统、Prelude</a></li><li><ol class="section"><li><a href="core/module/module.html"><strong aria-hidden="true">5.21.1.</strong> 模块 module 和包 crate</a></li><li><a href="core/module/prelude.html"><strong aria-hidden="true">5.21.2.</strong> Prelude</a></li><li><a href="core/module/pub-restricted.html"><strong aria-hidden="true">5.21.3.</strong> pub restricted</a></li></ol></li><li><a href="core/error-handling/option-result.html"><strong aria-hidden="true">5.22.</strong> 错误处理 Error Handling</a></li><li><ol class="section"><li><a href="core/error-handling/option.html"><strong aria-hidden="true">5.22.1.</strong> Option 类型</a></li><li><a href="core/error-handling/result.html"><strong aria-hidden="true">5.22.2.</strong> Result 类型</a></li></ol></li><li><a href="core/io/preface.html"><strong aria-hidden="true">5.23.</strong> 输入与输出</a></li><li><ol class="section"><li><a href="core/io/io.html"><strong aria-hidden="true">5.23.1.</strong> 标准输入输出</a></li><li><a href="core/io/output.html"><strong aria-hidden="true">5.23.2.</strong> print! 宏</a></li><li><a href="core/io/file-io.html"><strong aria-hidden="true">5.23.3.</strong> 文件输入输出</a></li></ol></li><li><a href="core/heap-stack/heap-stack.html"><strong aria-hidden="true">5.24.</strong> Rust 堆、栈与Box</a></li><li><a href="core/smart-pointers/preface.html"><strong aria-hidden="true">5.25.</strong> 智能指针</a></li><li><ol class="section"><li><a href="core/smart-pointers/rcarc.html"><strong aria-hidden="true">5.25.1.</strong> Rc, Arc</a></li><li><a href="core/smart-pointers/mutex.html"><strong aria-hidden="true">5.25.2.</strong> Mutex, RwLock</a></li><li><a href="core/smart-pointers/cell.html"><strong aria-hidden="true">5.25.3.</strong> Cell, RefCell</a></li></ol></li><li><a href="core/intoborrow/preface.html"><strong aria-hidden="true">5.26.</strong> 类型系统中的几个常见 Trait</a></li><li><ol class="section"><li><a href="core/intoborrow/into.html"><strong aria-hidden="true">5.26.1.</strong> Into/From 及其在 String 和 &amp;str 互转上的应用</a></li><li><a href="core/intoborrow/asref.html"><strong aria-hidden="true">5.26.2.</strong> AsRef, AsMut</a></li><li><a href="core/intoborrow/borrow.html"><strong aria-hidden="true">5.26.3.</strong> Borrow, BorrowMut, ToOwned</a></li><li><a href="core/intoborrow/deref.html"><strong aria-hidden="true">5.26.4.</strong> Deref 与 Deref coercions</a></li><li><a href="core/intoborrow/cow.html"><strong aria-hidden="true">5.26.5.</strong> Cow 及其在 String 和 &amp;str 上的应用</a></li></ol></li><li><a href="core/marker/sendsync.html"><strong aria-hidden="true">5.27.</strong> Send 和 Sync</a></li><li><a href="core/concurrency-parallel-thread/preface.html"><strong aria-hidden="true">5.28.</strong> 并发编程</a></li><li><ol class="section"><li><a href="core/concurrency-parallel-thread/thread.html"><strong aria-hidden="true">5.28.1.</strong> 线程</a></li><li><a href="core/concurrency-parallel-thread/message-passing.html"><strong aria-hidden="true">5.28.2.</strong> 消息传递</a></li><li><a href="core/concurrency-parallel-thread/share-memory.html"><strong aria-hidden="true">5.28.3.</strong> 共享内存</a></li><li><a href="core/concurrency-parallel-thread/synchronize.html"><strong aria-hidden="true">5.28.4.</strong> 同步</a></li><li><a href="core/concurrency-parallel-thread/parallel.html"><strong aria-hidden="true">5.28.5.</strong> 并行</a></li></ol></li><li><a href="core/unsafe-rawpointer/preface.html"><strong aria-hidden="true">5.29.</strong> Unsafe、原始指针</a></li><li><ol class="section"><li><a href="core/unsafe-rawpointer/unsafe.html"><strong aria-hidden="true">5.29.1.</strong> Unsafe</a></li><li><a href="core/unsafe-rawpointer/raw-pointer.html"><strong aria-hidden="true">5.29.2.</strong> 原始指针</a></li></ol></li><li><a href="core/ffi/preface.html"><strong aria-hidden="true">5.30.</strong> FFI</a></li><li><ol class="section"><li><a href="core/ffi/calling-ffi-function.html"><strong aria-hidden="true">5.30.1.</strong> rust调用ffi函数</a></li><li><a href="core/ffi/compiling-rust-to-lib.html"><strong aria-hidden="true">5.30.2.</strong> 将rust编译成库</a></li></ol></li><li><a href="core/attr-and-compiler-arg/preface.html"><strong aria-hidden="true">5.31.</strong> 属性和编译器参数</a></li><li><ol class="section"><li><a href="core/attr-and-compiler-arg/attribute.html"><strong aria-hidden="true">5.31.1.</strong> 属性</a></li><li><a href="core/attr-and-compiler-arg/rustc-option.html"><strong aria-hidden="true">5.31.2.</strong> 编译器参数</a></li></ol></li><li><a href="core/testing/preface.html"><strong aria-hidden="true">5.32.</strong> 测试与评测</a></li><li><ol class="section"><li><a href="core/testing/threearchtest.html"><strong aria-hidden="true">5.32.1.</strong> 测试 (testing)</a></li><li><a href="core/testing/bench.html"><strong aria-hidden="true">5.32.2.</strong> 评测 (benchmark)</a></li></ol></li><li><a href="core/coding-style/style.html"><strong aria-hidden="true">5.33.</strong> 代码风格</a></li><li><a href="core/any/any.html"><strong aria-hidden="true">5.34.</strong> Any与反射</a></li><li><a href="core/safe/safety.html"><strong aria-hidden="true">5.35.</strong> 安全</a></li><li><a href="core/std/overview.html"><strong aria-hidden="true">5.36.</strong> 标准库介绍</a></li><li><ol class="section"><li><a href="core/std/process.html"><strong aria-hidden="true">5.36.1.</strong> 系统命令:调用grep</a></li><li><a href="core/std/fs-and-path.html"><strong aria-hidden="true">5.36.2.</strong> 目录操作:简单grep</a></li><li><a href="core/std/net.html"><strong aria-hidden="true">5.36.3.</strong> 网络模块:W回音</a></li></ol></li><li><a href="core/action/preface.html"><strong aria-hidden="true">5.37.</strong> 实战篇</a></li><li><ol class="section"><li><a href="core/action/json_data/index.html"><strong aria-hidden="true">5.37.1.</strong> 实战：Json处理</a></li><li><a href="core/action/mysite/index.html"><strong aria-hidden="true">5.37.2.</strong> 实战：Web 应用开发入门</a></li><li><a href="core/action/db/index.html"><strong aria-hidden="true">5.37.3.</strong> 实战：使用Postgresql数据库</a></li></ol></li><li><a href="core/appendix/glossary.html"><strong aria-hidden="true">5.38.</strong> 附录-术语表</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Programming Language Primer - Rust 编程语言入门</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#rust-编程语言简介" id="rust-编程语言简介"><h1>Rust 编程语言简介</h1></a>
<p><strong>Rust</strong> 是一门系统级编程语言，被设计为保证内存和线程安全，并防止段错误。作为系统级编程语言，它的基本理念是 “零开销抽象”。</p>
<p>理论上来说，它的速度与 C/C++ 同级。</p>
<p>Rust 可以被归为通用的、多范式、编译型的编程语言，类似 C 或者 C++。与这两门编程语言不同的是，Rust 是线程安全的！</p>
<p>Rust 编程语言的目标是，创建一个高度安全和并发的软件系统。它强调安全性、并发和内存控制。尽管 Rust 借用了 C 和 C++ 的语法，它不允许空指针和悬挂指针，二者是 C 和 C++ 中系统崩溃、内存泄露和不安全代码的根源。</p>
<p>Rust 中有诸如 if else 和循环语句 for 和 while 的通用控制结构。和 C 和 C++ 风格的编程语言一样，代码段放在花括号中。</p>
<p>Rust 使用实现（implementation）、特征（trait）和结构化类型（structured type）而不是类（class）。这点，与基于继承的OO语言 C++, Java 有相当大的差异。而跟 Ocaml, Haskell 这类函数式语言更加接近。</p>
<p>Rust 做到了内存安全而无需 .NET 和 Java 编程语言中实现自动垃圾收集器的开销，这是通过所有权/借用机制、生命周期、以及类型系统来达到的。</p>
<p>下面是一个代码片段的例子，经典的 Hello World 应用：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  println!(&quot;hello, world&quot;);
}
</code></pre></pre>
<p>影响了 Rust 的流行的编程语言包括 C, C++, C#, Erlang, Haskell, OCaml, Ruby, Scheme 和 Swift 等等。Rust 也影响了 C# 7, Elm, Idris, Swift。</p>
<p>Rust 主要应用的领域包括4个方面：</p>
<ul>
<li>WebAssembly： 让像Rust等编程语言运行在Web浏览器上</li>
<li>Embedded applications：嵌入式应用程序，一般为嵌入式设备提供应用程序</li>
<li>Networking：网络编程，当然包括云计算。</li>
<li>Command line tools：命令行工具</li>
</ul>
<p>Rust 提供了安装程序，你只需要从官网下载并在相应的操作系统上运行安装程序。安装程序支持 Windows、Mac 和 Linux（通过脚本）上的32位和64位 CPU 体系架构，适用 Apache License 2.0 或者 MIT Licenses。</p>
<p>Rust 运行在以下操作系统上：Linux, OS X, Windows, FreeBSD, Android, iOS, ... 非常多的系统上。</p>
<p>简单提一下 Rust 的历史。</p>
<p>Rust 最早是 Mozilla 雇员 Graydon Hoare 的一个个人项目，从 2009 年开始，得到了 Mozilla 研究院的支助，2010 年项目对外公布。2010 ～2011 年间实现的自举。从此以后，Rust 经历了巨大的设计变化和反复（历程极其艰辛），终于在 2015 年 5 月 15日发布了 1.0 版(也称为：2015 edition 或者 Rust 2015)。在这个研发过程中，Rust 建立了一个强大活跃的社区，形成了一整套完善稳定的项目贡献机制（这是真正的可怕之处）。</p>
<p>Rust 现在由 Rust 项目开发者社区（https://github.com/rust-lang/rust ）维护。</p>
<p>自 15 年 5 月 1.0 发布以来，涌现了大量优秀的项目（可以 github 上搜索 Rust 查找），大公司也逐渐积极参与 Rust 的应用开发，以及回馈开源社区。</p>
<p>2018年12月6日，1.31 版本发布， 称为 Rust2018 （2018 edition）</p>
<a class="header" href="print.html#a安装rust" id="a安装rust"><h1>安装Rust</h1></a>
<p>本章讲解在三大平台 Linux, MacOS, Windows 上分别安装 Rust 的步骤。</p>
<a class="header" href="print.html#rust-for-linux" id="rust-for-linux"><h1>Rust for Linux</h1></a>
<p>Rust 支持主流的操作系统，Linux,Mac和 windows。</p>
<p>Rust 为Linux用户提供了两种安装方式：</p>
<a class="header" href="print.html#a1直接下载安装包" id="a1直接下载安装包"><h3>1、直接下载安装包：</h3></a>
<p>直接下载安装包的话需要检查一下你当前操作系统是64位还是32位，分别下载对应的安装包。</p>
<p>查看操作系统请在终端执行如下命令:</p>
<p><code>uname -a</code></p>
<p>结果如下图所示：</p>
<p><img src="../images/install-on-linux-check-system.png" alt="check system info" /></p>
<p>如上图所示，如果是 <strong>x86_64</strong> 则证明是64位系统，需要<a href="https://static.rust-lang.org/dist/rust-1.5.0-x86_64-unknown-linux-gnu.tar.gz">下载</a>64位安装包；</p>
<p>如果是<strong>x86-32</strong>则需要<a href="https://static.rust-lang.org/dist/rust-1.5.0-i686-unknown-linux-gnu.tar.gz">下载</a>32位安装包</p>
<p>下载安装包后解压运行即可。<em>在书写本章时，最新的稳定版本为1.5.0，</em>
解压：<code>tar -zxvf rust-1.5.0-x86_64-unknown-linux-gnu.tar.gz</code></p>
<p>解压完进入对应的目录：<code>cd rust-1.5.0-x86_64-unknown-linux-gnu</code>
执行 <code>./install.sh</code></p>
<p>上述命令执行完成后会打印： <strong>Rust is ready to roll.</strong> 表明安装成功</p>
<p>此时执行: <code>rustc --version</code>, 你会看到对应的 rust 版本信息,如下图所示：</p>
<p><img src="../images/install-on-linux-rust-success.png" alt="Success and show rust version info" /></p>
<a class="header" href="print.html#a2命令行一键安装" id="a2命令行一键安装"><h3>2、命令行一键安装：</h3></a>
<p>Rust 提供简单的一键安装，命令如下：</p>
<p><code>curl -sSf https://static.rust-lang.org/rustup.sh | sh</code></p>
<p>打开终端执行如上命令即可。</p>
<p><strong>注意</strong></p>
<p>除了稳定版之外，Rust 还提供了 Beta 和 Nightly 版本，下载地址如下：
https://www.rust-lang.org/zh-CN/other-installers.html</p>
<p>如果你不想安装 Rust 在你的电脑上，但是你还是像尝试一下 rust，那么这里有一个在线的环境：http://play.rust-lang.org/</p>
<p>中国科学技术大学镜像源包含 <a href="http://mirrors.ustc.edu.cn/rust-static/">rust-static</a>，梯子暂时出问题的同学可以尝试从这里下载编译器；除此之外。还有 Crates 源，详见<a href="https://servers.ustclug.org/2016/01/mirrors-add-rust-crates/">这里的说明</a>。</p>
<a class="header" href="print.html#rust-for-mac-os" id="rust-for-mac-os"><h1>Rust for Mac OS</h1></a>
<p>Rust 支持主流的操作系统，Linux，Mac 和 windows。</p>
<p>Rust 为 mac 用户提供了两种安装方式：</p>
<a class="header" href="print.html#a1直接下载安装包-1" id="a1直接下载安装包-1"><h3>1、直接下载安装包：</h3></a>
<p>直接下载安装包的话需要检查一下你当前操作系统是64位还是32位，分别下载对应的安装包。
查看操作系统请在终端执行如下命令:</p>
<p><code>uname -a</code></p>
<p><img src="../images/get-mac-os-information.png" alt="Mac-os-inofrmatoin" /></p>
<p>如上图红色部分所示，如果是 <strong>x86_64</strong> 则证明是64位系统，需要<a href="https://static.rust-lang.org/dist/rust-1.5.0-x86_64-apple-darwin.pkg">下载</a>64位安装包；
如果是<strong>x86-32</strong>则需要<a href="https://static.rust-lang.org/dist/rust-1.5.0-i686-apple-darwin.pkg">下载</a>32位安装包</p>
<p>和安装普通的软件一样，直接运行安装包即可。</p>
<p><em>在书写本章时，最新的稳定版本为1.5.0，</em></p>
<a class="header" href="print.html#a2命令行一键安装-1" id="a2命令行一键安装-1"><h3>2、命令行一键安装：</h3></a>
<p>Rust 提供简单的一键安装，命令如下：</p>
<p><code>curl -sSf https://static.rust-lang.org/rustup.sh | sh</code></p>
<p><em>此过程，有可能需要你输入几次密码</em></p>
<p>你只需打开你的命令行执行如上代码就可以了。（注意，你可能需要一个梯子，否则会遇到一些类似<em>Could not resolve host: static.rust-lang.org</em>的错误）</p>
<a class="header" href="print.html#a3验证安装" id="a3验证安装"><h3>3.验证安装：</h3></a>
<p>如果你完成了上面任意一个步骤，请执行如下命令：</p>
<p><code>rustc --version</code></p>
<p>如果看到如下信息，表明你安装成功：</p>
<p><code>rustc 1.5.0 (3d7cd77e4 2015-12-04)</code></p>
<p>如果提示没有 <em>rustc</em> 命令，那么请回顾你是否有某个地方操作不对，请回过头来再看一遍文档。</p>
<p><strong>注意</strong></p>
<p>除了稳定版之外，Rust 还提供了 Beta 和 Nightly 版本，下载地址如下：
https://www.rust-lang.org/zh-CN/other-installers.html</p>
<p>如果你不想安装 Rust 在你的电脑上，但是你还是像尝试一下 rust，那么这里有一个在线的环境：http://play.rust-lang.org/</p>
<p>中国科学技术大学镜像源包含 <a href="http://mirrors.ustc.edu.cn/rust-static/">rust-static</a>，梯子暂时出问题的同学可以尝试从这里下载编译器；除此之外，还有 Crates 源，详见<a href="https://servers.ustclug.org/2016/01/mirrors-add-rust-crates/">这里的说明</a>。</p>
<a class="header" href="print.html#rust-for-windows" id="rust-for-windows"><h1>Rust for Windows</h1></a>
<p>Rust 支持主流的操作系统，Linux,Mac和 Windows。</p>
<p>Rust在Windows上的安装和你在windows上安装其它软件一样。</p>
<a class="header" href="print.html#a1下载安装包" id="a1下载安装包"><h3>1、下载安装包：</h3></a>
<p><a href="https://www.rust-lang.org/zh-CN/other-installers.html">下载地址</a></p>
<p>Rust提供了多个版本和多个平台的安装包，下载对应的即可，此处我们以<a href="https://static.rust-lang.org/dist/rust-1.6.0-x86_64-pc-windows-gnu.msi">1.6.0</a>的稳定版为例。</p>
<a class="header" href="print.html#a2安装" id="a2安装"><h3>2、安装：</h3></a>
<p>双击下载到的安装包，如下图所示：</p>
<p><img src="../images/install-on-windows-1st.png" alt="Mac-os-inofrmatoin" /></p>
<p>默认，rust将安装到所有用户下，选择“Advanced”，可以指定安装用户和安装路径。然后点击&quot;install&quot;等待几分钟即可（中间可能会有安全提示，点击允许即可，如果你装了360之类的，需要小心360阻止写入注册表）。</p>
<a class="header" href="print.html#a3验证安装-1" id="a3验证安装-1"><h3>3.验证安装：</h3></a>
<p>安装完成后，运行windows命令行，然后输入:</p>
<p><code>rustc --version</code></p>
<p>看到 以 <strong>rustc 1.6.0</strong> 开头，说明你安装成功了。</p>
<p><strong><em>注意</em></strong></p>
<p>中国科学技术大学镜像源包含 <a href="http://mirrors.ustc.edu.cn/rust-static/">rust-static</a>，梯子暂时出问题的同学可以尝试从这里下载编译器；
除此之外。还有 Crates 源，详见<a href="https://servers.ustclug.org/2016/01/mirrors-add-rust-crates/">这里的说明</a>。</p>
<ol>
<li><a href="./use_mirrors_quickly.md">在Mac上，如何利用科大镜像源为Cargo及Rust提速?</a></li>
</ol>
<a class="header" href="print.html#a利用科大镜像源提速" id="a利用科大镜像源提速"><h1>利用科大镜像源提速</h1></a>
<p>Rust感觉是被墙损伤最大的一门开发语言，中科大源支持Rust，实在是美的很！ 废话不多说,直接上教程！</p>
<a class="header" href="print.html#a配置rustup" id="a配置rustup"><h2>配置<code>rustup</code></h2></a>
<pre><code class="language-shell">vi ~/.bashrc
</code></pre>
<p>然后加入：<code>RUSTUP_DIST_SERVER</code> 与 <code>RUSTUP_UPDATE_ROOT</code> 这两个环境变量</p>
<pre><code class="language-shell">export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup
</code></pre>
<p>接下来，使其环境变量生效!</p>
<pre><code class="language-shell">source ~/.bashrc
</code></pre>
<p>然后，你可以直接使用 <code>curl</code> 来下载你想要的版本. { nightly 日构建版本； stable 稳定发布版 本 }</p>
<pre><code class="language-shell">curl -sSf https://mirrors.ustc.edu.cn/rust-static/rustup.sh | sh -s -- --channel=nightly
</code></pre>
<p>当然，也可以直接访问 <code>https://mirrors.ustc.edu.cn/rust-static</code> 下载安装镜像。以上这么做，是为了以后执行有关 Rust 升级或者添加组件的时候，都从镜像源站点下载。</p>
<a class="header" href="print.html#a配置cargo" id="a配置cargo"><h1>配置<code>cargo</code></h1></a>
<p>检查一下，<code>~/.cargo/</code> 是否存在？ 如果不存在，创建目录并新建一个<code>config</code>文件</p>
<pre><code class="language-shell">mkdir -R ~/.cargo/ &amp;&amp; cd ~/.cargo/ &amp;&amp; touch config
</code></pre>
<p>然后 <code>vi config</code>, 在里面填入以下内容：</p>
<pre><code class="language-toml">
[registry]
index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;

[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;
replace-with = 'ustc'

[source.ustc]
registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;

</code></pre>
<p>这样，以后使用 <code>cargo install</code> 命令安装其他包装就非常方便了。</p>
<a class="header" href="print.html#rust-版本管理工具-rustup" id="rust-版本管理工具-rustup"><h1>Rust 版本管理工具: rustup</h1></a>
<p>rustup 是rust官方的版本管理工具。应当作为安装 Rust 的首选。</p>
<p>项目主页是: <a href="https://github.com/rust-lang-nursery/rustup.rs">https://github.com/rust-lang-nursery/rustup.rs</a></p>
<a class="header" href="print.html#features" id="features"><h2>Features</h2></a>
<ul>
<li>管理安装多个官方版本的 Rust 二进制程序。</li>
<li>配置基于目录的 Rust 工具链。</li>
<li>安装和更新来自 Rust 的发布通道: nightly, beta 和 stable。</li>
<li>接收来自发布通道更新的通知。</li>
<li>从官方安装历史版本的 nightly 工具链。</li>
<li>通过指定 stable 版本来安装。</li>
<li>安装额外的 std 用于交叉编译。</li>
<li>安装自定义的工具链。</li>
<li>独立每个安装的 Cargo metadata。</li>
<li>校验下载的 hash 值。</li>
<li>校验签名 (如果 GPG 存在)。</li>
<li>断点续传。</li>
<li>只依赖 bash, curl 和常见 unix 工具。</li>
<li>支持 Linux, OS X, Windows(via MSYS2)。</li>
</ul>
<a class="header" href="print.html#a安装" id="a安装"><h2>安装</h2></a>
<a class="header" href="print.html#windows" id="windows"><h3>Windows</h3></a>
<p>在<a href="http://www.rustup.rs">rustup的主页</a>下载并运行<a href="https://win.rustup.rs/">rustup-init.exe</a>,并按照提示选择选项。</p>
<pre><code>Welcome to Rust!

This will download and install the official compiler for the Rust programming
language, and its package manager, Cargo.

It will add the cargo, rustc, rustup and other commands to Cargo's bin
directory, located at:

  C:\Users\Liqueur Librazy\.cargo\bin

This path will then be added to your PATH environment variable by modifying the
HKEY_CURRENT_USER/Environment/PATH registry key.

You can uninstall at any time with rustup self uninstall and these changes will
be reverted.

Current installation options:

   default host triple: x86_64-pc-windows-msvc
     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
</code></pre>
<p>三个选项分别是</p>
<ol>
<li>开始安装（默认选项）</li>
<li>自定义安装</li>
<li>取消</li>
</ol>
<p>其中自定义安装可以更改默认架构与工具链、是否添加 PATH。例如想要选择 nightly 工具链可以进行以下自定义</p>
<pre><code>I'm going to ask you the value of each these installation options.
You may simply press the Enter key to leave unchanged.

Default host triple?


Default toolchain? (stable/beta/nightly)
nightly

Modify PATH variable? (y/n)

</code></pre>
<p>设置完毕后，选择 1 以开始安装。</p>
<a class="header" href="print.html#linux--macos" id="linux--macos"><h3>Linux &amp; macOS</h3></a>
<p>运行以下命令</p>
<pre><code>curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>这个命令将会编译和安装 rustup, 安装过程中可能会提示你输入 sudo 的密码。 然后, 他会下载和安装 stable 版本的工具链, 当执行 rustc, rustdoc 和 cargo 时, 将会配置他为默认工具链。</p>
<p><code>Unix</code> 上安装后工具链会被安装到 <code>$HOME/.cargo/bin</code> 目录。</p>
<p><code>.cargo/bin</code> 目录会被添加到系统的 <code>$PATH</code> 环境变量,重新登录后即可使用 <code>rustc</code>，<code>cargo</code> 等命令。</p>
<a class="header" href="print.html#a卸载" id="a卸载"><h2>卸载</h2></a>
<pre><code>rustup self uninstall
</code></pre>
<a class="header" href="print.html#a用法" id="a用法"><h2>用法</h2></a>
<p>安装后会得到一个 rustup 命令, 多使用命令自带的帮助提示, 可以快速定位你需要功能。</p>
<a class="header" href="print.html#a帮助" id="a帮助"><h3>帮助</h3></a>
<p>运行 <code>rustup -h</code> 你将会得到如下提示:</p>
<pre><code>❯ rustup -h
rustup 1.5.0 (92d0d1e9e 2017-06-24)
The Rust toolchain installer

USAGE:
    rustup.exe [FLAGS] [SUBCOMMAND]

FLAGS:
    -v, --verbose    Enable verbose output
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    show           Show the active and installed toolchains
    update         Update Rust toolchains and rustup
    default        Set the default toolchain
    toolchain      Modify or query the installed toolchains
    target         Modify a toolchain's supported targets
    component      Modify a toolchain's installed components
    override       Modify directory toolchain overrides
    run            Run a command with an environment configured for a given toolchain
    which          Display which binary will be run for a given command
    doc            Open the documentation for the current toolchain
    self           Modify the rustup installation
    set            Alter rustup settings
    completions    Generate completion scripts for your shell
    help           Prints this message or the help of the given subcommand(s)

DISCUSSION:
    rustup installs The Rust Programming Language from the official
    release channels, enabling you to easily switch between stable,
    beta, and nightly compilers and keep them updated. It makes
    cross-compiling simpler with binary builds of the standard library
    for common platforms.

    If you are new to Rust consider running `rustup doc --book` to
    learn Rust.

</code></pre>
<p>根据提示, 使用 <code>rust help &lt;command&gt;</code> 来查看子命令的帮助。</p>
<p><code>rustup doc --book</code> 会打开英文版的 <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>。</p>
<a class="header" href="print.html#a常用命令" id="a常用命令"><h3>常用命令</h3></a>
<p><code>rustup default &lt;toolchain&gt;</code> 配置默认工具链。</p>
<p><code>rustup show</code> 显示当前安装的工具链信息。</p>
<p><code>rustup update</code> 检查安装更新。</p>
<p><code>rustup toolchain [SUBCOMMAND]</code> 配置工具链</p>
<blockquote>
<ul>
<li><code>rustup toolchain install &lt;toolchain&gt;</code> 安装工具链。</li>
<li><code>rustup toolchain uninstall &lt;toolchain&gt;</code> 卸载工具链。</li>
<li><code>rustup toolchain link &lt;toolchain-name&gt; &quot;&lt;toolchain-path&gt;&quot;</code> 设置<a href="https://github.com/rust-lang-nursery/rustup.rs#working-with-custom-toolchains-and-local-builds">自定义工具链</a>。</li>
</ul>
<p>其中标准的 <code>&lt;toolchain&gt;</code>具有如下的形式</p>
<pre><code>`&lt;channel&gt;[-&lt;date&gt;][-&lt;host&gt;]`
&lt;channel&gt;       = stable|beta|nightly|&lt;version&gt;
&lt;date&gt;          = YYYY-MM-DD
&lt;host&gt;          = &lt;target-triple&gt;
</code></pre>
<p>如 <code>stable-x86_64-pc-windows-msvc</code> <code>nightly-2017-7-25</code> <code>1.18.0</code> 等都是合法的toolchain名称。</p>
</blockquote>
<p><code>rustup override [SUBCOMMAND]</code> 配置一个目录以及其子目录的默认工具链</p>
<blockquote>
<p>使用 <code>--path &lt;path&gt;</code> 指定目录或在某个目录下运行以下命令</p>
<ul>
<li><code>rustup override set &lt;toolchain&gt;</code> 设置该目录以及其子目录的默认工具链。</li>
<li><code>rustup override unset</code> 取消目录以及其子目录的默认工具链。</li>
</ul>
<p>使用 <code>rustup override list</code> 查看已设置的默认工具链。</p>
</blockquote>
<p><code>rustup target [SUBCOMMAND]</code> 配置工具链的可用目标</p>
<blockquote>
<ul>
<li><code>rustup target add &lt;target&gt;</code> 安装目标。</li>
<li><code>rustup target remove &lt;target&gt;</code> 卸载目标。</li>
<li><code>rustup target add --toolchain &lt;toolchain&gt; &lt;target&gt;</code> 为特定工具链安装目标。</li>
</ul>
</blockquote>
<p><code>rustup component</code> 配置 rustup 安装的组件</p>
<blockquote>
<ul>
<li><code>rustup component add &lt;component&gt;</code> 安装组件</li>
<li><code>rustup component remove &lt;component&gt;</code> 卸载组件</li>
<li><code>rustup component list</code> 列出可用组件</li>
</ul>
<p>常用组件：</p>
<ul>
<li>Rust 源代码 <code>rustup component add rust-src</code></li>
<li>Rust Langular Server (RLS) <code>rustup component add rls</code></li>
</ul>
</blockquote>
<a class="header" href="print.html#a编辑器" id="a编辑器"><h1>编辑器</h1></a>
<p>本章描述几种常用编辑器针对 Rust 开发环境的配置。</p>
<a class="header" href="print.html#a前期准备" id="a前期准备"><h1>前期准备</h1></a>
<a class="header" href="print.html#a下载-rust-源代码供-racer-使用" id="a下载-rust-源代码供-racer-使用"><h2>下载 Rust 源代码（供 racer 使用）</h2></a>
<a class="header" href="print.html#a从github下载" id="a从github下载"><h3>从github下载</h3></a>
<p><code>git clone https://github.com/rust-lang/rust.git</code></p>
<a class="header" href="print.html#a从官网下载源代码包" id="a从官网下载源代码包"><h3>从官网下载源代码包</h3></a>
<p>下载地址： <code>https://static.rust-lang.org/dist/rustc-nightly-src.tar.gz</code></p>
<a class="header" href="print.html#a使用rustup下载推荐" id="a使用rustup下载推荐"><h3>使用rustup下载（推荐）</h3></a>
<p>使用rustup获取源码最大的好处在于可以使用<code>rustup update</code>随时获取最新版源码，执行以下命令获取源码</p>
<pre><code class="language-bash">rustup component add rust-src
</code></pre>
<a class="header" href="print.html#racer" id="racer"><h2>racer</h2></a>
<p>racer是一个由rust的爱好者提供的rust自动补全和语法分析工具，被用来提供基本的补全功能和定义跳转功能。其本身完全由rust写成，补全功能已经比较完善了。</p>
<p>我们可以通过如下的方式获取它：</p>
<a class="header" href="print.html#cargo自动安装" id="cargo自动安装"><h3>cargo自动安装</h3></a>
<p>在rust 1.5版本以后，其安装包自带的cargo工具已经支持了cargo install命令，这个命令可以帮助我们通过简单的方式获取到<code>racer</code>的最新版。</p>
<p>你可以通过以下命令安装<code>racer</code>最新版，目前已知在Linux、Unix和Windows上适用</p>
<pre><code class="language-bash">cargo install racer
</code></pre>
<a class="header" href="print.html#a编译安装" id="a编译安装"><h3>编译安装</h3></a>
<p>事实上我更推荐有条件的用户通过这种方式安装，因为自己实战操作一遍总是有些收获的。~~(帅气可爱的DCjanus表示怀疑)~~</p>
<a class="header" href="print.html#a下载源码" id="a下载源码"><h4>下载源码</h4></a>
<p>首先，我们需要下载racer的源码</p>
<pre><code class="language-bash">git clone https://github.com/phildawes/racer.git
</code></pre>
<a class="header" href="print.html#a进行编译" id="a进行编译"><h4>进行编译</h4></a>
<p>然后，进入目录然后进行编译</p>
<pre><code class="language-bash">cd racer &amp;&amp; cargo build --release
</code></pre>
<p>这样，我们会得到racer的二进制文件在 <code>target/release/racer</code>目录</p>
<a class="header" href="print.html#a设置环境变量" id="a设置环境变量"><h4>设置环境变量</h4></a>
<p>为了对Rust标准库进行补全，racer需要获取Rust源码路径。</p>
<p>设置名为<code>RUST_SRC_PATH</code>的环境变量为<code>[path_to_your_rust_source]/src</code></p>
<p>其中<code>[path_to_your_rust_source]</code>表示源码所在文件夹，使用rustup获取Rust源码的情况下<code>[path_to_your_rust_source]</code>默认为<code>~/.multirust/toolchains/[your-toolchain]/lib/rustlib/src/rust/src</code></p>
<a class="header" href="print.html#a测试" id="a测试"><h3>测试</h3></a>
<p>请重新打开终端，并进入到关闭之前的路径。
执行如下代码：
linux:</p>
<pre><code class="language-bash">./target/release/racer complete std::io::B
</code></pre>
<p>windows:</p>
<pre><code class="language-bash">target\release\racer complete std::io::B
</code></pre>
<p>你将会看到racer的提示，这表示racer已经执行完成了。</p>
<a class="header" href="print.html#a安装-rustfmt" id="a安装-rustfmt"><h2>安装 rustfmt</h2></a>
<p><code>cargo install rustfmt</code></p>
<a class="header" href="print.html#rust-langular-server-rls" id="rust-langular-server-rls"><h2>Rust Langular Server (RLS)</h2></a>
<p><code>Rust Langular Server</code>(下文简称<code>RLS</code>)可以为很多IDE或编辑器提供包括不限于自动补全、跳转定义、重命名、跳转类型的功能支持。</p>
<p>使用rustup安装步骤如下:</p>
<ol>
<li>保证<code>rustup</code>为最新版。关于
<pre><code class="language-bash">rustup self update
</code></pre>
关于 <code>rustup</code> 的用法，参照： <a href="https://github.com/rust-lang/rustup.rs">https://github.com/rust-lang/rustup.rs</a></li>
<li>[可选]升级工具链(并不要求设置<code>nightly</code>为默认，但需要保证安装了<code>nightly</code>工具链)
<pre><code class="language-bash">rustup update nightly
</code></pre>
</li>
<li>[可选]正式安装RLS 的 nightly方式
<pre><code class="language-bash">rustup component add rls --toolchain nightly
rustup component add rust-analysis --toolchain nightly
rustup component add rust-src --toolchain nightly
rustup component add clippy-preview
</code></pre>
</li>
<li>设置环境变量
如果在安装Racer时没有设置名为<code>RUST_SRC_PATH</code>的环境变量，请参考前文进行设置。</li>
</ol>
<p><strong>该项目托管地址:<a href="https://github.com/rust-lang-nursery/rls">https://github.com/rust-lang-nursery/rls</a></strong></p>
<a class="header" href="print.html#vimgvim安装配置" id="vimgvim安装配置"><h1>vim/GVim安装配置</h1></a>
<p>本节介绍vim的Rust支持配置，在阅读本节之前，我们假定你已经拥有了一个可执行的rustc程序，并编译好了racer。</p>
<a class="header" href="print.html#a我的vim截图" id="a我的vim截图"><h2>我的vim截图</h2></a>
<p>应邀而加</p>
<p><img src="../images/editor-vim-wayslog.png" alt="此处应该有截图" /></p>
<a class="header" href="print.html#a使用vundle" id="a使用vundle"><h2>使用vundle</h2></a>
<p>vundle是vim的一个插件管理工具，基本上算是本类当中最为易用的了。
首先我们需要安装它</p>
<a class="header" href="print.html#linux-or-os-x" id="linux-or-os-x"><h3>linux or OS X</h3></a>
<pre><code class="language-bash">mkdir -p  ~/.vim/bundle/
git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
</code></pre>
<a class="header" href="print.html#windows-1" id="windows-1"><h3>windows</h3></a>
<ol>
<li>首先找到你的gvim的安装路径，然后在路径下找到vimfiles文件夹</li>
<li>在这个文件夹中将vundle库克隆到vimfiles/bundle/目录下的Vundle.vim文件夹中</li>
</ol>
<a class="header" href="print.html#a启用rust支持" id="a启用rust支持"><h2>启用rust支持</h2></a>
<a class="header" href="print.html#a下载源码-1" id="a下载源码-1"><h3>下载源码</h3></a>
<p>首先，你需要下载rust-lang的源码文件，并将其解压到一个路径下。
这个源码文件我们可以从<a href="https://www.rust-lang.org/downloads.html">rust官网</a>下载到，请下载你对应平台的文件。
然后将其解压到一个目录下，并找到其源码文件中的<code>src</code>目录。
比如我们解压源码包到<code>C:\\rust-source\</code>，那么我们需要的路径就是<code>C:\\rust-source\src</code>，记好这个路径，我们将在下一步用到它。</p>
<a class="header" href="print.html#a修改vim配置" id="a修改vim配置"><h3>修改vim配置</h3></a>
<p>首先找到你的vimrc配置文件，然后在其中添加如下配置</p>
<pre><code class="language-vim">set nocompatible
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'
Plugin 'racer-rust/vim-racer'
Plugin 'rust-lang/rust.vim'

call vundle#end()

filetype on
</code></pre>
<p>然后为了让配置生效，我们重启我们的(g)vim，然后在vim里执行如下命令</p>
<pre><code>:PluginInstall
</code></pre>
<p>这里vundle会自动的去仓库里拉取我们需要的文件，这里主要是vim-racer和rust.vim两个库。</p>
<a class="header" href="print.html#a更多的配置" id="a更多的配置"><h3>更多的配置</h3></a>
<p>为了让我们的vim能正常的使用，我们还需要在vimrc配置文件里加入一系列配置，</p>
<pre><code class="language-vim">&quot;&quot; 开启rust的自动reformat的功能
let g:rustfmt_autosave = 1

&quot;&quot; 手动补全和定义跳转
set hidden
&quot;&quot; 这一行指的是你编译出来的racer所在的路径
let g:racer_cmd = &quot;&lt;path-to-racer&gt;/target/release/racer&quot;
&quot;&quot; 这里填写的就是我们在1.2.1中让你记住的目录
let $RUST_SRC_PATH=&quot;&lt;path-to-rust-srcdir&gt;/src/&quot;
</code></pre>
<a class="header" href="print.html#a使用-youcompleteme" id="a使用-youcompleteme"><h4>使用 YouCompleteMe</h4></a>
<p>YouCompleteMe 是 vim 下的智能补全插件, 支持 C-family, Python, Rust 等的语法补全, 整合了多种插件, 功能强大. Linux 各发行版的官方源里基本都有软件包, 可直接安装. 如果有需要进行编译安装的话, 可参考<a href="https://github.com/Valloric/YouCompleteMe#installation">官方教程</a></p>
<p>让 YCM 支持 Rust 需要在安装 YCM 过程中执行 ./install.py 时加上 --racer-completer, 并在 .vimrc 中添加如下设置</p>
<pre><code>let g:ycm_rust_src_path=&quot;&lt;path-to-rust-srcdir&gt;/src/&quot;
&quot;&quot; 一些方便的快捷键
&quot;&quot;&quot; 在 Normal 模式下, 敲 &lt;leader&gt;jd 跳转到定义或声明(支持跨文件)
nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;
&quot;&quot;&quot; 在 Insert 模式下, 敲 &lt;leader&gt;; 补全
inoremap &lt;leader&gt;; &lt;C-x&gt;&lt;C-o&gt;
</code></pre>
<a class="header" href="print.html#a总结" id="a总结"><h2>总结</h2></a>
<p>经过不多的配置，我们得到了如下功能：</p>
<ol>
<li>基本的c-x c-o补全 (使用 YCM 后, 能做到自动补全)</li>
<li>语法着色</li>
<li>gd跳转到定义</li>
</ol>
<p>总体来看支持度并不高。</p>
<p><img src="../images/editor-vim-welldone.png" alt="此处应该有第二张截图" /></p>
<a class="header" href="print.html#a额外的" id="a额外的"><h3>额外的</h3></a>
<p>Q1. 颜色好挫</p>
<p>A1. 我推荐一个配色，也是我自己用的 <a href="https://github.com/tomasr/molokai">molokai</a></p>
<p>更详细内容可以参见我的<a href="https://github.com/wayslog/dotfiles/blob/master/_vimrc">vimrc配置</a>，当然，我这个用的是比较老的版本的vundle，仅供参考。</p>
<p>Have a nice Rust !</p>
<a class="header" href="print.html#emacs" id="emacs"><h1>Emacs</h1></a>
<p>本节介绍 Emacs (Version 24) 的 Rust 配置，假设你已经安装好了 Emacs，并且有使用 Emacs 的经验。具体的安装和使用说明，见网上相关文档，在此不赘述。</p>
<p>另外，本节的例子是在 Mac OS 上，在 Linux 上面基本一样。</p>
<p>Windows的Emacs用户仅作参考。</p>
<a class="header" href="print.html#a简介" id="a简介"><h2>简介</h2></a>
<p>Emacs 的 rust-mode 提供了语法高亮显示和 elisp 函数，可以围绕 Rust 函数定义移动光标。有几个插件提供了附加的功能，如自动补全和动态语法检查。</p>
<p><img src="../images/editor-emacs-base.png" alt="" /></p>
<a class="header" href="print.html#a安装插件" id="a安装插件"><h2>安装插件</h2></a>
<p>首先，需要将 melpa 代码库添加到你的插件列表中，才能安装 Rust 需要的插件。将下面的代码片段加入你的<code>~/.emacs.d/init.el</code> 文件中。</p>
<pre><code>;; Add melpa repository to archives
(add-to-list 'package-archives
    '(&quot;melpa&quot; . &quot;http://melpa.milkbox.net/packages/&quot;) t)

;; Initialize packages
(package-initialize)

</code></pre>
<p>运行下面的命令，更新插件列表。</p>
<ul>
<li>M-x eval-buffer</li>
<li>M-x package-refresh-contents</li>
</ul>
<p>然后，就可以安装插件，在 Emacs 中使用 Rust 了。运行 <code>M-x package-list-packages</code>，用 <code>i</code> 标记下述插件进行安装，当所有的插件选择好了之后，用 <code>x</code> 执行安装。</p>
<ul>
<li>company</li>
<li>company-racer</li>
<li>racer</li>
<li>flycheck</li>
<li>flycheck-rust</li>
<li>rust-mode</li>
</ul>
<p>将下面的代码片段加入你的<code>~/.emacs.d/init.el</code> 文件：</p>
<pre><code>;; Enable company globally for all mode
(global-company-mode)

;; Reduce the time after which the company auto completion popup opens
(setq company-idle-delay 0.2)

;; Reduce the number of characters before company kicks in
(setq company-minimum-prefix-length 1)
;; Set path to racer binary
(setq racer-cmd &quot;/usr/local/bin/racer&quot;)

;; Set path to rust src directory
(setq racer-rust-src-path &quot;/Users/YOURUSERNAME/.rust/src/&quot;)

;; Load rust-mode when you open `.rs` files
(add-to-list 'auto-mode-alist '(&quot;\\.rs\\'&quot; . rust-mode))

;; Setting up configurations when you load rust-mode
(add-hook 'rust-mode-hook

     '(lambda ()
     ;; Enable racer
     (racer-activate)

     ;; Hook in racer with eldoc to provide documentation
     (racer-turn-on-eldoc)

     ;; Use flycheck-rust in rust-mode
     (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)

     ;; Use company-racer in rust mode
     (set (make-local-variable 'company-backends) '(company-racer))

     ;; Key binding to jump to method definition
     (local-set-key (kbd &quot;M-.&quot;) #'racer-find-definition)

     ;; Key binding to auto complete and indent
     (local-set-key (kbd &quot;TAB&quot;) #'racer-complete-or-indent)))

</code></pre>
<p><img src="../images/editor-emacs-error-checking.png" alt="" /></p>
<a class="header" href="print.html#a配置-racer" id="a配置-racer"><h2>配置 Racer</h2></a>
<p>Racer 需要 Rust 的源代码用于自动补全。</p>
<ul>
<li>git clone https://github.com/rust-lang/rust.git ~/.rust</li>
<li>重新启动 Emacs 并打开一个 Rust 源代码文件。</li>
</ul>
<p><img src="../images/editor-emacs-completion.png" alt="" /></p>
<a class="header" href="print.html#a结论" id="a结论"><h2>结论</h2></a>
<p>现在，可以在 Emacs 中编辑 Rust 源代码文件了。功能总结如下：</p>
<ul>
<li>语法高亮显示和自动缩进</li>
<li>自动补全</li>
<li>动态语法错误检查</li>
<li>跳转到函数定义</li>
<li>内嵌文档</li>
</ul>
<p><img src="../images/editor-emacs-jump.gif" alt="" /></p>
<a class="header" href="print.html#a注释" id="a注释"><h2>注释</h2></a>
<ol>
<li>本节的内容适用于 Emacs Version 24；版本 23 的配置方法不同；版本 22 及以下不支持。</li>
<li>MacOS 自带的 Emacs 版本是 22，版本 24 可以从<a href="http://emacsformacosx.com/">这里</a>下载。</li>
</ol>
<a class="header" href="print.html#vs-code-安装配置" id="vs-code-安装配置"><h1>VS Code 安装配置</h1></a>
<p><a href="https://code.visualstudio.com/">VS Code</a> 是微软出的一款开源代码编辑器，秉承了微软在IDE领域的一惯优秀基因，是一款潜力相当大的编辑器/IDE。</p>
<p>VScode 目前也对 Rust 也有良好的支持。</p>
<a class="header" href="print.html#a下载-vscode" id="a下载-vscode"><h2>下载 VScode</h2></a>
<p>请打开官网 https://code.visualstudio.com/ 下载编辑器。</p>
<a class="header" href="print.html#a依赖" id="a依赖"><h2>依赖</h2></a>
<p>如本章第一节所述，准备好 <code>racer</code>，<code>rust 源代码</code>，<code>rustfmt</code>，<code>rls</code> 这四样东西，并且配置好相应的环境变量，此不赘述。</p>
<a class="header" href="print.html#a安装-rust-扩展-rust" id="a安装-rust-扩展-rust"><h2>安装 Rust 扩展 Rust</h2></a>
<ol>
<li>打开 VScode 编辑器；</li>
<li>按 Ctrl + p 打开命令面板；</li>
<li>在编辑器中上部浮现出的输入框中，输入 <code>ext install vscode-rust</code>，会自动搜索可用的插件，搜索出来后，点击进行安装；</li>
<li>使用<code>VScode</code>打开任意一个<code>.rs</code>文件，插件首次启动会自动引导用户完成配置。</li>
</ol>
<p>注:推荐使用RLS模式，即使用<a href="https://github.com/rust-lang-nursery/rls">Rust Langular Server</a>提供各项功能支持</p>
<a class="header" href="print.html#atom" id="atom"><h1>Atom</h1></a>
<p>本文是rust的Atom编辑器配置。
横向对比一下，不得不说，Atom无论在易用性还是界面上都比前辈们要好的很多，对于Rust的配置，也是基本上可以做到开箱即用。
虽然本文独占一小节，但是其实能写的东西也就了了。</p>
<ul>
<li><a href="print.html#%E8%87%AA%E8%A1%8C%E9%85%8D%E7%BD%AE">自行配置</a></li>
<li><a href="print.html#tokamak">使用tokamak</a></li>
</ul>
<a class="header" href="print.html#a自行配置" id="a自行配置"><h2>自行配置</h2></a>
<a class="header" href="print.html#a准备工作" id="a准备工作"><h2>准备工作</h2></a>
<p>首先，你需要一个可执行的rustc编译器，一个cargo程序，一个已经编译好的racer程序和一份已经解压好的rust源码。
我们假定你已经将这三个程序安装完毕，并且能够自由的从命令行里调用他们。</p>
<p>另外，本文不讲解如何安装Atom，需要新安装的同学请自行前往<a href="https://github.com/atom/atom">项目主页</a>安装。</p>
<p>ps:无论是windows用户还是*nix用户都需要将以上三个程序加入你的PATH(Windows下叫Path)环境变量里。</p>
<a class="header" href="print.html#a需要安装的插件包" id="a需要安装的插件包"><h2>需要安装的插件包</h2></a>
<p>打开Atom，按Ctrl+Shift+p，搜索preference，打开Atom的配置中心，选择install选项卡。</p>
<p>依次安装<code>rust-api-docs-helper</code>/<code>racer</code>/<code>language-rust</code>/<code>linter-rust</code>/<code>linter</code>。</p>
<p>这里要单独说的一个就是linter，这是一个基础的lint组件包，atom的很多以linter为前缀的包都会依赖这个包，但是Atom并不会为我们自动的安装，因此需要我们自己去安装。</p>
<a class="header" href="print.html#a一点配置" id="a一点配置"><h2>一点配置</h2></a>
<p>以上，我们安装好了几个组件包，但是不要着急去打开一个Rust文件。你可能还需要一点点的配置。这里，我们在配置中心里打开<code>Packages</code>选项卡，在<code>Installed Packages</code>里搜索racer，并点击其<code>Setting</code>。</p>
<p>这里需要将racer的可执行文件的绝对路径填入<code>Path to the Racer executable</code>里。同时，我们还需要将rust源码文件夹下的src目录加入到<code>Path to the Rust source code directory</code>里。</p>
<a class="header" href="print.html#a完成安装" id="a完成安装"><h2>完成安装</h2></a>
<p>好了，就是这么简单。你现在可以打开任意一个rust文件就会发现源码高亮已经默认打开了，编辑一下，racer也能自动补全，<em>如果不能</em>，尝试一下用<code>F3</code>键来显式地呼出racer的补全。</p>
<a class="header" href="print.html#tokamak" id="tokamak"><h2>tokamak</h2></a>
<p><a href="https://github.com/vertexclique/tokamak">tokamak</a> 是一个使 atom 摇身一变为 rust IDE 的 atom 插件. 安装后 atom 即具有语法高亮, 代码补全与 Lint 等功能, 而且还有个不错的界面, 看起来确实像个 IDE. 你可以在 atom 中搜索 tokamak 并安装它.</p>
<a class="header" href="print.html#sublime" id="sublime"><h1>Sublime</h1></a>
<p>Sublime Text是一款非常有名的文本编辑器，其本身也具备强大的插件机制。通过配置各种插件可以在使用Sublime Text编辑rust代码时获得更加良好的支持。</p>
<p>本文主要展示在已经预装rust的Windows环境下的安装，如果您还没有安装rust，请先参照本书的<a href="../install/install_rust_on_windows.md">安装章节</a>安装rust。</p>
<a class="header" href="print.html#a安装-1" id="a安装-1"><h2>安装</h2></a>
<a class="header" href="print.html#sublime-text3安装" id="sublime-text3安装"><h3>Sublime Text3安装</h3></a>
<p>请在 <a href="http://www.sublimetext.com/3">Sublime Text3官网</a>上选择适合当前机器版本的Sublime Text版本进行下载和安装。</p>
<a class="header" href="print.html#rust的安装" id="rust的安装"><h3>rust的安装</h3></a>
<p>请在rust官网的<a href="https://www.rust-lang.org/downloads.html">下载页面</a>下载rust的源代码压缩包并在本地解压缩安装，在稍后的配置环节我们将会用到这个路径。如果国内下载速度过慢，可以考虑使用中科大的<a href="http://mirrors.ustc.edu.cn/">镜像</a>下载rust源码包。</p>
<a class="header" href="print.html#a下载rust并编译代码提示插件racer" id="a下载rust并编译代码提示插件racer"><h3>下载Rust并编译代码提示插件racer</h3></a>
<p>具体安装和编译内容请查看本章第一节的<a href="../editors/before.md">安装准备</a>，请牢记编译后的racer.exe文件路径，在稍后的配置环节中我们将用到它。</p>
<a class="header" href="print.html#a配置" id="a配置"><h2>配置</h2></a>
<a class="header" href="print.html#sublime-text3相关插件安装" id="sublime-text3相关插件安装"><h3>Sublime Text3相关插件安装</h3></a>
<a class="header" href="print.html#a安装package-control" id="a安装package-control"><h4>安装Package Control</h4></a>
<p>Sublime Text3在安装各种插件前需要先安装Package Control，如果您的编辑器已安装Package Control请跳过本段直接安装rust相关插件。</p>
<p>您可以查看<a href="https://packagecontrol.io/installation">Package Control官网</a>学习如何安装。
也可以直接在编辑器中使用 <code>ctrl+~</code> 快捷键启动控制台，粘贴以下代码并回车进行安装。</p>
<pre><code class="language-shell">
import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)

</code></pre>
<a class="header" href="print.html#rust相关插件" id="rust相关插件"><h4>rust相关插件</h4></a>
<p>在编辑器下使用快捷键 <code>ctrl+shift+p</code> 启动命令行工具，输入Install Package按回车进入插件安装，选择或输入插件名称并回车即可完成插件的安装。</p>
<p>使用上述方式安装Rust插件(rust语法高亮)、RustAutoComplete(rust代码提示和自动补全插件)。</p>
<p>此时安装尚未完成，我们需要将本地的 racer.exe配置进RustAutoComplete插件中。打开编辑器顶端的Preferences选项卡，依次 Preferences-&gt;Package Settings-&gt;RustAutoComplete-&gt;Settings-User 来打开 RustAutoComplete 的配置文件，在文件中配置以下信息并保存。</p>
<pre><code class="language-shell">{
  &quot;racer&quot;: &quot;E:/soft/racer-master/target/release/racer.exe&quot;,
  &quot;search_paths&quot;: [    &quot;E:/soft/rustc-1.7.0/src&quot;   ]
}
</code></pre>
<p>其中racer是编译后的racer.exe程序的绝对路径。search_paths是rust源码文件下src目录的绝对路径。</p>
<p>编辑器重启后插件即可生效。</p>
<a class="header" href="print.html#a快速编译" id="a快速编译"><h2>快速编译</h2></a>
<p>Sublime本身支持多种编译系统，在Tools选项卡下的Build System中选择Rust或者Cargo作为编译系统，选中后使用快捷键 <code>ctrl+B</code> 即可对代码进行快速编译。</p>
<a class="header" href="print.html#visual-studio" id="visual-studio"><h1>Visual Studio</h1></a>
<p>本文是使用VisualRust和VS GDB Debugger / VisualGDB 完成在VisualStudio中，编辑和调试Rust程序。</p>
<a class="header" href="print.html#a安装rust-cargo" id="a安装rust-cargo"><h2>安装Rust, Cargo</h2></a>
<p>首先需要下载Rust, 下载地址https://www.rust-lang.org/downloads.html</p>
<p>这里一定要下windows GNU ABI的版本, 因为我们要用GDB来调试.</p>
<p><img src="../images/editor-visualstudio-download.png" alt="" /></p>
<p>另外，机器上也需要安装Visual Studio2013或2015。
安装完Rust,打开命令行，执行
cargo install racer</p>
<p><img src="../images/editor-visualstudio-racer.png" alt="" /></p>
<p>Racer是用来做Rust自动完成的，会在VisualRust使用。这里我们使用rust编译的racer, 并不用VisualRust里自带的racer，因为它太旧了.
另外需要下载Rust源代码，设置
RUST_SRC_PATH为Rust源代码src的目录</p>
<p><img src="../images/editor-visualstudio-racersc.png" alt="" /></p>
<a class="header" href="print.html#a安装visualrust和vs-gdb-debugger" id="a安装visualrust和vs-gdb-debugger"><h2>安装VisualRust和VS GDB Debugger</h2></a>
<p>做完上述工作，就可以安装VisualRust和VS GDB Debugger,在这里下载
https://github.com/PistonDevelopers/VisualRust
https://visualstudiogallery.msdn.microsoft.com/35dbae07-8c1a-4f9d-94b7-bac16cad9c01</p>
<p>VisualGDB可在这里购买
http://www.visualgdb.com/</p>
<a class="header" href="print.html#a编译rust项目" id="a编译rust项目"><h2>编译Rust项目</h2></a>
<p>新建Rust项目
<img src="../images/editor-visualstudio-newproject.png" alt="" />
在tool, option里设置racer和rust_src_path
<img src="../images/editor-visualstudio-settings.png" alt="" />
这时候就可以在写代码的时候就可以自动提示了。像下面这样
<img src="../images/editor-visualstudio-autocomplete.png" alt="" /></p>
<a class="header" href="print.html#a用vs-gdb-debugger调试rust项目" id="a用vs-gdb-debugger调试rust项目"><h2>用VS GDB Debugger调试Rust项目</h2></a>
<p>ok,愉快的开始你的Rust之旅吧。下面开始使用VS GDB Debugger调试Rust.</p>
<p>在解决方案中，添加GDB调试项目
<img src="../images/editor-visualstudio-GDBproject.png" alt="" /></p>
<p>设置需要调试的程序所在的目录和文件名
<img src="../images/editor-visualstudio-GDBproject-settings.png" alt="" /></p>
<p>设置需要调试的程序的编译命令，此处用rustc，也可以使用cargo编译
<img src="../images/editor-visualstudio-GDBproject-settings2.png" alt="" /></p>
<p>将需要调试的程序的源代码添加到项目目录下
<img src="../images/editor-visualstudio-add-files.png" alt="" /></p>
<p>打开源代码文件并设置断点信息，将项目设置为启动项目并选择Local GDB即可开始调试
<img src="../images/editor-visualstudio-set-breakpoints.png" alt="" /></p>
<p><img src="../images/editor-visualstudio-debugging2.png" alt="" /></p>
<a class="header" href="print.html#a用visualgdb调试rust项目" id="a用visualgdb调试rust项目"><h2>用VisualGDB调试Rust项目</h2></a>
<p>Build完Rust程序，点击debug, 选择quick debug with gdb
<img src="../images/editor-visualstudio-quickdebug.png" alt="" /></p>
<p>然后在里面选择MingW和exe的路径</p>
<p><img src="../images/editor-visualstudio-setdebugger.png" alt="" /></p>
<p>点击Debug,开始你的调试生活吧</p>
<p><img src="../images/editor-visualstudio-debugging.png" alt="" /></p>
<a class="header" href="print.html#intellij-idea-安装配置" id="intellij-idea-安装配置"><h1>IntelliJ IDEA 安装配置</h1></a>
<p><a href="https://www.jetbrains.com/idea">IntelliJ IDEA</a> 是JetBrains 研发的一款编程IDE工具。</p>
<p>该文章也适用于 <a href="https://www.jetbrains.com/clion">CLion</a></p>
<a class="header" href="print.html#a下载-intellij-idea-或者-clion" id="a下载-intellij-idea-或者-clion"><h2>下载 IntelliJ IDEA 或者 CLion</h2></a>
<p>请打开官网 <a href="https://www.jetbrains.com/products.html">https://www.jetbrains.com/products.html</a> 下载编辑器。</p>
<a class="header" href="print.html#a依赖-1" id="a依赖-1"><h2>依赖</h2></a>
<p>如本章第一节所述，准备好 <code>racer</code>，<code>rust 源代码</code>，<code>rustfmt</code>，<code>rls</code> 这四样东西，并且配置好相应的环境变量，此不赘述。</p>
<a class="header" href="print.html#a安装插件-rust-扩展-rust" id="a安装插件-rust-扩展-rust"><h2>安装插件 Rust 扩展 Rust</h2></a>
<ol>
<li>打开 IDE；</li>
<li>安装插件： Rust</li>
</ol>
<p>具体方法：可以参考 <a href="https://plugins.jetbrains.com/plugin/8182-rust">https://plugins.jetbrains.com/plugin/8182-rust</a></p>
<p>注:推荐使用RLS模式，即使用<a href="https://github.com/rust-lang-nursery/rls">Rust Langular Server</a>提供各项功能支持</p>
<a class="header" href="print.html#spacemacs" id="spacemacs"><h1>Spacemacs</h1></a>
<p>spacemacs，是一个给vimer的Emacs。</p>
<a class="header" href="print.html#a简介-1" id="a简介-1"><h2>简介</h2></a>
<p>spacemacs是一个专门给那些习惯vim的操作，同时又向往emacs的扩展能力的人。它非常适合我这种折腾过vim，配置过emacs的人，但同时也欢迎任何没有基础的新人使用。简单来说，它是一个开箱即用的Emacs！这对一个比很多人年龄都大的软件来说是一件极其不容易的事情。</p>
<a class="header" href="print.html#a安装-2" id="a安装-2"><h2>安装</h2></a>
<p>由于笔者自己在linux平台，并没有windows平台的经验，所以在这里便不献丑了，期待各位补充。另外，windows平台真的需要么，斜眼瞅向了Visual Studio。</p>
<a class="header" href="print.html#emacs安装" id="emacs安装"><h3>Emacs安装</h3></a>
<p>在*nix系统中，都不一定会默认安装了Emacs，就算安装了，也不一定是最新的版本。在这里，我强烈建议各位卸载掉系统自带的Emacs，因为你不知道系统给你安装的是个什么奇怪的存在，最遭心的，我碰见过只提供阉割版Emacs的linux发行版。</p>
<p>建议各位自己去emacs项目主页下载Emacs-24.5（本书写作时的最新版）极其以上版本，然后下载下来源码。至于Emacs的安装也非常简单，linux平台老三步。</p>
<pre><code class="language-bash">./configure
make
sudo make install
</code></pre>
<p>什么？你没有make？没有GCC？缺少依赖？
请安装它们……</p>
<a class="header" href="print.html#spacemacs安装" id="spacemacs安装"><h3>Spacemacs安装</h3></a>
<p>前面说了,Spacemacs就是个Emacs的配置文件库，因此我们可以通过非常简单的方式安装它：</p>
<pre><code class="language-bash">git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
mv ~/.emacs ~/_emacs.backup
cd ~/.emacs.d
echo $(git describe --tags $(git rev-list --tags --max-count=1)) | xargs git checkout
</code></pre>
<p>其中，后三行是笔者加的，这里必须要吐槽一下的是，Spacemacs的master分支实际上是极其落后而且有错误的！其目前的release都是从develop分支上打的tag。</p>
<p>因此，一！定！不！要！用！主！分！支！</p>
<p>最后，之所以要加最后一行，这是笔者安装的时候的release的一个小bug，没有这个文件的话,emacs并不会顺利的完成初始化。</p>
<p>好了，配置文件我们已经搞定了，接下来，启动你的emacs，spacemacs会自动的去网上下载你需要的插件安装包。另外，能自备梯子的最好，因为你要下的东西不大，但是这个网络确实比较捉急。</p>
<a class="header" href="print.html#a前期准备-1" id="a前期准备-1"><h3>前期准备</h3></a>
<p>为了让Spacemacs支持Rust，我们还需要一点小小的配置。首先，请参照<a href="../editors/before.md">前期准备</a>，安装好你的racer。</p>
<p>在这里，强烈建议将racer的环境变量加入到系统变量中(通常他们在<code>/etc/profile/</code>里进行配置)并重新启动系统，因为真的有很多人直接点击emacs的图标启动它的，这样做很可能导致emacs并不继承自己的环境变量，这是很令人无奈的。</p>
<a class="header" href="print.html#a完成配置" id="a完成配置"><h2>完成配置</h2></a>
<a class="header" href="print.html#a修改标准的spacemacs配置" id="a修改标准的spacemacs配置"><h3>修改标准的Spacemacs配置。</h3></a>
<p>Spacemacs文档中提供了一份标准的spacemacs<a href="https://github.com/syl20bnr/spacemacs/blob/master/core/templates/.spacemacs.template">配置文件</a>，你可以将其加入到你自己的<code>~/.spacemacs</code>文件中。</p>
<p>这里，我们需要修改的是其关于自定义插件的部分：</p>
<pre><code class="language-lisp">(defun dotspacemacs/layers ()
  &quot;Configuration Layers declaration.
You should not put any user code in this function besides modifying the variable
values.&quot;
  (setq-default
   ;; Base distribution to use. This is a layer contained in the directory
   ;; `+distribution'. For now available distributions are `spacemacs-base'
   ;; or `spacemacs'. (default 'spacemacs)
   dotspacemacs-distribution 'spacemacs
   ;; List of additional paths where to look for configuration layers.
   ;; Paths must have a trailing slash (i.e. `~/.mycontribs/')
   dotspacemacs-configuration-layer-path '()
   ;; List of configuration layers to load. If it is the symbol `all' instead
   ;; of a list then all discovered layers will be installed.
   dotspacemacs-configuration-layers
   '(
     ;; ----------------------------------------------------------------
     ;; Example of useful layers you may want to use right away.
     ;; Uncomment some layer names and press &lt;SPC f e R&gt; (Vim style) or
     ;; &lt;M-m f e R&gt; (Emacs style) to install them.
     ;; ----------------------------------------------------------------
     auto-completion
     better-defaults
     git
     spell-checking
     syntax-checking
     version-control
     rust
     )
   ;; List of additional packages that will be installed without being
   ;; wrapped in a layer. If you need some configuration for these
   ;; packages then consider to create a layer, you can also put the
   ;; configuration in `dotspacemacs/config'.
   dotspacemacs-additional-packages '()
   ;; A list of packages and/or extensions that will not be install and loaded.
   dotspacemacs-excluded-packages '()
   ;; If non-nil spacemacs will delete any orphan packages, i.e. packages that
   ;; are declared in a layer which is not a member of
   ;; the list `dotspacemacs-configuration-layers'. (default t)
   dotspacemacs-delete-orphan-packages t))

;; ...
;; 以下配置文件内容省略
;; ...
</code></pre>
<p>注意<code>dotspacemacs-configuration-layers</code>的配置和标准配置文件的不同。</p>
<p>将配置文件保存，然后重启你的emacs，当然，我们也可以按<code>SPC f e R</code>来完成重载配置文件的目的，然后你会发现emacs会开始下一轮下载，稍等其完成。</p>
<p>在上一步中，我们已经完成了对Racer的环境变量的配置，所以，现在你的Spacemacs已经配置完成了！这种简便的配置形式，几乎能和Atom抗衡了。</p>
<a class="header" href="print.html#a按键绑定" id="a按键绑定"><h3>按键绑定</h3></a>
<p>如下，spacemacs默认提供了几种按键绑定，但是，笔者并不觉得这些很好用，还是更喜欢用命令行。</p>
<table><thead><tr><th> Key Binding </th><th> Description                       </th></tr></thead><tbody>
<tr><td> ~SPC m c c~ </td><td> compile project with Cargo        </td></tr>
<tr><td> ~SPC m c t~ </td><td> run tests with Cargo              </td></tr>
<tr><td> ~SPC m c d~ </td><td> generate documentation with Cargo </td></tr>
<tr><td> ~SPC m c x~ </td><td> execute the project with Cargo    </td></tr>
</tbody></table>
<a class="header" href="print.html#a尝试" id="a尝试"><h2>尝试</h2></a>
<p>现在开始，我们可以打开一个Cargo项目，并且去使用它了。你会惊讶的发现racer/flycheck/company这三个插件配合在一起的时候是那么的和谐简单。</p>
<a class="header" href="print.html#a快速上手" id="a快速上手"><h1>快速上手</h1></a>
<p>本章的目的在于快速上手(Quickstart)，对Rust语言建立初步的印象。
前面的章节中，我们已经安装好了Rust，配置好了编辑器，相信你一定已经跃跃欲试了。
注意: 本章的一些概念只需要大概了解就行，后续的章节将会有详细的讲解，但是本章的例子请务必亲自手敲并运行一遍。</p>
<p>下面，让我们开始动手写Rust程序吧!</p>
<p>ps：本章原始章节由 ee0703 书写的。因为内容不太满意，由 <a href="https://github.com/Naupio">Naupio（N猫）</a>重写了整个章节，并加入大量的内容。特别鸣谢 <a href="https://github.com/photino">photino</a> 提供的 <a href="https://github.com/photino/rust-notes">rust-notes</a> 。本章也有大量内容编辑自 <a href="https://github.com/Naupio">Naupio（N猫）</a> 创作中的 Rust  新书的快速入门章节。</p>
<a class="header" href="print.html#rust旅程" id="rust旅程"><h1>Rust旅程</h1></a>
<a class="header" href="print.html#helloworld" id="helloworld"><h2>HelloWorld</h2></a>
<p>按照编程语言的传统，学习第一门编程语言的第一个程序都是打印 Hello World！
下面根据我们的步骤创建 Rust 的 Hello World！程序：</p>
<p><strong>下面的命令操作，如果没有特别说明，都是在shell下运行。本文为了简单统一，所有例子都在 win10 的 powershell 下运行，所有命令都运行在<code>ps:</code>标识符之后</strong></p>
<ul>
<li>创建一个 Doing 目录和 helloworld.rs 文件</li>
</ul>
<blockquote>
<p>ps: mkdir ~/Doing<br />
ps: cd ~/Doing<br />
ps: notepad helloworld.rs # 作者偏向于使用 sublime 作为编辑器<br />
ps: subl helloworld.rs # 本章以后使用 subl 代替 notepad</p>
</blockquote>
<p>注意这里用的后缀名是.rs，一般编程语言的代码文件都有惯用的后缀名，比如：
C语言是.c，java是.java，python是.py等等，<strong>请务必记住Rust语言的惯用后缀名是.rs</strong>（虽然用别的后缀名也能通过rustc的编译）。</p>
<ul>
<li>在 helloworld.rs 文件中输入 Rust 代码</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<ul>
<li>编译 helloworld.rs 文件</li>
</ul>
<blockquote>
<p>ps: rustc helloworld.rs<br />
ps: rustc helloworld.rs -O # 也可以选择优化编译</p>
</blockquote>
<ul>
<li>运行程序</li>
</ul>
<blockquote>
<p>ps: ./helloworld.exe # windows 平台下需要加 .exe 后缀<br />
Hello World!</p>
</blockquote>
<p>没有<code>ps:</code>前缀的表示为控制台打印输出。</p>
<p>我们已经用rust编写第一个可执行程序，打印出了'hello world!'，很酷，对吧！
但是这段代码到底是什么意思呢，作为新手的你一定云里雾里吧，让我们先看一下这个程序：</p>
<ol>
<li>第一行中 fn 表示定义一个<strong>函数</strong>，main是这个函数的名字，花括号{}里的语句则表示这个函数的内容。</li>
<li>名字叫做<strong>main</strong>的函数有特殊的用途，那就是作为程序的入口，也就是说程序每次都从这个函数开始运行。</li>
<li>函数中只有一句 <code>println!(&quot;Hello World!&quot;);</code>，这里<code>println!</code>是一个Rust语言自带的<strong>宏</strong>，
这个宏的功能就是打印文本(结尾会换行)，而&quot;Hello World!&quot;这个用引号包起来的东西是一个<strong>字符串</strong>，就是我们要打印的文本。</li>
<li>你一定注意到了<code>;</code>吧， 在Rust语言中，分号<code>;</code>用来把语句分隔开，也就是说语句的末尾一般用分号做为结束标志。</li>
</ol>
<a class="header" href="print.html#hellorust" id="hellorust"><h2>HelloRust</h2></a>
<ul>
<li>创建项目 hellorust</li>
</ul>
<blockquote>
<p>ps: cargo new hellorust --bin</p>
</blockquote>
<ul>
<li>查看目录结构</li>
</ul>
<blockquote>
<p>ps: tree # win10 powershell 自带有 tree 查看文件目录结构的功能<br />
└─hellorust<br />
----└─src</p>
</blockquote>
<p>这里显示的目录结构，在hellorust目录下有 src 文件夹和 Cargo.toml 文件，同时这个目录会初始化为 git 项目</p>
<ul>
<li>查看Cargo.toml文件</li>
</ul>
<blockquote>
<p>ps: cat Cargo.toml<br />
[package]<br />
name = &quot;hellorust&quot;<br />
version = &quot;0.1.&quot;<br />
authors = [&quot;YourName <YourEmail>&quot;]<br />
[dependencies]</p>
</blockquote>
<ul>
<li>编辑src目录下的main.rs文件</li>
</ul>
<blockquote>
<p>ps: subl ./src/main.rs</p>
</blockquote>
<p>cargo 创建的项目，在src目录下会有一个初始化的main.rs文件，内容为：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>现在我们编辑这个文件，改为：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rust = &quot;Rust&quot;;
    println!(&quot;Hello, {}!&quot;, rust);
}
</code></pre></pre>
<p>这里的 <code>let rust = &quot;Rust&quot;</code> 是把 rust 变量绑定为 &quot;Rust&quot; ，
<code>println!(&quot;Hello, {}!&quot;, rust);</code>里把 rust 变量的值代入到<code>&quot;Hello, {}!&quot;</code>中的<code>{}</code>。</p>
<ul>
<li>编译和运行</li>
</ul>
<blockquote>
<p>ps: cargo build<br />
ps: cargo build --release # 这个属于优化编译<br />
ps: ./target/debug/hellorust.exe<br />
ps: ./target/release/hellorust.exe # 如果前面是优化编译，则这样运行<br />
ps: cargo run # 编译和运行合在一起<br />
ps: cargo run --release # 同上，区别是是优化编译的</p>
</blockquote>
<a class="header" href="print.html#a变量绑定与原生类型" id="a变量绑定与原生类型"><h1>变量绑定与原生类型</h1></a>
<a class="header" href="print.html#a变量绑定" id="a变量绑定"><h2>变量绑定</h2></a>
<p>Rust 通过 let 关键字进行变量绑定。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a1 = 5;
    let a2:i32 = 5;
    assert_eq!(a1, a2);
    //let 绑定 整数变量默认类型推断是 i32

    let b1:u32 = 5;
    //assert_eq!(a1, b1);
    //去掉上面的注释会报错，因为类型不匹配
    //errer: mismatched types
}
</code></pre></pre>
<p>这里的 assert_eq! 宏的作用是判断两个参数是不是相等的，但如果是两个不匹配的类型，就算字面值相等也会报错。</p>
<a class="header" href="print.html#a可变绑定" id="a可变绑定"><h2>可变绑定</h2></a>
<p>rust 在声明变量时，在变量前面加入 mut 关键字，变量就会成为可变绑定的变量。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut a: f64 = 1.0;
    let b = 2.0f32;

    //改变 a 的绑定
    a = 2.0;
    println!(&quot;{:?}&quot;, a);

    //重新绑定为不可变
    let a = a;

    //不能赋值
    //a = 3.0;

    //类型不匹配
    //assert_eq!(a, b);
}
</code></pre></pre>
<p>这里的 b 变量，绑定了 2.0f32。这是 Rust 里面值类型显式标记的语法，规定为<code>value</code>+<code>type</code>的形式。</p>
<p><strong>例如：</strong>
固定大小类型：</p>
<blockquote>
<p>1u8 1i8<br />
1u16 1i16<br />
1u32 1i32<br />
1u64 1i64</p>
</blockquote>
<p>可变大小类型：</p>
<blockquote>
<p>1usize 1isize</p>
</blockquote>
<p>浮点类型：</p>
<blockquote>
<p>1f32 1f64</p>
</blockquote>
<a class="header" href="print.html#let解构" id="let解构"><h2>let解构</h2></a>
<p>为什么在 Rust 里面声明一个变量的时候要采用 let 绑定表达式？
那是因为 let 绑定表达式的表达能力更强，而且 let 表达式实际上是一种模式匹配。</p>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    println!(&quot;a = {:?}, b = {:?}&quot;, a, b);
    //a 不可变绑定
    //a = false;

    //b 可变绑定
    b = true;
    assert_eq!(a, b);
}
</code></pre></pre>
<p>这里使用了 bool，只有true和false两个值，通常用来做逻辑判断的类型。</p>
<a class="header" href="print.html#a概要" id="a概要"><h1>概要</h1></a>
<p>在 Rust 中，每一个值(或资源)都属于某一个 <strong>数据类型</strong>（<em>data type</em>），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：</p>
<ol>
<li>标量（scalar）</li>
<li>复合（compound）</li>
</ol>
<p>记住，Rust 是 <strong>静态类型</strong>（<em>statically typed</em>）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，使用指定转换方式。例如，下面的例子，使用 <code>parse</code> 将 <code>String</code> 转换为数字时，必须增加类型注解：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
#}</code></pre></pre>
<p>这里如果不添加类型注解，Rust 会显示如下错误，这说明编译器需要我们提供更多信息，来了解我们想要的类型：</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
</code></pre>
<p>同时，Rust 内置了很多原生类型（Primitive Types）， 我们根据两类数据类型子集的方式来细分一下。</p>
<a class="header" href="print.html#a内置原生类型" id="a内置原生类型"><h2>内置原生类型</h2></a>
<ul>
<li>
<p>标量（scalar）：</p>
<ol>
<li>布尔类型 (boolean):</li>
<li>字符类型 (char):</li>
<li>整型 (integer):</li>
<li>浮点型 (float):</li>
<li>指针类型 (RAW Point):</li>
<li>元类型 (meta):</li>
</ol>
</li>
<li>
<p>复合（compound）：</p>
<ul>
<li>元组类型 (tuple):</li>
<li>数组类型 (array):</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#a非内置原生类型" id="a非内置原生类型"><h2>非内置原生类型</h2></a>
<p>Rust内置的原生类型 (primitive types) 有以下几类：</p>
<ul>
<li>布尔类型：有两个值<code>true</code>和<code>false</code>。</li>
<li>字符类型：表示单个Unicode字符，存储为4个字节。</li>
<li>数值类型：分为有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、
无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 以及浮点数 (<code>f32</code>, <code>f64</code>)。</li>
<li>字符串类型：最底层的是不定长类型<code>str</code>，更常用的是字符串切片<code>&amp;str</code>和堆分配字符串<code>String</code>，
其中字符串切片是静态分配的，有固定的大小，并且不可变，而堆分配字符串是可变的。</li>
<li>数组：具有固定大小，并且元素都是同种类型，可表示为<code>[T; N]</code>。</li>
<li>切片：引用一个数组的部分数据并且不需要拷贝，可表示为<code>&amp;[T]</code>。</li>
<li>元组：具有固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得每个元素的值。</li>
<li>指针：最底层的是裸指针<code>*const T</code>和<code>*mut T</code>，但解引用它们是不安全的，必须放到<code>unsafe</code>块里。</li>
<li>函数：具有函数类型的变量实质上是一个函数指针。</li>
<li>元类型：即<code>()</code>，其唯一的值也是<code>()</code>。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boolean type
let t = true;
let f: bool = false;

// char type
let c = 'c';

// numeric types
let x = 42;
let y: u32 = 123_456;
let z: f64 = 1.23e+2;
let zero = z.abs_sub(123.4);
let bin = 0b1111_0000;
let oct = 0o7320_1546;
let hex = 0xf23a_b049;

// string types
let str = &quot;Hello, world!&quot;;
let mut string = str.to_string();

// arrays and slices
let a = [0, 1, 2, 3, 4];
let middle = &amp;a[1..4];
let mut ten_zeros: [i64; 10] = [0; 10];

// tuples
let tuple: (i32, &amp;str) = (50, &quot;hello&quot;);
let (fifty, _) = tuple;
let hello = tuple.1;

// raw pointers
let x = 5;
let raw = &amp;x as *const i32;
let points_at = unsafe { *raw };

// functions
fn foo(x: i32) -&gt; i32 { x }
let bar: fn(i32) -&gt; i32 = foo;
#}</code></pre></pre>
<p>有几点是需要特别注意的：</p>
<ul>
<li>数值类型可以使用<code>_</code>分隔符来增加可读性。</li>
<li>Rust还支持单字节字符<code>b'H'</code>以及单字节字符串<code>b&quot;Hello&quot;</code>，仅限制于ASCII字符。
此外，还可以使用<code>r#&quot;...&quot;#</code>标记来表示原始字符串，不需要对特殊字符进行转义。</li>
<li>使用<code>&amp;</code>符号将<code>String</code>类型转换成<code>&amp;str</code>类型很廉价，
但是使用<code>to_string()</code>方法将<code>&amp;str</code>转换到<code>String</code>类型涉及到分配内存，
除非很有必要否则不要这么做。</li>
<li>数组的长度是不可变的，动态的数组称为Vec (vector)，可以使用宏<code>vec!</code>创建。</li>
<li>元组可以使用<code>==</code>和<code>!=</code>运算符来判断是否相同。</li>
<li>不多于32个元素的数组和不多于12个元素的元组在值传递时是自动复制的。</li>
<li>Rust不提供原生类型之间的隐式转换，只能使用<code>as</code>关键字显式转换。</li>
<li>可以使用<code>type</code>关键字定义某个类型的别名，并且应该采用驼峰命名法。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// explicit conversion
let decimal = 65.4321_f32;
let integer = decimal as u8;
let character = integer as char;

// type aliases
type NanoSecond = u64;
type Point = (u8, u8);
#}</code></pre></pre>
<a class="header" href="print.html#a数组动态数组和字符串" id="a数组动态数组和字符串"><h1>数组、动态数组和字符串</h1></a>
<a class="header" href="print.html#a数组和动态数组" id="a数组和动态数组"><h2>数组和动态数组</h2></a>
<a class="header" href="print.html#a数组-array" id="a数组-array"><h3>数组 array</h3></a>
<p>Rust 使用数组存储相同类型的数据集。
<code>[T; N]</code>表示一个拥有 T 类型，N 个元素的数组。数组的大小是固定。</p>
<p><strong>例子：</strong></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut array: [i32; 3] = [0; 3];

    array[1] = 1;
    array[2] = 2;

    assert_eq!([1, 2], &amp;array[1..]);

    // This loop prints: 0 1 2
    for x in &amp;array {
        println!(&quot;{} &quot;, x);
    }
}
</code></pre></pre>
<a class="header" href="print.html#a动态数组-vec" id="a动态数组-vec"><h3>动态数组 Vec</h3></a>
<p>动态数组是一种基于堆内存申请的连续动态数据类型，拥有 O(1) 时间复杂度的索引、压入（push）、弹出（pop)。</p>
<p><strong>例子：</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//创建空Vec
let v: Vec&lt;i32&gt; = Vec::new();
//使用宏创建空Vec
let v: Vec&lt;i32&gt; = vec![];
//创建包含5个元素的Vec
let v = vec![1, 2, 3, 4, 5];
//创建十个零
let v = vec![0; 10];
//创建可变的Vec，并压入元素3
let mut v = vec![1, 2];
v.push(3);
//创建拥有两个元素的Vec，并弹出一个元素
let mut v = vec![1, 2];
let two = v.pop();
//创建包含三个元素的可变Vec，并索引一个值和修改一个值
let mut v = vec![1, 2, 3];
let three = v[2];
v[1] = v[1] + 5;
#}</code></pre></pre>
<a class="header" href="print.html#a字符串" id="a字符串"><h2>字符串</h2></a>
<p>Rust 里面有两种字符串类型。<code>String</code> 和 <code>str</code>。</p>
<a class="header" href="print.html#str" id="str"><h3>&amp;str</h3></a>
<p><code>str</code> 类型基本上不怎么使用，通常使用 <code>&amp;str</code> 类型，它其实是 <code>[u8]</code> 类型的切片形式 <code>&amp;[u8]</code>。这是一种固定大小的字符串类型。
常见的的字符串字面值就是 <code>&amp;'static str</code> 类型。这是一种带有 <code>'static</code> 生命周期的 &amp;str 类型。</p>
<p><strong>例子：</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 字符串字面值
let hello = &quot;Hello, world!&quot;;

// 附带显式类型标识
let hello: &amp;'static str = &quot;Hello, world!&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#string" id="string"><h3>String</h3></a>
<p><code>String</code> 是一个带有的 <code>vec:Vec&lt;u8&gt;</code> 成员的结构体，你可以理解为 <code>str</code> 类型的动态形式。
它们的关系相当于 <code>[T]</code> 和 <code>Vec&lt;T&gt;</code> 的关系。
显然 <code>String</code> 类型也有压入和弹出。</p>
<p><strong>例子：</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 创建一个空的字符串
let mut s = String::new();
// 从 `&amp;str` 类型转化成 `String` 类型
let mut hello = String::from(&quot;Hello, &quot;);
// 压入字符和压入字符串切片
hello.push('w');
hello.push_str(&quot;orld!&quot;);

// 弹出字符。
let mut s = String::from(&quot;foo&quot;);
assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('o'));
assert_eq!(s.pop(), Some('f'));
assert_eq!(s.pop(), None);
#}</code></pre></pre>
<a class="header" href="print.html#a结构体与枚举" id="a结构体与枚举"><h1>结构体与枚举</h1></a>
<a class="header" href="print.html#a结构体" id="a结构体"><h2>结构体</h2></a>
<p>结构体 (struct) 是一种记录类型，所包含的每个域 (field) 都有一个名称。
每个结构体也都有一个名称，通常以大写字母开头，使用驼峰命名法。
元组结构体 (tuple struct) 是由元组和结构体混合构成，元组结构体有名称，
但是它的域没有。当元组结构体只有一个域时，称为新类型 (newtype)。
没有任何域的结构体，称为类单元结构体 (unit-like struct)。
结构体中的值默认是不可变的，需要给结构体加上<code>mut</code>使其可变。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// structs
struct Point {
  x: i32,
  y: i32,
}
let point = Point { x: 0, y: 0 };

// tuple structs
struct Color(u8, u8, u8);
let android_green = Color(0xa4, 0xc6, 0x39);
let Color(red, green, blue) = android_green;

// A tuple struct’s constructors can be used as functions.
struct Digit(i32);
let v = vec![0, 1, 2];
let d: Vec&lt;Digit&gt; = v.into_iter().map(Digit).collect();

// newtype: a tuple struct with only one element
struct Inches(i32);
let length = Inches(10);
let Inches(integer_length) = length;

// unit-like structs
struct EmptyStruct;
let empty = EmptyStruct;
#}</code></pre></pre>
<p>一个包含<code>..</code>的<code>struct</code>可以用来从其它结构体拷贝一些值或者在解构时忽略一些域：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Default)]
struct Point3d {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point3d::default();
let point = Point3d { y: 1, ..origin };
let Point3d { x: x0, y: y0, .. } = point;
#}</code></pre></pre>
<p>需要注意，Rust在语言级别不支持域可变性 (field mutability)，所以不能这么写：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    mut x: i32,
    y: i32,
}
#}</code></pre></pre>
<p>这是因为可变性是绑定的一个属性，而不是结构体自身的。可以使用<code>Cell&lt;T&gt;</code>来模拟：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::Cell;

struct Point {
    x: i32,
    y: Cell&lt;i32&gt;,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);
#}</code></pre></pre>
<p>此外，结构体的域对其所在模块 (mod) 之外默认是私有的，可以使用<code>pub</code>关键字将其设置成公开。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod graph {
    #[derive(Default)]
    pub struct Point {
        pub x: i32,
        y: i32,
    }

    pub fn inside_fn() {
        let p = Point {x:1, y:2};
        println!(&quot;{}, {}&quot;, p.x, p.y);
    }
}

fn outside_fn() {
    let p = graph::Point::default();
    println!(&quot;{}&quot;, p.x);
    // println!(&quot;{}&quot;, p.y);
    // field `y` of struct `graph::Point` is private
}
#}</code></pre></pre>
<a class="header" href="print.html#a枚举" id="a枚举"><h2>枚举</h2></a>
<p>Rust有一个集合类型，称为枚举 (enum)，代表一系列子数据类型的集合。
其中子数据结构可以为空-如果全部子数据结构都是空的，就等价于C语言中的enum。
我们需要使用<code>::</code>来获得每个元素的名称。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// enums
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

let x: Message = Message::Move { x: 3, y: 4 };
#}</code></pre></pre>
<p>与结构体一样，枚举中的元素默认不能使用关系运算符进行比较 (如<code>==</code>, <code>!=</code>, <code>&gt;=</code>)，
也不支持像<code>+</code>和<code>*</code>这样的双目运算符，需要自己实现，或者使用<code>match</code>进行匹配。</p>
<p>枚举默认也是私有的，如果使用<code>pub</code>使其变为公有，则它的元素也都是默认公有的。
这一点是与结构体不同的：即使结构体是公有的，它的域仍然是默认私有的。这里的共有/私有仍然
是针对其定义所在的模块之外。此外，枚举和结构体也可以是递归的 (recursive)。</p>
<a class="header" href="print.html#a控制流control-flow" id="a控制流control-flow"><h1>控制流(control flow)</h1></a>
<a class="header" href="print.html#if" id="if"><h2>If</h2></a>
<p>If是分支 (branch) 的一种特殊形式，也可以使用<code>else</code>和<code>else if</code>。
与C语言不同的是，逻辑条件不需要用小括号括起来，但是条件后面必须跟一个代码块。
Rust中的<code>if</code>是一个表达式 (expression)，可以赋给一个变量：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

let y = if x == 5 { 10 } else { 15 };
#}</code></pre></pre>
<p>Rust是基于表达式的编程语言，有且仅有两种语句 (statement)：</p>
<ol>
<li><strong>声明语句</strong> (declaration statement)，比如进行变量绑定的<code>let</code>语句。</li>
<li><strong>表达式语句</strong> (expression statement)，它通过在末尾加上分号<code>;</code>来将表达式变成语句，
丢弃该表达式的值，一律返回unit<code>()</code>。</li>
</ol>
<p>表达式如果返回，总是返回一个值，但是语句不返回值或者返回<code>()</code>，所以以下代码会报错：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let y = (let x = 5);

let z: i32 = if x == 5 { 10; } else { 15; };
#}</code></pre></pre>
<p>值得注意的是，在Rust中赋值 (如<code>x = 5</code>) 也是一个表达式，返回unit的值<code>()</code>。</p>
<a class="header" href="print.html#for" id="for"><h2>For</h2></a>
<p>Rust中的<code>for</code>循环与C语言的风格非常不同，抽象结构如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for var in expression {
    code
}
#}</code></pre></pre>
<p>其中<code>expression</code>是一个迭代器 (iterator)，具体的例子为<code>0..10</code> (不包含最后一个值)，
或者<code>[0, 1, 2].iter()</code>。</p>
<a class="header" href="print.html#while" id="while"><h2>While</h2></a>
<p>Rust中的<code>while</code>循环与C语言中的类似。对于无限循环，Rust有一个专用的关键字<code>loop</code>。
如果需要提前退出循环，可以使用关键字<code>break</code>或者<code>continue</code>，
还允许在循环的开头设定标签 (同样适用于<code>for</code>循环)：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
'outer: loop {
   println!(&quot;Entered the outer loop&quot;);

   'inner: loop {
       println!(&quot;Entered the inner loop&quot;);
       break 'outer;
   }

   println!(&quot;This point will never be reached&quot;);
}

println!(&quot;Exited the outer loop&quot;);
#}</code></pre></pre>
<a class="header" href="print.html#match" id="match"><h2>Match</h2></a>
<p>Rust中的<code>match</code>表达式非常强大，首先看一个例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let day = 5;

match day {
  0 | 6 =&gt; println!(&quot;weekend&quot;),
  1 ... 5 =&gt; println!(&quot;weekday&quot;),
  _ =&gt; println!(&quot;invalid&quot;),
}
#}</code></pre></pre>
<p>其中<code>|</code>用于匹配多个值，<code>...</code>匹配一个范围 (包含最后一个值)，并且<code>_</code>在这里是必须的，
因为<code>match</code>强制进行穷尽性检查 (exhaustiveness checking)，必须覆盖所有的可能值。
如果需要得到<code>|</code>或者<code>...</code>匹配到的值，可以使用<code>@</code>绑定变量：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
#}</code></pre></pre>
<p>使用<code>ref</code>关键字来得到一个引用：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let mut y = 5;

match x {
    // the `r` inside the match has the type `&amp;i32`
    ref r =&gt; println!(&quot;Got a reference to {}&quot;, r),
}

match y {
    // the `mr` inside the match has the type `&amp;i32` and is mutable
    ref mut mr =&gt; println!(&quot;Got a mutable reference to {}&quot;, mr),
}
#}</code></pre></pre>
<p>再看一个使用<code>match</code>表达式来解构元组的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let pair = (0, -2);

match pair {
    (0, y) =&gt; println!(&quot;x is `0` and `y` is `{:?}`&quot;, y),
    (x, 0) =&gt; println!(&quot;`x` is `{:?}` and y is `0`&quot;, x),
    _ =&gt; println!(&quot;It doesn't matter what they are&quot;),
}
#}</code></pre></pre>
<p><code>match</code>的这种解构同样适用于结构体或者枚举。如果有必要，还可以使用<code>..</code>来忽略域或者数据：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}

enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    // 这里是 match 的 if guard 表达式，我们将在以后的章节进行详细介绍
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!(&quot;Got an int bigger than five!&quot;),
    OptionalInt::Value(..) =&gt; println!(&quot;Got an int!&quot;),
    OptionalInt::Missing =&gt; println!(&quot;No such luck.&quot;),
}
#}</code></pre></pre>
<p>此外，Rust还引入了<code>if let</code>和<code>while let</code>进行模式匹配：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let number = Some(7);
let mut optional = Some(0);

// If `let` destructures `number` into `Some(i)`, evaluate the block.
if let Some(i) = number {
    println!(&quot;Matched {:?}!&quot;, i);
} else {
    println!(&quot;Didn't match a number!&quot;);
}

// While `let` destructures `optional` into `Some(i)`, evaluate the block.
while let Some(i) = optional {
    if i &gt; 9 {
        println!(&quot;Greater than 9, quit!&quot;);
        optional = None;
    } else {
        println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
        optional = Some(i + 1);
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a函数与方法" id="a函数与方法"><h1>函数与方法</h1></a>
<a class="header" href="print.html#a函数" id="a函数"><h2>函数</h2></a>
<p>要声明一个函数，需要使用关键字<code>fn</code>，后面跟上函数名，比如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>其中函数参数的类型不能省略，可以有多个参数，但是最多只能返回一个值，
提前返回使用<code>return</code>关键字。Rust编译器会对未使用的函数提出警告，
可以使用属性<code>#[allow(dead_code)]</code>禁用无效代码检查。</p>
<p>Rust有一个特殊特性适用于发散函数 (diverging function)，它不返回：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn diverges() -&gt; ! {
    panic!(&quot;This function never returns!&quot;);
}
#}</code></pre></pre>
<p>其中<code>panic!</code>是一个宏，使当前执行线程崩溃并打印给定信息。返回类型<code>!</code>可用作任何类型：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i32 = diverges();
let y: String = diverges();
#}</code></pre></pre>
<a class="header" href="print.html#a匿名函数" id="a匿名函数"><h2>匿名函数</h2></a>
<p>Rust使用闭包 (closure) 来创建匿名函数：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = 5;
let plus_num = |x: i32| x + num;
#}</code></pre></pre>
<p>其中闭包<code>plus_num</code>借用了它作用域中的<code>let</code>绑定<code>num</code>。如果要让闭包获得所有权，
可以使用<code>move</code>关键字：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;   // 闭包通过move获取了num的所有权

    add_num(5);
}

// 下面的num在被move之后还能继续使用是因为其实现了Copy特性
// 具体可见所有权(Owership)章节
assert_eq!(5, num);
#}</code></pre></pre>
<a class="header" href="print.html#a高阶函数" id="a高阶函数"><h2>高阶函数</h2></a>
<p>Rust 还支持高阶函数 (high order function)，允许把闭包作为参数来生成新的函数：</p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 { x + 1 }

fn apply&lt;F&gt;(f: F, y: i32) -&gt; i32
    where F: Fn(i32) -&gt; i32
{
    f(y) * y
}

fn factory(x: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(move |y| x + y)
}

fn main() {
    let transform: fn(i32) -&gt; i32 = add_one;
    let f0 = add_one(2i32) * 2;
    let f1 = apply(add_one, 2);
    let f2 = apply(transform, 2);
    println!(&quot;{}, {}, {}&quot;, f0, f1, f2);

    let closure = |x: i32| x + 1;
    let c0 = closure(2i32) * 2;
    let c1 = apply(closure, 2);
    let c2 = apply(|x| x + 1, 2);
    println!(&quot;{}, {}, {}&quot;, c0, c1, c2);

    let box_fn = factory(1i32);
    let b0 = box_fn(2i32) * 2;
    let b1 = (*box_fn)(2i32) * 2;
    let b2 = (&amp;box_fn)(2i32) * 2;
    println!(&quot;{}, {}, {}&quot;, b0, b1, b2);

    let add_num = &amp;(*box_fn);
    let translate: &amp;Fn(i32) -&gt; i32 = add_num;
    let z0 = add_num(2i32) * 2;
    let z1 = apply(add_num, 2);
    let z2 = apply(translate, 2);
    println!(&quot;{}, {}, {}&quot;, z0, z1, z2);
}
</code></pre></pre>
<a class="header" href="print.html#a方法" id="a方法"><h2>方法</h2></a>
<p>Rust通过<code>impl</code>关键字在<code>struct</code>、<code>enum</code>或者<code>trait</code>对象上实现方法调用语法 (method call syntax)。
关联函数 (associated function) 的第一个参数通常为<code>self</code>参数，有3种变体：</p>
<ul>
<li><code>self</code>，允许实现者移动和修改对象，对应的闭包特性为<code>FnOnce</code>。</li>
<li><code>&amp;self</code>，既不允许实现者移动对象也不允许修改，对应的闭包特性为<code>Fn</code>。</li>
<li><code>&amp;mut self</code>，允许实现者修改对象但不允许移动，对应的闭包特性为<code>FnMut</code>。</li>
</ul>
<p>不含<code>self</code>参数的关联函数称为静态方法 (static method)。</p>
<pre><pre class="playpen"><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }

    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());

    // use associated function and method chaining
    println!(&quot;{}&quot;, Circle::new(0.0, 0.0, 2.0).area());
}
</code></pre></pre>
<a class="header" href="print.html#a特性" id="a特性"><h1>特性</h1></a>
<a class="header" href="print.html#a特性与接口" id="a特性与接口"><h2>特性与接口</h2></a>
<p>为了描述类型可以实现的抽象接口 (abstract interface)，
Rust引入了特性 (trait) 来定义函数类型签名 (function type signature)：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
#}</code></pre></pre>
<p>其中函数<code>print_area()</code>中的泛型参数<code>T</code>被添加了一个名为<code>HasArea</code>的特性约束 (trait constraint)，
用以确保任何实现了<code>HasArea</code>的类型将拥有一个<code>.area()</code>方法。
如果需要多个特性限定 (multiple trait bounds)，可以使用<code>+</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug
{
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
#}</code></pre></pre>
<p>其中第二个例子使用了更灵活的<code>where</code>从句，它还允许限定的左侧可以是任意类型，
而不仅仅是类型参数。</p>
<p>定义在特性中的方法称为默认方法 (default method)，可以被该特性的实现覆盖。
此外，特性之间也可以存在继承 (inheritance)：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn foo(&amp;self);

    // default method
    fn bar(&amp;self) { println!(&quot;We called bar.&quot;); }
}

// inheritance
trait FooBar : Foo {
    fn foobar(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}
#}</code></pre></pre>
<p>如果两个不同特性的方法具有相同的名称，可以使用通用函数调用语法 (universal function call syntax)：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// short-hand form
Trait::method(args);

// expanded form
&lt;Type as Trait&gt;::method(args);
#}</code></pre></pre>
<p>关于实现特性的几条限制：</p>
<ul>
<li>如果一个特性不在当前作用域内，它就不能被实现。</li>
<li>不管是特性还是<code>impl</code>，都只能在当前的包装箱内起作用。</li>
<li>带有特性约束的泛型函数使用单态化实现 (monomorphization)，
所以它是静态派分的 (statically dispatched)。</li>
</ul>
<p>下面列举几个非常有用的标准库特性：</p>
<ul>
<li><code>Drop</code>提供了当一个值退出作用域后执行代码的功能，它只有一个<code>drop(&amp;mut self)</code>方法。</li>
<li><code>Borrow</code>用于创建一个数据结构时把拥有和借用的值看作等同。</li>
<li><code>AsRef</code>用于在泛型中把一个值转换为引用。</li>
<li><code>Deref&lt;Target=T&gt;</code>用于把<code>&amp;U</code>类型的值自动转换为<code>&amp;T</code>类型。</li>
<li><code>Iterator</code>用于在集合 (collection) 和惰性值生成器 (lazy value generator) 上实现迭代器。</li>
<li><code>Sized</code>用于标记运行时长度固定的类型，而不定长的切片和特性必须放在指针后面使其运行时长度已知，
比如<code>&amp;[T]</code>和<code>Box&lt;Trait&gt;</code>。</li>
</ul>
<a class="header" href="print.html#a泛型和多态" id="a泛型和多态"><h2>泛型和多态</h2></a>
<p>泛型 (generics) 在类型理论中称作参数多态 (parametric polymorphism)，
意为对于给定参数可以有多种形式的函数或类型。先看Rust中的一个泛型例子：</p>
<p>Option在rust标准库中的定义:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>Option的典型用法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: Option&lt;i32&gt; = Some(5);
let y: Option&lt;f64&gt; = Some(5.0f64);
#}</code></pre></pre>
<p>其中<code>&lt;T&gt;</code>部分表明它是一个泛型数据类型。当然，泛型参数也可以用于函数参数和结构体域：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// generic functions
fn make_pair&lt;T, U&gt;(a: T, b: U) -&gt; (T, U) {
    (a, b)
}
let couple = make_pair(&quot;man&quot;, &quot;female&quot;);

// generic structs
struct Point&lt;T&gt; {
    x: T,
    y: T,
}
let int_origin = Point { x: 0, y: 0 };
let float_origin = Point { x: 0.0, y: 0.0 };
#}</code></pre></pre>
<p>对于多态函数，存在两种派分 (dispatch) 机制：静态派分和动态派分。
前者类似于C++的模板，Rust会生成适用于指定类型的特殊函数，然后在被调用的位置进行替换，
好处是允许函数被内联调用，运行比较快，但是会导致代码膨胀 (code bloat)；
后者类似于Java或Go的<code>interface</code>，Rust通过引入特性对象 (trait object) 来实现，
在运行期查找虚表 (vtable) 来选择执行的方法。特性对象<code>&amp;Foo</code>具有和特性<code>Foo</code>相同的名称，
通过转换 (casting) 或者强制多态化 (coercing) 一个指向具体类型的指针来创建。</p>
<p>当然，特性也可以接受泛型参数。但是，往往更好的处理方式是使用关联类型 (associated type)：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// use generic parameters
trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    fn edges(&amp;self, &amp;N) -&gt; Vec&lt;E&gt;;
}

fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 {

}

// use associated types
trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}

fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint {

}

struct Node;

struct Edge;

struct SimpleGraph;

impl Graph for SimpleGraph {
    type N = Node;
    type E = Edge;

    fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {

    }

    fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {

    }
}

let graph = SimpleGraph;
let object = Box::new(graph) as Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;

#}</code></pre></pre>
<a class="header" href="print.html#a注释与文档" id="a注释与文档"><h1>注释与文档</h1></a>
<a class="header" href="print.html#a注释-1" id="a注释-1"><h2>注释</h2></a>
<p>在 Rust 里面注释分成两种，行注释和块注释。它的形式和 C 语言是一样的。
两种注释分别是：</p>
<blockquote>
<ol>
<li>行注释使用 <code>//</code> 放在注释前面。比如:</li>
</ol>
</blockquote>
<pre><code>// I love Rust, but I hate Rustc.
</code></pre>
<blockquote>
<ol start="2">
<li>块注释分别使用<code>/*</code>和<code>*/</code>包裹需要注释的内容。比如：</li>
</ol>
</blockquote>
<pre><code>/* W-Cat 是个大胖猫，N-Cat 是个高度近视猫。*/
</code></pre>
<a class="header" href="print.html#a文档" id="a文档"><h2>文档</h2></a>
<p>Rust 自带有文档功能的注释，分别是<code>///</code>和<code>//!</code>。支持 Markdown 格式</p>
<ol>
<li><code>///</code>用来描述的它后面接着的项。</li>
<li><code>//!</code>用来描述包含它的项，一般用在模块文件的头部。
比如在 main.rs 文件中输入以下内容：</li>
</ol>
<pre><code>        //! # The first line
        //! The second line
        /// Adds one to the number given.
        ///
        /// # Examples
        ///
        /// ```
        /// let five = 5;
        ///
        /// assert_eq!(6, add_one(5));
        /// # fn add_one(x: i32) -&gt; i32 {
        /// #     x + 1
        /// # }
        /// ```
        fn add_one(x: i32) -&gt; i32 {
            x + 1
        }
</code></pre>
<a class="header" href="print.html#a生成-html-文档" id="a生成-html-文档"><h3>生成 html 文档</h3></a>
<ul>
<li><code>rustdoc main.rs</code></li>
</ul>
<p>或者</p>
<ul>
<li><code>cargo doc</code></li>
</ul>
<a class="header" href="print.html#a输入输出流" id="a输入输出流"><h1>输入输出流</h1></a>
<p><strong>输入输出</strong>是人机交互的一种方式。最常见的输入输出是标准输入输出和文件输入输出（当然还有数据库输入输出，本节不讨论这部分）。</p>
<a class="header" href="print.html#a标准输入" id="a标准输入"><h2>标准输入</h2></a>
<p>标准输入也叫作控制台输入，是常见输入的一种。</p>
<p><strong>例子1：</strong></p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn read_input() -&gt; io::Result&lt;()&gt; {
    let mut input = String::new();

    try!(io::stdin().read_line(&amp;mut input));

    println!(&quot;You typed: {}&quot;, input.trim());

    Ok(())
}

fn main() {
    read_input();
}
</code></pre></pre>
<p><strong>例子2：</strong></p>
<pre><pre class="playpen"><code class="language-rust">use std::io;
fn main() {
    let mut input = String::new();

    io::stdin().read_line(&amp;mut input).expect(&quot;WTF!&quot;);

    println!(&quot;You typed: {}&quot;, input.trim());
}
</code></pre></pre>
<p>这里体现了常见的标准输入的处理方式。两个例子都是声明了一个可变的字符串来保存输入的数据。
他们的不同之处在在于处理潜在输入异常的方式。</p>
<ol>
<li>
<p>例子 1 使用了 <code>try!</code> 宏。这个宏会返回 <code>Result&lt;(), io::Error&gt;</code> 类型，<code>io::Result&lt;()&gt;</code> 就是这个类型的别名。所以例子 1 需要单独使用一个 <code>read_input</code> 函数来接收这个类型，而不是在 <code>main</code> 函数里面，因为 <code>main</code> 函数并没有接收 <code>io::Result&lt;()&gt;</code> 作为返回类型。</p>
</li>
<li>
<p>例子 2 使用了 <code>Result&lt;(), io::Error&gt;</code> 类型的 <code>expect</code> 方法来接收 <code>io::stdin().read_line</code> 的返回类型。并处理可能潜在的 io 异常。</p>
</li>
</ol>
<a class="header" href="print.html#a标准输出" id="a标准输出"><h2>标准输出</h2></a>
<p>标准输出也叫控制台输出，Rust 里面常见的标准输出宏有 <code>print!</code> 和 <code>println!</code>。它们的区别是后者比前者在末尾多输出一个换行符。</p>
<p><strong>例子1：</strong></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print!(&quot;this &quot;);
    print!(&quot;will &quot;);
    print!(&quot;be &quot;);
    print!(&quot;on &quot;);
    print!(&quot;the &quot;);
    print!(&quot;same &quot;);
    print!(&quot;line &quot;);

    print!(&quot;this string has a newline, why not choose println! instead?\n&quot;);
}
</code></pre></pre>
<p><strong>例子2：</strong></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;hello there!&quot;);
    println!(&quot;format {} arguments&quot;, &quot;some&quot;);
}
</code></pre></pre>
<p>这里两个例子都比较简单。读者可以运行一下查看输出结果对比一下他们的区别。
值得注意的是例子 2 中，<code>{ }</code> 会被 <code>&quot;some&quot;</code> 所替换。这是 rust 里面的一种格式化输出。</p>
<p>标准化的输出是行缓冲(line-buffered)的,这就导致标准化的输出在遇到一个新行之前并不会被隐式刷新。
换句话说  <code>print!</code> 和 <code>println!</code> 二者的效果并不总是相同的。
如果说得更简单明了一点就是，您不能把 <code>print!</code> 当做是C语言中的 <code>printf</code> 譬如：</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;
fn main() {
    print!(&quot;请输入一个字符串：&quot;);
    let mut input = String::new();
    io::stdin()
        .read_line(&amp;mut input)
        .expect(&quot;读取失败&quot;);
    print!(&quot;您输入的字符串是：{}\n&quot;, input);
}
</code></pre></pre>
<p>在这段代码运行时则不会先出现预期的提示字符串，因为行没有被刷新。
如果想要达到预期的效果就要显示的刷新：</p>
<pre><pre class="playpen"><code class="language-rust">use std::io::{self, Write};
fn main() {
    print!(&quot;请输入一个字符串：&quot;);
    io::stdout().flush().unwrap();
    let mut input = String::new();
    io::stdin()
        .read_line(&amp;mut input)
        .expect(&quot;读取失败&quot;);
    print!(&quot;您输入的字符串是：{}\n&quot;, input);
}
</code></pre></pre>
<a class="header" href="print.html#a文件输入" id="a文件输入"><h2>文件输入</h2></a>
<p>文件输入和标准输入都差不多，除了输入流指向了文件而不是控制台。下面例子采用了模式匹配来处理潜在的输入错误</p>
<p><strong>例子：</strong></p>
<pre><pre class="playpen"><code class="language-rust">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // 创建一个文件路径
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // 打开文件只读模式, 返回一个 `io::Result&lt;File&gt;` 类型
    let mut file = match File::open(&amp;path) {
        // 处理打开文件可能潜在的错误
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display,
                                                   Error::description(&amp;why)),
        Ok(file) =&gt; file,
    };

    // 文件输入数据到字符串，并返回 `io::Result&lt;usize&gt;` 类型
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display,
                                                   Error::description(&amp;why)),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }
}
</code></pre></pre>
<a class="header" href="print.html#a文件输出" id="a文件输出"><h2>文件输出</h2></a>
<p>文件输出和标准库输出也差不多，只不过是把输出流重定向到文件中。下面详细看例子。</p>
<p><strong>例子：</strong></p>
<pre><pre class="playpen"><code class="language-rust">// 输出文本
static LOREM_IPSUM: &amp;'static str =
&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::error::Error;
use std::io::prelude::*;
use std::fs::File;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // 用只写模式打开一个文件，并返回 `io::Result&lt;File&gt;` 类型
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;,
                           display,
                           Error::description(&amp;why)),
        Ok(file) =&gt; file,
    };

    // 写入 `LOREM_IPSUM` 字符串到文件中, 并返回 `io::Result&lt;()&gt;` 类型
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; {
            panic!(&quot;couldn't write to {}: {}&quot;, display,
                                               Error::description(&amp;why))
        },
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre></pre>
<a class="header" href="print.html#rust知识积累" id="rust知识积累"><h1>Rust知识积累</h1></a>
<a class="header" href="print.html#cargo简介" id="cargo简介"><h1>cargo简介</h1></a>
<p>曾几何时，对于使用惯了<code>C/C++</code>语言的猿们来说，项目代码的组织与管理绝对是一场噩梦。为了解决<code>C/C++</code>项目的管理问题，猿神们想尽了各种办法，开发出了各种五花八门的项目管理工具，从一开始的<code>automake</code>到后来的<code>cmake</code>、<code>qmake</code>等等，但结果并不如人意，往往是解决了一些问题，却引入了更多的问题，<code>C/C++</code>猿们经常会陷入在掌握语言本身的同时，还要掌握复杂的构建工具语法的窘境。无独有偶，<code>java</code>的项目代码组织与管理工具<code>ant</code>和<code>maven</code>也存在同样的问题。复杂的项目管理配置参数，往往让猿们不知所措。</p>
<p>作为一门现代语言，<code>rust</code>自然要摒弃石器时代项目代码管理的方法和手段。<code>rust</code>项目组为各位猿提供了超级大杀器<code>cargo</code>，以解决项目代码管理所带来的干扰和困惑。用过<code>node.js</code>的猿们，应该对<code>node.js</code>中的神器<code>npm</code>、<code>grunt</code>、<code>gulp</code>等工具印象深刻。作为新一代静态语言中的翘楚，<code>rust</code>官方参考了现有语言管理工具的优点，于是就产生了<code>cargo</code>。</p>
<p>言而总之，作为<code>rust</code>的代码组织管理工具，<code>cargo</code>提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为<code>rust</code>项目的管理提供尽可能完整的手段。同时，与<code>rust</code>语言及其编译器<code>rustc</code>本身的各种特性紧密结合，可以说既是语言本身的知心爱人，又是<code>rust</code>猿们的贴心小棉袄，谁用谁知道。
废话就不多说了，直接上例子和各种高清无马图。</p>
<a class="header" href="print.html#cargo入门" id="cargo入门"><h1>cargo入门</h1></a>
<p>首先，当然还是废话，要使用cargo，自然首先要安装cargo。安装cargo有三种方法，前两种方法请参见rust的安装方法，因为cargo工具是官方正统出身，当然包含在官方的分发包中。第三种方法即从<a href="https://github.com/rust-lang/cargo"><code>cargo</code></a>项目的源码仓库进行构建。Oh，My God。的确是废话。</p>
<p>好了，假设各位已经安装好了cargo，大家和我一起学一下起手式。当然了，猿的世界，起手式一般都千篇一律——那就是<code>hello world</code>大法。
在终端中输入</p>
<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>
<p>上述命令使用<strong>cargo new</strong>在当前目录下新建了基于cargo项目管理的rust项目，项目名称为hello_world，--bin表示该项目将生成可执行文件。具体生成的项目目录结构如下：</p>
<pre><code class="language-bash">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>大家可以在终端中输入上述命令，敲出回车键之后即可看到上述结果，或者直接去编辑器或文件管理器中去观察即可。
打开main.rs文件，可以看到，cargo new命令为我们自动生成了hello_world运行所必须的所有代码：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>好了，心急的猿们可能已经迫不及待的脱裤子了，好吧，我们先来构建并看看cargo有多神奇，在终端中输入：</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>稍等片刻，cargo会自动为我们构建好高清应用所需的一切，对于这个起手式来说，缓冲不会超过5秒，12秒88的选手要憋住了。</p>
<pre><code class="language-bash">$ cargo run
    Running `target/debug/hello_world`
Hello, world!

</code></pre>
<p>看到了什么，看到了什么，吓尿了有木有，吓尿了有木有。好了，cargo就是这么简单。</p>
<p>当然了，说cargo美，并不仅仅是简单这么简单，cargo虽然简单，但是很强大。有多么强大？？可以说，基本上rust开发管理中所需的手段，cargo都有。很小很强大，既强又有节操，不带马，学习曲线几乎为零。</p>
<a class="header" href="print.html#a基于cargo的rust项目组织结构" id="a基于cargo的rust项目组织结构"><h1>基于cargo的rust项目组织结构</h1></a>
<p>这次不说废话了，先上高清无马图：</p>
<p><img src="../images/project-structure.png" alt="cargo项目组织结构" /></p>
<p>对上述cargo默认的项目结构解释如下：</p>
<a class="header" href="print.html#cargotoml和cargolock文件总是位于项目根目录下" id="cargotoml和cargolock文件总是位于项目根目录下"><h5><code>cargo.toml</code>和<code>cargo.lock</code>文件总是位于项目根目录下。</h5></a>
<a class="header" href="print.html#a源代码位于src目录下" id="a源代码位于src目录下"><h5>源代码位于<code>src</code>目录下。</h5></a>
<a class="header" href="print.html#a默认的库入口文件是srclibrs" id="a默认的库入口文件是srclibrs"><h5>默认的库入口文件是<code>src/lib.rs</code>。</h5></a>
<a class="header" href="print.html#a默认的可执行程序入口文件是srcmainrs" id="a默认的可执行程序入口文件是srcmainrs"><h5>默认的可执行程序入口文件是<code>src/main.rs</code>。</h5></a>
<a class="header" href="print.html#a其他可选的可执行文件位于srcbinrs这里每一个rs文件均对应一个可执行文件" id="a其他可选的可执行文件位于srcbinrs这里每一个rs文件均对应一个可执行文件"><h5>其他可选的可执行文件位于<code>src/bin/*.rs</code>(这里每一个rs文件均对应一个可执行文件)。</h5></a>
<a class="header" href="print.html#a外部测试源代码文件位于tests目录下" id="a外部测试源代码文件位于tests目录下"><h5>外部测试源代码文件位于<code>tests</code>目录下。</h5></a>
<a class="header" href="print.html#a示例程序源代码文件位于examples" id="a示例程序源代码文件位于examples"><h5>示例程序源代码文件位于<code>examples</code>。</h5></a>
<a class="header" href="print.html#a基准测试源代码文件位于benches目录下" id="a基准测试源代码文件位于benches目录下"><h5>基准测试源代码文件位于<code>benches</code>目录下。</h5></a>
<p>好了，大家一定谨记这些默认规则，最好按照这种模式来组织自己的rust项目。</p>
<a class="header" href="print.html#cargotoml和cargolock" id="cargotoml和cargolock"><h1>cargo.toml和cargo.lock</h1></a>
<p><code>cargo.toml</code>和<code>cargo.lock</code>是cargo项目代码管理的核心两个文件，cargo工具的所有活动均基于这两个文件。</p>
<p><code>cargo.toml</code>是cargo特有的项目数据描述文件，对于猿们而言，<code>cargo.toml</code>文件存储了项目的所有信息，它直接面向rust猿，猿们如果想让自己的rust项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建'cargo.toml'。</p>
<p>而<code>cargo.lock</code>文件则不直接面向猿，猿们也不需要直接去修改这个文件。lock文件是cargo工具根据同一项目的toml文件生成的项目依赖详细清单文件，所以我们一般不用不管他，只需要对着<code>cargo.toml</code>文件撸就行了。</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;fuying&quot;]

[dependencies]
</code></pre>
<p>toml文件是由诸如[package]或[dependencies]这样的段落组成，每一个段落又由多个字段组成，这些段落和字段就描述了项目组织的基本信息，例如上述toml文件中的[package]段落描述了<code>hello_world</code>项目本身的一些信息，包括项目名称（对应于name字段）、项目版本（对应于version字段）、作者列表（对应于authors字段）等；[dependencies]段落描述了<code>hello_world</code>项目的依赖项目有哪些。</p>
<p>下面我们来看看toml描述文件中常用段落和字段的意义。</p>
<a class="header" href="print.html#package段落" id="package段落"><h1>package段落</h1></a>
<p>[package]段落描述了软件开发者对本项目的各种元数据描述信息，例如[name]字段定义了项目的名称，[version]字段定义了项目的当前版本，[authors]定义了该项目的所有作者，当然，[package]段落不仅仅包含这些字段，[package]段落的其他可选字段详见cargo参数配置章节。</p>
<a class="header" href="print.html#a定义项目依赖" id="a定义项目依赖"><h1>定义项目依赖</h1></a>
<p>使用cargo工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。这也是使用cargo对rust 的项目进行管理的重要目标之一。在cargo的toml文件描述中，主要通过各种依赖段落来描述该项目的各种依赖项。toml中常用的依赖段落包括一下几种：</p>
<ul>
<li>基于rust官方仓库crates.io，通过版本说明来描述：</li>
<li>基于项目源代码的git仓库地址，通过URL来描述：</li>
<li>基于本地项目的绝对路径或者相对路径，通过类Unix模式的路径来描述：
这三种形式具体写法如下：</li>
</ul>
<pre><code class="language-toml">[dependencies]
typemap = &quot;0.3&quot;
plugin = &quot;0.2*&quot;
hammer = { version = &quot;0.5.0&quot;}
color = { git = &quot;https://github.com/bjz/color-rs&quot; }
geometry = { path = &quot;crates/geometry&quot; }
</code></pre>
<p>上述例子中，2-4行为方法一的写法，第5行为方法二的写法，第6行为方法三的写法。
这三种写法各有用处，如果项目需要使用crates.io官方仓库来管理项目依赖项，推荐使用第一种方法。如果项目开发者更倾向于使用git仓库中最新的源码，可以使用方法二。方法二也经常用于当官方仓库的依赖项编译不通过时的备选方案。方法三主要用于源代码位于本地的依赖项。</p>
<a class="header" href="print.html#a定义集成测试用例" id="a定义集成测试用例"><h1>定义集成测试用例</h1></a>
<p>cargo另一个重要的功能，即将软件开发过程中必要且非常重要的测试环节进行集成，并通过代码属性声明或者toml文件描述来对测试进行管理。其中，单元测试主要通过在项目代码的测试代码部分前用<code>#[test]</code>属性来描述，而集成测试，则一般都会通过toml文件中的[[test]]段落进行描述。
例如，假设集成测试文件均位于tests文件夹下，则toml可以这样来写：</p>
<pre><code class="language-toml">[[test]]
name = &quot;testinit&quot;
path = &quot;tests/testinit.rs&quot;

[[test]]
name = &quot;testtime&quot;
path = &quot;tests/testtime.rs&quot;
</code></pre>
<p>上述例子中，name字段定义了集成测试的名称，path字段定义了集成测试文件相对于本toml文件的路径。
看看，定义集成测试就是如此简单。
需要注意的是:</p>
<ul>
<li>如果没有在Cargo.toml里定义集成测试的入口，那么tests目录(不包括子目录)下的每个rs文件被当作集成测试入口.</li>
<li>如果在Cargo.toml里定义了集成测试入口，那么定义的那些rs就是入口，不再默认指定任何集成测试入口.</li>
</ul>
<a class="header" href="print.html#a定义项目示例和可执行程序" id="a定义项目示例和可执行程序"><h1>定义项目示例和可执行程序</h1></a>
<p><strong>上面我们介绍了cargo项目管理中常用的三个功能，还有两个经常使用的功能：example用例的描述以及bin用例的描述。其描述方法和test用例描述方法类似。不过，这时候段落名称'[[test]]'分别替换为：'[[example]]'或者'[[bin]]'。例如：</strong></p>
<pre><code class="language-toml">[[example]]
name = &quot;timeout&quot;
path = &quot;examples/timeout.rs&quot;

[[bin]]
name = &quot;bin1&quot;
path = &quot;bin/bin1.rs&quot;

</code></pre>
<p>对于'[[example]]'和'[[bin]]'段落中声明的examples和bins，需要通过'cargo run --example NAME'或者'cargo run --bin NAME'来运行，其中NAME对应于你在name字段中定义的名称。</p>
<a class="header" href="print.html#a构建清理更新以及安装" id="a构建清理更新以及安装"><h1>构建、清理、更新以及安装</h1></a>
<p>领会了toml描述文件的写法，是一个重要的方面。另一个重要的方面，就是cargo工具本身为我们程序猿提供的各种好用的工具。如果大家感兴趣，自己在终端中输入'cargo --help'查看即可。其中开发时最常用的命令就是'cargo build'，用于构建项目。此外，'cargo clean'命令可以清理target文件夹中的所有内容；'cargo update'根据toml描述文件重新检索并更新各种依赖项的信息，并写入lock文件，例如依赖项版本的更新变化等等；'cargo install'可用于实际的生产部署。这些命令在实际的开发部署中均是非常有用的。</p>
<p><strong>cargo更多详细用法请参见<a href="../cargo-detailed-cfg/cargo-detailed-cfg.md">'28. cargo参数配置'</a></strong></p>
<a class="header" href="print.html#cargo-详细配置" id="cargo-详细配置"><h1>Cargo 详细配置</h1></a>
<p>我们一起探讨了cargo的一些常用的基本技能。cargo非常好，而且非常强大。</p>
<p>我们将深入探讨cargo的一些细节问题，这包括以下几个方面：</p>
<ul>
<li>基于语义化版本的项目版本声明与管理</li>
<li><code>cargo</code>的<code>toml</code>描述文件配置字段详细参考</li>
</ul>
<a class="header" href="print.html#a基于语义化版本的项目版本声明与管理" id="a基于语义化版本的项目版本声明与管理"><h2>基于语义化版本的项目版本声明与管理</h2></a>
<p>我们在使用toml描述文件对项目进行配置时，经常会遇到项目版本声明及管理的问题，比如：</p>
<pre><code class="language-toml">[package]
name = &quot;libevent_sys&quot;
version = &quot;0.1.0&quot;

[dependencies]
libc = &quot;0.2&quot;

</code></pre>
<p>这里package段落中的version字段的值，以及dependencies段落中的libc字段的值，这些值的写法，都涉及到语义化版本控制的问题。语义化版本控制是用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。简单来说，语义化版本控制遵循下面这些规则：</p>
<ul>
<li>
<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>
</li>
</ul>
<ol>
<li>
<p>主版本号：当你做了不兼容的 API 修改；</p>
</li>
<li>
<p>次版本号：当你做了向下兼容的功能性新增；</p>
</li>
<li>
<p>修订号：当你做了向下兼容的问题修正；</p>
</li>
</ol>
<ul>
<li>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</li>
</ul>
<p>关于语义化版本控制的具体细节问题，大家可以参考</p>
<ul>
<li><a href="./semver-ver-2.0-zh.md">语义化版本文档 2.0</a></li>
<li><a href="http://semver.org/lang/zh-CN/">http://semver.org/lang/zh-CN/</a></li>
</ul>
<p>我不再赘述。</p>
<a class="header" href="print.html#cargo的toml描述文件配置字段详细参考" id="cargo的toml描述文件配置字段详细参考"><h2>cargo的toml描述文件配置字段详细参考</h2></a>
<a class="header" href="print.html#package-软件包" id="package-软件包"><h3>[package] 软件包</h3></a>
<p>啥也不多说了，直接上例子，大家注意我在例子中的中文解释，个人觉得这样比较一目了然：</p>
<pre><code class="language-toml">[package]
 # 软件包名称，如果需要在别的地方引用此软件包，请用此名称。
name = &quot;hello_world&quot;

# 当前版本号，这里遵循semver标准，也就是语义化版本控制标准。
version = &quot;0.1.0&quot;    # the current version, obeying semver

# 软件所有作者列表
authors = [&quot;you@example.com&quot;]

# 非常有用的一个字段，如果要自定义自己的构建工作流，
# 尤其是要调用外部工具来构建其他本地语言（C、C++、D等）开发的软件包时。
# 这时，自定义的构建流程可以使用rust语言，写在&quot;build.rs&quot;文件中。
build = &quot;build.rs&quot;

# 显式声明软件包文件夹内哪些文件被排除在项目的构建流程之外，
# 哪些文件包含在项目的构建流程中
exclude = [&quot;build/**/*.o&quot;, &quot;doc/**/*.html&quot;]
include = [&quot;src/**/*&quot;, &quot;Cargo.toml&quot;]

# 当软件包在向公共仓库发布时出现错误时，使能此字段可以阻止此错误。
publish = false

# 关于软件包的一个简短介绍。
description = &quot;...&quot;

# 下面这些字段标明了软件包仓库的更多信息
documentation = &quot;...&quot;
homepage = &quot;...&quot;
repository = &quot;...&quot;

# 顾名思义，此字段指向的文件就是传说中的ReadMe，
# 并且，此文件的内容最终会保存在注册表数据库中。
readme = &quot;...&quot;

# 用于分类和检索的关键词。
keywords = [&quot;...&quot;, &quot;...&quot;]

# 软件包的许可证，必须是cargo仓库已列出的已知的标准许可证。
license = &quot;...&quot;

# 软件包的非标许可证书对应的文件路径。
license-file = &quot;...&quot;

</code></pre>
<a class="header" href="print.html#dependencies-依赖的详细配置" id="dependencies-依赖的详细配置"><h3>[dependencies] 依赖的详细配置</h3></a>
<p>最直接的方式在之前第五章探讨过，例如这样：</p>
<pre><code class="language-toml">[dependencies]
hammer = &quot;0.5.0&quot;
color = &quot;&gt; 0.6.0, &lt; 0.8.0&quot;
</code></pre>
<p>与平台相关的依赖定义格式不变，不同的是需要定义在[target]字段下。例如：</p>
<pre><code class="language-toml"># 注意，此处的cfg可以使用not、any、all等操作符任意组合键值对。
# 并且此用法仅支持cargo 0.9.0（rust 1.8.0）以上版本。
# 如果是windows平台，则需要此依赖。
[target.'cfg(windows)'.dependencies]
winhttp = &quot;0.4.0&quot;

[target.'cfg(unix)'.dependencies]
openssl = &quot;1.0.1&quot;

#如果是32位平台，则需要此依赖。
[target.'cfg(target_pointer_width = &quot;32&quot;)'.dependencies]
native = { path = &quot;native/i686&quot; }

[target.'cfg(target_pointer_width = &quot;64&quot;)'.dependencies]
native = { path = &quot;native/i686&quot; }

# 另一种写法就是列出平台的全称描述
[target.x86_64-pc-windows-gnu.dependencies]
winhttp = &quot;0.4.0&quot;
[target.i686-unknown-linux-gnu.dependencies]
openssl = &quot;1.0.1&quot;

# 如果使用自定义平台，请将自定义平台文件的完整路径用双引号包含
[target.&quot;x86_64/windows.json&quot;.dependencies]
winhttp = &quot;0.4.0&quot;
[target.&quot;i686/linux.json&quot;.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/i686&quot; }
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/x86_64&quot; }

# [dev-dependencies]段落的格式等同于[dependencies]段落，
# 不同之处在于，[dependencies]段落声明的依赖用于构建软件包，
# 而[dev-dependencies]段落声明的依赖仅用于构建测试和性能评估。
# 此外，[dev-dependencies]段落声明的依赖不会传递给其他依赖本软件包的项目
[dev-dependencies]
iron = &quot;0.2&quot;

</code></pre>
<a class="header" href="print.html#profile-自定义编译器调用方式模板详细参数" id="profile-自定义编译器调用方式模板详细参数"><h3>[profile] 自定义编译器调用方式模板详细参数</h3></a>
<p>cargo内置五种编译器调用模板，分别为dev、release、test、bench、doc，分别用于定义不同类型生成目标时的编译器参数，如果我们自己想改变这些编译模板，可以自己定义相应字段的值，例如（注意：下述例子中列出的值均为此模板字段对应的系统默认值）：</p>
<pre><code class="language-toml"># 开发模板, 对应`cargo build`命令
[profile.dev]
opt-level = 0  # 控制编译器的 --opt-level 参数，也就是优化参数。当前优化参数有三个级别 0，1，2, 3  级别0相当于debug模式， 级别3相当于release模式
debug = true   # 控制编译器是否开启 `-g` 参数
rpath = false  # 控制编译器的 `-C rpath` 参数
lto = false    # 控制`-C lto` 参数，此参数影响可执行文件和静态库的生成，
debug-assertions = true  # 控制调试断言是否开启
codegen-units = 1 # 控制编译器的 `-C codegen-units` 参数。注意，当`lto = true`时，此字段值被忽略

# 发布模板, 对应`cargo build --release`命令
[profile.release]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 1

# 测试模板，对应`cargo test`命令
[profile.test]
opt-level = 0
debug = true
rpath = false
lto = false
debug-assertions = true
codegen-units = 1

# 性能评估模板，对应`cargo bench`命令
[profile.bench]
opt-level = 3
debug = false
rpath = false
lto = false
debug-assertions = false
codegen-units = 1

# 文档模板，对应`cargo doc`命令
[profile.doc]
opt-level = 0
debug = true
rpath = false
lto = false
debug-assertions = true
codegen-units = 1

</code></pre>
<p>需要注意的是，当调用编译器时，只有位于调用最顶层的软件包的模板文件有效，其他的子软件包或者依赖软件包的模板定义将被顶层软件包的模板覆盖。</p>
<a class="header" href="print.html#features-段落" id="features-段落"><h3>[features] 段落</h3></a>
<p>[features] 段落中的字段被用于条件编译选项或者是可选依赖。例如：</p>
<pre><code class="language-toml">[package]
name = &quot;awesome&quot;

[features]
# 此字段设置了可选依赖的默认选择列表，
# 注意这里的&quot;session&quot;并非一个软件包名称，
# 而是另一个featrue字段session
default = [&quot;jquery&quot;, &quot;uglifier&quot;, &quot;session&quot;]

# 类似这样的值为空的feature一般用于条件编译，
# 类似于`#[cfg(feature = &quot;go-faster&quot;)]`。
go-faster = []

# 此feature依赖于bcrypt软件包，
# 这样封装的好处是未来可以对secure-password此feature增加可选项目。
secure-password = [&quot;bcrypt&quot;]

# 此处的session字段导入了cookie软件包中的feature段落中的session字段
session = [&quot;cookie/session&quot;]

[dependencies]
# 必要的依赖
cookie = &quot;1.2.0&quot;
oauth = &quot;1.1.0&quot;
route-recognizer = &quot;=2.1.0&quot;

# 可选依赖
jquery = { version = &quot;1.0.2&quot;, optional = true }
uglifier = { version = &quot;1.5.3&quot;, optional = true }
bcrypt = { version = &quot;*&quot;, optional = true }
civet = { version = &quot;*&quot;, optional = true }
</code></pre>
<p>如果其他软件包要依赖使用上述awesome软件包，可以在其描述文件中这样写：</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # 禁用awesome 的默认features
features = [&quot;secure-password&quot;, &quot;civet&quot;] # 使用此处列举的各项features
</code></pre>
<p>使用features时需要遵循以下规则：</p>
<ul>
<li>feature名称在本描述文件中不能与出现的软件包名称冲突</li>
<li>除了default feature，其他所有的features均是可选的</li>
<li>features不能相互循环包含</li>
<li>开发依赖包不能包含在内</li>
<li>features组只能依赖于可选软件包</li>
</ul>
<p>features的一个重要用途就是，当开发者需要对软件包进行最终的发布时，在进行构建时可以声明暴露给终端用户的features，这可以通过下述命令实现：</p>
<pre><code class="language-shellscript">cargo build --release --features &quot;shumway pdf&quot;
</code></pre>
<a class="header" href="print.html#a关于测试" id="a关于测试"><h3>关于测试</h3></a>
<p>当运行<code>cargo test</code>命令时，cargo将会按做以下事情：</p>
<pre><code class="language-shell">cargo test
</code></pre>
<ul>
<li>编译并运行软件包源代码中被#[cfg(test)] 所标志的单元测试</li>
<li>编译并运行文档测试</li>
<li>编译并运行集成测试</li>
<li>编译examples</li>
</ul>
<a class="header" href="print.html#a配置构建目标" id="a配置构建目标"><h3>配置构建目标</h3></a>
<p>所有的诸如[[bin]], [lib], [[bench]], [[test]] 以及 [[example]]等字段，均提供了类似的配置，以说明构建目标应该怎样被构建。例如（下述例子中[lib]段落中各字段值均为默认值）：</p>
<pre><code class="language-toml">[lib]
# 库名称，默认与项目名称相同
name = &quot;foo&quot;

# 此选项仅用于[lib]段落，其决定构建目标的构建方式，
# 可以取dylib, rlib, staticlib 三种值之一，表示生成动态库、r库或者静态库。
crate-type = [&quot;dylib&quot;]

# path字段声明了此构建目标相对于cargo.toml文件的相对路径
path = &quot;src/lib.rs&quot;

# 单元测试开关选项
test = true

# 文档测试开关选项
doctest = true

# 性能评估开关选项
bench = true

# 文档生成开关选项
doc = true

# 是否构建为编译器插件的开关选项
plugin = false

# 如果设置为false，`cargo test`将会忽略传递给rustc的--test参数。
harness = true
</code></pre>
<a class="header" href="print.html#cargoio" id="cargoio"><h1>Cargo.io</h1></a>
<a class="header" href="print.html#a注释-2" id="a注释-2"><h1>注释</h1></a>
<p>Rust 代码文件中，通常我们可以看到 3 种注释。</p>
<ul>
<li>行注释</li>
<li>文档注释</li>
<li>模块注释</li>
</ul>
<a class="header" href="print.html#a行注释" id="a行注释"><h2>行注释</h2></a>
<p><code>//</code> 后的，直到行尾，都属于注释，不会影响程序的行为。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 创建一个绑定, 把 5 绑定到 x
let x = 5;

let y = 6; // 创建另一个绑定
#}</code></pre></pre>
<a class="header" href="print.html#a文档注释" id="a文档注释"><h2>文档注释</h2></a>
<p>文档注释使用 <code>///</code>，一般用于函数或结构体（字段）的说明，置于要说明的对象上方。文档注释内部可使用markdown格式的标记语法，可用于 rustdoc 工具的自动文档提取。</p>
<pre><code>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// # fn add_one(x: i32) -&gt; i32 {
/// #     x + 1
/// # }
/// ```
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<a class="header" href="print.html#a模块注释" id="a模块注释"><h2>模块注释</h2></a>
<p>模块注释使用 <code>//!</code>，用于说明本模块的功能。一般置于模块文件的头部。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.
#}</code></pre></pre>
<p>PS: 相对于 <code>///</code>, <code>//!</code> 用来注释包含它的项（也就是说，crate，模块或者函数），而不是位于它之后的项。</p>
<a class="header" href="print.html#a其它兼容c语言的注释" id="a其它兼容c语言的注释"><h2>其它：兼容C语言的注释</h2></a>
<p>Rust 也支持兼容 C 的块注释写法：<code>/* */</code>。但是不推荐使用，请尽量不要使用这种注释风格（会被鄙视的）。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/*
    let x = 42;
    println!(&quot;{}&quot;, x);
*/
#}</code></pre></pre>
<a class="header" href="print.html#a关键字" id="a关键字"><h1>关键字</h1></a>
<p>The following list contains keywords that are reserved for current or future use by the <code>Rust</code> language.
As such, they cannot be used as identifiers (except as raw identifiers), including names of <code>functions</code>, <code>variables</code>, <code>parameters</code>, <code>struct fields</code>, <code>modules</code>, <code>crates</code>, <code>constants</code>, <code>macros</code>, <code>static values</code>, <code>attributes</code>, <code>types</code>, <code>traits</code>, or <code>lifetimes</code>.</p>
<p>下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了 [原始标识符][raw-identifiers]），这包括函数、变量、参数、结构体字段、模块、crate、常量、宏、静态值、属性、类型、trait 或生命周期
的名字。</p>
<ol>
<li><strong>abstract</strong> -</li>
<li><strong>as</strong> - perform primitive casting, disambiguate the specific trait containing an item, or rename items in use and extern crate statements. 强制原生类型转换，消除特定包含项的 trait 的歧义，或者对 <code>use</code> 和 <code>extern crate</code> 语句中的项重命名</li>
<li><strong>async</strong> -</li>
<li><strong>become</strong> -</li>
<li><strong>box</strong> -</li>
<li><strong>break</strong> - exit a loop immediately. 立刻退出或跳出循环</li>
<li><strong>const</strong> - define constant items or constant raw pointers. 定义常量或不变裸指针（constant raw pointer）</li>
<li><strong>continue</strong> - continue to the next loop iteration. 继续进入下一次循环迭代</li>
<li><strong>crate</strong> - link an external crate or a macro variable representing the crate in which the macro is defined. 链接（link）一个外部 <strong>crate</strong> 或一个代表宏定义的 <strong>crate</strong> 的宏变量</li>
<li><strong>do</strong> -</li>
<li><strong>dyn</strong> - dynamic dispatch to a trait object. 动态分发 trait 对象</li>
<li><strong>else</strong> - fallback for if and if let control flow constructs. 作为 <code>if</code> 和 <code>if let</code> 控制流结构的 fallback</li>
<li><strong>enum</strong> - define an enumeration. 定义一个枚举</li>
<li><strong>extern</strong> - link an external crate, function, or variable. 链接一个外部 <strong>crate</strong> 、函数或变量</li>
<li><strong>false</strong> - Boolean false literal. 布尔字面值 <code>false</code></li>
<li><strong>final</strong> -</li>
<li><strong>fn</strong> - define a function or the function pointer type. 定义一个函数或 <strong>函数指针类型</strong> (<em>function pointer type</em>)</li>
<li><strong>for</strong> - loop over items from an iterator, implement a trait, or specify a higher-ranked lifetime. 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期</li>
<li><strong>if</strong> - branch based on the result of a conditional expression. 基于条件表达式的结果分支</li>
<li><strong>impl</strong> - implement inherent or trait functionality. 实现自有或 trait 功能</li>
<li><strong>in</strong> - part of for loop syntax. <code>for</code> 循环语法的一部分</li>
<li><strong>let</strong> - bind a variable. 绑定一个变量</li>
<li><strong>loop</strong> - loop unconditionally. 无条件循环</li>
<li><strong>macro</strong> - macro 宏</li>
<li><strong>match</strong> - match a value to patterns. 模式匹配</li>
<li><strong>mod</strong> - define a module. 定义一个模块</li>
<li><strong>move</strong> - make a closure take ownership of all its captures. 使闭包获取其所捕获项的所有权</li>
<li><strong>mut</strong> - denote mutability in references, raw pointers, or pattern bindings. 表示引用、裸指针或模式绑定的可变性性</li>
<li><strong>override</strong> -</li>
<li><strong>priv</strong> -</li>
<li><strong>pub</strong> - denote public visibility in struct fields, impl blocks, or modules. 表示结构体字段、<code>impl</code> 块或模块的公有可见性</li>
<li><strong>ref</strong> - bind by reference. 通过引用绑定</li>
<li><strong>return</strong> - return from function. 从函数中返回</li>
<li><strong>Self</strong> - a type alias for the type implementing a trait. 实现 trait 的类型的类型别名</li>
<li><strong>self</strong> - method subject or current module. 表示方法本身或当前模块</li>
<li><strong>static</strong> - global variable or lifetime lasting the entire program execution. 表示全局变量或在整个程序执行期间保持其生命周期</li>
<li><strong>struct</strong> - define a structure. 定义一个结构体</li>
<li><strong>super</strong> - parent module of the current module. 表示当前模块的父模块</li>
<li><strong>trait</strong> - define a trait.  定义一个 trait</li>
<li><strong>true</strong> - Boolean true literal. 布尔字面值 <code>true</code></li>
<li><strong>try</strong> -</li>
<li><strong>type</strong> - 定义一个类型别名或关联类型</li>
<li><strong>typeof</strong> -</li>
<li><strong>unsafe</strong> - denote unsafe code, functions, traits, or implementations. 表示不安全的代码、函数、trait 或实现</li>
<li><strong>unsized</strong> -</li>
<li><strong>use</strong> - bring symbols into scope. 引入外部空间的符号</li>
<li><strong>virtual</strong> -</li>
<li><strong>where</strong> - denote clauses that constrain a type. 表示一个约束类型的从句</li>
<li><strong>while</strong> - loop conditionally based on the result of an expression. 基于一个表达式的结果判断是否进行循环</li>
<li><strong>yield</strong> -</li>
</ol>
<a class="header" href="print.html#a原始标识符-raw-identifiers" id="a原始标识符-raw-identifiers"><h2>原始标识符 Raw identifiers</h2></a>
<p>Raw identifiers let you use keywords where they would not normally be allowed by prefixing them with <em>r#</em>.</p>
<p>原始标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 <code>r#</code> 前缀。</p>
<p>例如，<code>match</code> 是关键字。如果尝试编译这个函数：</p>
<pre><code class="language-rust ignore">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>会得到这个错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>可以通过原始标识符编写：</p>
<pre><pre class="playpen"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>注意 <code>r#</code> 前缀需同时用于函数名和调用。</p>
<a class="header" href="print.html#a动机" id="a动机"><h2>动机</h2></a>
<p>出于一些原因这个功能是实用的，不过其主要动机是解决跨版本问题。比如，<code>try</code> 在 2015 edition 中不是关键字，而在 2018 edition 则是。所以如果如果用 2015 edition 编写的库中带有 <code>try</code> 函数，在 2018 edition 中调用时就需要使用原始标识符。</p>
<a class="header" href="print.html#a栈stack与堆heap" id="a栈stack与堆heap"><h1>栈（Stack）与堆（Heap）</h1></a>
<a class="header" href="print.html#a简介-2" id="a简介-2"><h2>简介</h2></a>
<p>堆和栈是计算机里面最基本的概念，不过如果一直使用高级语言如 Python/Go/Ruby/PHP/Java 等之类的语言的话，可能对堆和栈并不怎么理解，当然这里的栈(Stack)并不是数据结构里面的概念，而是计算机对内存的一个抽象。相比而言，C/C++/Rust 这些语言就必须对堆和栈的概念非常了解才能写出正确的程序，之所以有这样的区别是因为它们的内存管理方式不同，Python 之类的语言程序运行时会同时会运行垃圾回收器，垃圾回收器与用户程序或并行执行或交错执行，垃圾回收器会自动释放不再使用的内存空间，而 C/C++/Rust 则没有垃圾回收器。</p>
<p>操作系统会将物理内存映射成虚拟地址空间，程序在启动时看到的虚拟地址空间是一块完整连续的内存。</p>
<p>栈内存从高位地址向下增长，且栈内存分配是连续的，一般操作系统对栈内存大小是有限制的，Linux/Unix 类系统上面可以通过 ulimit 设置最大栈空间大小，所以 C 语言中无法创建任意长度的数组。在Rust里，函数调用时会创建一个临时栈空间，调用结束后 Rust 会让这个栈空间里的对象自动进入 <code>Drop</code> 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的。</p>
<p>相对地，堆上内存则是从低位地址向上增长，堆内存通常只受物理内存限制，而且通常是不连续的，一般由程序员手动申请和释放的，如果想申请一块连续内存，则操作系统需要在堆中查找一块未使用的满足大小的连续内存空间，故其效率比栈要低很多，尤其是堆上如果有大量不连续内存时。另外内存使用完也必须由程序员手动释放，不然就会出现内存泄漏，内存泄漏对需要长时间运行的程序(例如守护进程)影响非常大。</p>
<blockquote>
<a class="header" href="print.html#a栈stack与堆heap-1" id="a栈stack与堆heap-1"><h3>栈（Stack）与堆（Heap）</h3></a>
<p>在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。</p>
<p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 <strong>进栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。</p>
<p>栈的操作是十分快速的，这主要是得益于它存取数据的方式：因为数据存取的位置总是在栈顶而不需要寻找一个位置存放或读取数据。另一个让操作栈快速的属性是，栈中的所有数据都必须占用已知且固定的大小。</p>
<p>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。</p>
<p>想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。</p>
<p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。</p>
<p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p>
<p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p>
</blockquote>
<a class="header" href="print.html#a类型运算符和字符串" id="a类型运算符和字符串"><h1>类型、运算符和字符串</h1></a>
<p>本章讲解 Rust 中的类型相关基础知识、运算符相关知识、和字符串的基本知识。</p>
<a class="header" href="print.html#a原生类型" id="a原生类型"><h1>原生类型</h1></a>
<p>像其他现代编程语言一样，Rust提供了一系列基础的类型，我们一般称之为<em>原生类型</em>。其强大的类型系统就是建立在这些原生类型之上的，因此，在写Rust代码之前，必须要对Rust的原生类型有一定的了解。</p>
<a class="header" href="print.html#bool" id="bool"><h2>bool</h2></a>
<p>Rust自带了<code>bool</code>类型，其可能值为<code>true</code>或者<code>false</code>。
我们可以通过这样的方式去声明它：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let is_she_love_me = false;
let mut is_he_love_me: bool = true;
#}</code></pre></pre>
<p>当然，bool类型被用的最多的地方就是在<code>if表达式</code>里了。</p>
<a class="header" href="print.html#char" id="char"><h2>char</h2></a>
<p>在Rust中，一个<code>char</code>类型表示一个<em>Unicode</em>字符,这也就意味着，在某些语言里代表一个字符(8bit)的char，在Rust里实际上是四个字节(32bit)。
同时，我们可以将各种奇怪的非中文字符随心所欲的赋值给一个char类型。需要注意的是，Rust中我们要用<code>'</code>来表示一个char，如果用<code>&quot;</code>的话你得到的实际上是一个<code>&amp;'static str</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let c = 'x';
let cc = '王';
#}</code></pre></pre>
<a class="header" href="print.html#a数字类型" id="a数字类型"><h2>数字类型</h2></a>
<p>和其他类C系的语言不一样，Rust用一种<em>符号+位数</em>的方式来表示其基本的数字类型。可能你习惯了<code>int</code>、<code>double</code>、<code>float</code>之类的表示法，Rust的表示法需要你稍微适应一下。</p>
<p>你可用的符号有 <code>i</code>、<code>f</code>、<code>u</code></p>
<p>你可用的位数，当然了，都是2的n次幂，分别为<code>8</code>、<code>16</code>、<code>32</code>、<code>64</code>及<code>size</code>。</p>
<p>你可以将其组合起来，形成诸如<code>i32</code>,<code>u16</code>等类型。</p>
<p>当然了，这样的组合并不自由，因为浮点类型最少只能用32位来表示，因此只能有<code>f32</code>和<code>f64</code>来表示。</p>
<a class="header" href="print.html#a自适应类型" id="a自适应类型"><h3>自适应类型</h3></a>
<p>看完上面你一定会对<code>isize</code>和<code>usize</code>很好奇。这两个是来干啥的。这两个嘛，其实是取决于你的操作系统的位数。简单粗暴一点比如64位电脑上就是64位，32位电脑上就是32位，16位……呵呵哒。</p>
<p>但是需要注意的是，你不能因为你的电脑是64位的，而强行将它等同于64，也就是说<code>isize != i64</code>，任何情况下你都需要强制转换。</p>
<a class="header" href="print.html#a数组-array-1" id="a数组-array-1"><h2>数组 array</h2></a>
<p>Rust的数组是被表示为<code>[T;N]</code>。其中N表示数组大小，并且这个大小一定是个编译时就能获得的整数值，T表示<code>泛型</code>类型，即任意类型。我们可以这么来声明和使用一个数组:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [8, 9, 10];
let b: [u8;3] = [8, 6, 5];
print!(&quot;{}&quot;, a[0]);
#}</code></pre></pre>
<p>和Golang一样，Rust的数组中的<code>N</code>（大小）也是类型的一部分，即<code>[u8; 3] != [u8; 4]</code>。这么设计是为了更安全和高效的使用内存，当然了，这会给第一次接触类似概念的人带来一点点困难，比如以下代码。</p>
<pre><pre class="playpen"><code class="language-rust">fn show(arr: [u8;3]) {
    for i in &amp;arr {
        print!(&quot;{} &quot;, i);
    }
}

fn main() {
    let a: [u8; 3] = [1, 2, 3];
    show(a);
    let b: [u8; 4] = [1, 2, 3, 4];
    show(b);
}
</code></pre></pre>
<p>编译运行它你将获得一个编译错误：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
&lt;anon&gt;:11:10: 11:11 error: mismatched types:
 expected `[u8; 3]`,
    found `[u8; 4]`
(expected an array with a fixed size of 3 elements,
    found one with 4 elements) [E0308]
&lt;anon&gt;:11     show(b);
                   ^
&lt;anon&gt;:11:10: 11:11 help: see the detailed explanation for E0308
error: aborting due to previous error
#}</code></pre></pre>
<p>这是因为你将一个4长度的数组赋值给了一个只需要3长度数组作为参数的函数。那么如何写一个通用的show方法来展现任意长度数组呢？请看下节<code>Slice</code></p>
<a class="header" href="print.html#slice" id="slice"><h2>Slice</h2></a>
<p><code>Slice</code>从直观上讲，是对一个<code>Array</code>的切片，通过<code>Slice</code>，你能获取到一个<code>Array</code>的部分或者全部的访问权限。和<code>Array</code>不同，<code>Slice</code>是可以动态的，但是呢，其范围是不能超过<code>Array</code>的大小，这点和Golang是不一样的。</p>
<p>一个<code>Slice</code>的表达式可以为如下: <code>&amp;[T]</code> 或者 <code>&amp;mut [T]</code>。</p>
<p>这里<code>&amp;</code>符号是一个难点，我们不妨先不要关注这个符号，简单的把它看成是<code>Slice</code>的甲鱼臀部——规定。另外，同样的，<code>Slice</code>也是可以通过下标的方式访问其元素，下标也是从0开始的哟。
你可以这么声明并使用一个<code>Slice</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let arr = [1, 2, 3, 4, 5, 6];
let slice_complete = &amp;arr[..]; // 获取全部元素
let slice_middle = &amp;arr[1..4]; // 获取中间元素，最后取得的Slice为 [2, 3, 4] 。切片遵循左闭右开原则。
let slice_right = &amp;arr[1..]; // 最后获得的元素为[2, 3, 4, 5, 6]，长度为5。
let slice_left = &amp;arr[..3]; // 最后获得的元素为[1, 2, 3]，长度为3。
#}</code></pre></pre>
<p>怎么样，了解了吧。
那么接下来我们用<code>Slice</code>来改造一下上面的函数</p>
<pre><pre class="playpen"><code class="language-rust">fn show(arr: &amp;[u8]) {
    for i in arr {
        print!(&quot;{} &quot;, i);
    }
    println!(&quot;&quot;);
}

fn main() {
    let a: [u8; 3] = [1, 2, 3];
    let slice_a = &amp;a[..];
    show(slice_a);
    let b: [u8; 4] = [1, 2, 3, 4];
    show(&amp;b[..]);
}
</code></pre></pre>
<p>输出</p>
<pre><code>1 2 3
1 2 3 4
</code></pre>
<a class="header" href="print.html#a动态数组-vec-1" id="a动态数组-vec-1"><h2>动态数组 Vec</h2></a>
<p>熟悉C++ STL的同学可能对C++的vector很熟悉，同样的，Rust也提供了一个类似的东西。他叫<code>Vec</code>。</p>
<p>在基础类型里讲<code>Vec</code>貌似是不太合适的，但在实际应用中的应用比较广泛，所以说先粗略的介绍一下，在集合类型的章节会有详细讲述。</p>
<p>在Rust里，<code>Vec</code>被表示为 <code>Vec&lt;T&gt;</code>， 其中T是一个泛型。</p>
<p>下面介绍几种典型的<code>Vec</code>的用法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v1: Vec&lt;i32&gt; = vec![1, 2, 3]; // 通过vec!宏来声明
let v2 = vec![0; 10]; // 声明一个初始长度为10的值全为0的动态数组
println!(&quot;{}&quot;, v1[0]); // 通过下标来访问数组元素

for i in &amp;v1 {
    print!(&quot;{}&quot;, i); // &amp;Vec&lt;i32&gt; 可以通过 Deref 转换成 &amp;[i32]
}

println!(&quot;&quot;);

for i in &amp;mut v1 {
    *i = *i+1;
    print!(&quot;{}&quot;, i); // 可变访问
}

#}</code></pre></pre>
<p>输出结果：</p>
<pre><code>1
123
234
</code></pre>
<a class="header" href="print.html#a最原生字符串-str" id="a最原生字符串-str"><h2>最原生字符串 str</h2></a>
<p>你可以用<code>str</code>来声明一个字符串，事实上，Rust中，所有用<code>&quot;&quot;</code>双引号包裹起来的都可以称为<code>&amp;str</code>(注意这个<code>&amp;</code>,这是难点，先不用管他。)，但是这个类型被单独用的情况很少，因此，我们将在下一节着重介绍字符串类型。</p>
<a class="header" href="print.html#a函数类型-functions" id="a函数类型-functions"><h2>函数类型 Functions</h2></a>
<p>函数同样的是一个类型，这里只给大家普及一些基本的概念，函数类型涉及到比较高阶的应用，希望大家能在后面的<code>闭包</code>章节仔细参读</p>
<p>下面是一个小例子</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 { x+1 }

let x: fn(i32) -&gt; i32 = foo;

assert_eq!(11, x(10));
#}</code></pre></pre>
<a class="header" href="print.html#a布尔类型" id="a布尔类型"><h1>布尔类型</h1></a>
<p>正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。Rust 中的布尔类型使用 <code>bool</code> 表示。例如：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // 显式指定类型注解
}
</code></pre></pre>
<p>使用布尔值的主要场景是条件表达式，例如 <code>if</code> 表达式。在 “控制流”（“Control Flow”）部分将介绍 <code>if</code> 表达式在 Rust 中如何工作。</p>
<a class="header" href="print.html#a字符类型" id="a字符类型"><h1>字符类型</h1></a>
<p>Rust 的 <code>char</code> 类型是语言中最原生的字母类型，如下代码展示了如何使用它。（注意 <code>char</code> 由单引号指定，不同于字符串使用双引号。）</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Rust 的 <code>char</code> 类型代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，拼音字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 <code>char</code> 值。Unicode 标量值包含从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code> 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 <code>char</code> 并不符合。</p>
<a class="header" href="print.html#a整型-integer" id="a整型-integer"><h1>整型 (integer)</h1></a>
<p><strong>整数</strong> 是一个没有小数部分的数字。我们使用过 <code>u32</code> 整数类型。该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数（有符号整数类型以 <code>i</code> 开头而不是 <code>u</code>）。表格 3-1 展示了 Rust 内建的整数类型。在有符号列和无符号列中的每一个变体（例如，<code>i16</code>）都可以用来声明整数值的类型。</p>
<p><span class="caption">表格 3-1: Rust 中的整型</span></p>
<table><thead><tr><th> 长度   </th><th> 有符号   </th><th> 无符号   </th></tr></thead><tbody>
<tr><td> 8-bit  </td><td> <code>i8</code>    </td><td> <code>u8</code>     </td></tr>
<tr><td> 16-bit </td><td> <code>i16</code>   </td><td> <code>u16</code>    </td></tr>
<tr><td> 32-bit </td><td> <code>i32</code>   </td><td> <code>u32</code>    </td></tr>
<tr><td> 64-bit </td><td> <code>i64</code>   </td><td> <code>u64</code>    </td></tr>
<tr><td> arch   </td><td> <code>isize</code> </td><td> <code>usize</code>  </td></tr>
</tbody></table>
<p>每一个变体都可以是有符号或无符号的，并有一个明确的大小。<strong>有符号</strong> 和 <strong>无符号</strong> 代表数字能否为负值，换句话说，数字是否需要有一个符号（有符号数），或者永远为正而不需要符号（无符号数）。这有点像在纸上书写数字：当需要考虑符号的时候，数字以加号或减号作为前缀；然而，可以安全地假设为正数时，加号前缀通常省略。有符号数以补码形式（two’s complement representation）存储（如果你不清楚这是什么，可以在网上搜索；对其的解释超出了本书的范畴）。</p>
<p>每一个有符号的变体可以储存包含从 -(2<sup>n - 1</sup>) 到 2<sup>n - 1</sup> - 1 在内的数字，这里 <em>n</em> 是变体使用的位数。所以 <code>i8</code> 可以储存从 -(2<sup>7</sup>) 到 2<sup>7</sup> - 1 在内的数字，也就是从 -128 到 127。无符号的变体可以储存从 0 到 2<sup>n</sup> - 1 的数字，所以 <code>u8</code> 可以储存从 0 到 2<sup>8</sup> - 1 的数字，也就是从 0 到 255。</p>
<p>另外，<code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p>
<p>可以使用表格 3-2 中的任何一种形式编写数字字面值。注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 <code>57u8</code>，同时也允许使用 <code>_</code> 做为分隔符以方便读数，例如<code>1_000</code>。</p>
<p><span class="caption">表格 3-2: Rust 中的整型字面值</span></p>
<table><thead><tr><th> 数字字面值        </th><th> 例子          </th></tr></thead><tbody>
<tr><td> Decimal          </td><td> <code>98_222</code>      </td></tr>
<tr><td> Hex              </td><td> <code>0xff</code>        </td></tr>
<tr><td> Octal            </td><td> <code>0o77</code>        </td></tr>
<tr><td> Binary           </td><td> <code>0b1111_0000</code> </td></tr>
<tr><td> Byte (<code>u8</code> only) </td><td> <code>b'A'</code>        </td></tr>
</tbody></table>
<p>那么该使用哪种类型的数字呢？如果拿不定主意，Rust 的默认类型通常就很好，数字类型默认是 <code>i32</code>：它通常是最快的，甚至在 64 位系统上也是。<code>isize</code> 或 <code>usize</code> 主要作为某些集合的索引。</p>
<a class="header" href="print.html#a整型溢出" id="a整型溢出"><h2>整型溢出</h2></a>
<p>比方说有一个 <code>u8</code> ，它可以存放从零到 <code>255</code> 的值。那么当你将其修改为 <code>256</code> 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），关于这一行为 Rust 有一些有趣的规则。当在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em>，这个术语被 Rust 用来表明程序因错误而退出。后面详细介绍 panic。</p>
<p>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为 “two’s complement wrapping” 的操作。简而言之，<code>256</code> 变成 <code>0</code>，<code>257</code> 变成 <code>1</code>，依此类推。依赖溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，<code>Wrapping</code>。</p>
<a class="header" href="print.html#a浮点型-float" id="a浮点型-float"><h1>浮点型 (float)</h1></a>
<p>Rust 也有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。默认类型是 <code>f64</code>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。</p>
<p>这是一个展示浮点数的实例：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>浮点数采用 IEEE-754 标准表示。<code>f32</code> 是单精度浮点数，<code>f64</code> 是双精度浮点数。</p>
<a class="header" href="print.html#a数组类型" id="a数组类型"><h1>数组类型</h1></a>
<p>另一个包含多个值的方式是 <strong>数组</strong>（<em>array</em>）。与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。</p>
<p>Rust 中，数组中的值位于中括号内的逗号分隔的列表中：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>当你想要在栈（stack）而不是在堆（heap）上为数据分配空间（第四章将讨论栈与堆的更多内容），或者是想要确保总是有固定数量的元素时，数组非常有用。但是数组并不如 vector 类型灵活。vector 类型是标准库提供的一个 <strong>允许</strong> 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，你可能应该使用 vector。第八章会详细讨论 vector。</p>
<p>一个你可能想要使用数组而不是 vector 的例子是，当程序需要知道一年中月份的名字时。程序不大可能会去增加或减少月份。这时你可以使用数组，因为我们知道它总是包含 12 个元素：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
#}</code></pre></pre>
<p>数组的类型比较有趣；它看起来像 <code>[type; number]</code>。例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: [i32; 5] = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>首先是方括号；这看起来像创建数组的语法。其中有两部分由分号分割的信息。第一部分是数组中每个元素的类型。因为所有元素都是相同类型的，所以只需列出一次。分号之后，是一个表示数组长度的数字。因为数组是固定长度的，该数字也一直保持不变，即便数组的元素被修改，它也不会增长或缩小。</p>
<a class="header" href="print.html#a访问数组元素" id="a访问数组元素"><h2>访问数组元素</h2></a>
<p>数组是一整块分配在栈上的内存。可以使用索引来访问数组的元素，像这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>在这个例子中，叫做 <code>first</code> 的变量的值是 <code>1</code>，因为它是数组索引 <code>[0]</code> 的值。变量 <code>second</code> 将会是数组索引 <code>[1]</code> 的值 <code>2</code>。</p>
<a class="header" href="print.html#a无效的数组元素访问" id="a无效的数组元素访问"><h2>无效的数组元素访问</h2></a>
<p>如果我们访问数组结尾之后的元素会发生什么呢？比如你将上面的例子改成下面这样，这可以编译不过在运行时会因错误而退出：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p>使用 <code>cargo run</code> 运行代码后会产生如下结果：</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>编译并没有产生任何错误，不过程序会出现一个 <strong>运行时</strong>（<em>runtime</em>）错误并且不会成功退出。当尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em>，这是 Rust 术语，它用于程序因为错误而退出的情况。</p>
<p>这是第一个在实战中遇到的 Rust 安全原则的例子。在很多底层语言中，并没有进行这类检查，这样当提供了一个不正确的索引时，就会访问无效的内存。通过立即退出而不是允许内存访问并继续执行，Rust 让你避开此类错误。第九章会讨论更多 Rust 的错误处理。</p>
<a class="header" href="print.html#a元组类型" id="a元组类型"><h1>元组类型</h1></a>
<p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。</p>
<p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了可选的类型注解：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p><code>tup</code> 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用模式匹配（pattern matching）来解构（destructure）元组值，像这样：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>程序首先创建了一个元组并绑定到 <code>tup</code> 变量上。接着使用了 <code>let</code> 和一个模式将 <code>tup</code> 分成了三个不同的变量，<code>x</code>、<code>y</code> 和 <code>z</code>。这叫做 <strong>解构</strong>（<em>destructuring</em>），因为它将一个元组拆成了三个部分。最后，程序打印出了 <code>y</code> 的值，也就是 <code>6.4</code>。</p>
<p>除了使用模式匹配解构外，也可以使用点号（<code>.</code>）后跟值的索引来直接访问它们。例如：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>这个程序创建了一个元组，<code>x</code>，并接着使用索引为每个元素创建新变量。跟大多数编程语言一样，元组的第一个索引值是 0。</p>
<a class="header" href="print.html#a复合类型" id="a复合类型"><h1>复合类型</h1></a>
<a class="header" href="print.html#a元组tuple" id="a元组tuple"><h2>元组(Tuple)</h2></a>
<p>在别的语言里，你可能听过元组这个词，它表示一个大小、类型固定的有序数据组。在 Rust 中，情况并没有什么本质上的不同。不过 Rust 为我们提供了一系列简单便利的语法来让我们能更好的使用他。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let y = (2, &quot;hello world&quot;);
let x: (i32, &amp;str) = (3, &quot;world hello&quot;);

// 然后呢，你能用很简单的方式去访问他们：

// 用 let 表达式
let (w, z) = y; // w=2, z=&quot;hello world&quot;

// 用下标

let f = x.0; // f = 3
let e = x.1; // e = &quot;world hello&quot;
#}</code></pre></pre>
<a class="header" href="print.html#a结构体struct" id="a结构体struct"><h2>结构体(struct)</h2></a>
<p>在Rust中，结构体是一个跟 <code>tuple</code> 类似 的概念。我们同样可以将一些常用的数据、属性聚合在一起，就形成了一个结构体。</p>
<p>所不同的是，Rust的结构体有三种最基本的形式。</p>
<a class="header" href="print.html#a具名结构体" id="a具名结构体"><h3>具名结构体</h3></a>
<p>这种结构体呢，他可以大致看成这样的一个声明形式:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct A {
    attr1: i32,
    atrr2: String,
}
#}</code></pre></pre>
<p>内部每个成员都有自己的名字和类型。</p>
<a class="header" href="print.html#a元组类型结构体" id="a元组类型结构体"><h3>元组类型结构体</h3></a>
<p>元组类型结构体使用小括号，类似 <code>tuple</code> 。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct B(i32, u16, bool);
#}</code></pre></pre>
<p>它可以看作是一个有名字的元组，具体使用方法和一般的元组基本类似。</p>
<a class="header" href="print.html#a空结构体" id="a空结构体"><h3>空结构体</h3></a>
<p>结构体内部也可以没有任何成员。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct D;
#}</code></pre></pre>
<p>空结构体的内存占用为0。但是我们依然可以针对这样的类型实现它的“成员函数”。</p>
<p>不过到目前为止，在 1.9 版本之前的版本，空结构体后面不能加大括号。
如果这么写，则会导致这部分的老编译器编译错误：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct C {

}
#}</code></pre></pre>
<a class="header" href="print.html#a实现结构体impl" id="a实现结构体impl"><h3>实现结构体(impl)</h3></a>
<p>Rust没有继承，它和Golang不约而同的选择了trait(Golang叫Interface)作为其实现多态的基础。可是，如果我们要想对一个结构体写一些专门的成员函数那应该怎么写呢？</p>
<p>答： impl</p>
<p>talk is cheap ,举个栗子：</p>
<pre><pre class="playpen"><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn new(n: &amp;str) -&gt; Person {
        Person {
            name: n.to_string(),
        }
    }

    fn greeting(&amp;self) {
        println!(&quot;{} say hello .&quot;, self.name);
    }
}

fn main() {
    let peter = Person::new(&quot;Peter&quot;);
    peter.greeting();
}
</code></pre></pre>
<p>看见了 <code>self</code>，Python程序员不厚道的笑了。</p>
<p>我们来分析一下，上面的<code>impl</code>中，new 被 Person 这个结构体自身所调用，其特征是 <code>::</code> 的调用，Java程序员站出来了：类函数！ 而带有 <code>self</code> 的 <code>greeting</code> ，更像是一个成员函数。</p>
<p>恩，回答正确，然而不加分。</p>
<a class="header" href="print.html#a关于各种ref的讨论" id="a关于各种ref的讨论"><h3>关于各种ref的讨论</h3></a>
<p>Rust 对代码有着严格的安全控制，因此对一个变量也就有了所有权和借用的概念。所有权同一时间只能一人持有，可变引用也只能同时被一个实例持有，不可变引用则可以被多个实例持有。同时所有权能被转移，在Rust中被称为 <code>move</code> 。</p>
<p>以上是所有权的基本概念，事实上，在整个软件的运行周期内，所有权的转换是一件极其恼人和烦琐的事情，尤其对那些初学 Rust 的同学来说。同样的，Rust 的结构体作为其类型系统的基石，也有着比较严格的所有权控制限制。具体来说，关于结构体的所有权，有两种你需要考虑的情况。</p>
<a class="header" href="print.html#a字段的-ref-和-owner" id="a字段的-ref-和-owner"><h4>字段的 ref 和 owner</h4></a>
<p>在以上的结构体中，我们定义了不少结构体，但是如你所见，结构体的每个字段都是完整的属于自己的。也就是说，每个字段的 owner 都是这个结构体。每个字段的生命周期最终都不会超过这个结构体。</p>
<p>但是有些时候，我只是想要持有一个(可变)引用的值怎么办？
如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct RefBoy {
    loc: &amp;i32,
}
#}</code></pre></pre>
<p>这时候你会得到一个编译错误：</p>
<pre><code>&lt;anon&gt;:6:14: 6:19 error: missing lifetime specifier [E0106]
&lt;anon&gt;:6         loc: &amp; i32,
</code></pre>
<p>这种时候，你将持有一个值的引用，因为它本身的生命周期在这个结构体之外，所以对这个结构体而言，它无法准确的判断获知这个引用的生命周期，这在 Rust 编译器而言是不被接受的。
因此，这个时候就需要我们给这个结构体人为的写上一个生命周期，并显式地表明这个引用的生命周期。写法如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct RefBoy&lt;'a&gt; {
    loc: &amp;'a i32,
}
#}</code></pre></pre>
<p>这里解释一下这个符号 <code>&lt;&gt;</code>，它表示的是一个 <code>属于</code> 的关系，无论其中描述的是 <em>生命周期</em> 还是 <em>泛型</em> 。即： <code>RefBoy in 'a</code>。最终我们可以得出个结论，<code>RefBoy</code> 这个结构体，其生命周期一定不能比 <code>'a</code> 更长才行。</p>
<p>写到这里，可能有的人还是对生命周期比较迷糊，不明白其中缘由，其实你只需要知道两点即可：</p>
<ol>
<li>结构体里的引用字段必须要有显式的生命周期</li>
<li>一个被显式写出生命周期的结构体，其自身的生命周期一定小于等于其显式写出的任意一个生命周期</li>
</ol>
<p>关于第二点，其实生命周期是可以写多个的，用 <code>,</code> 分隔。</p>
<p>注：生命周期和泛型都写在 <code>&lt;&gt;</code> 里，先生命周期后泛型，用<code>,</code>分隔。</p>
<a class="header" href="print.html#impl中的三种self" id="impl中的三种self"><h4>impl中的三种self</h4></a>
<p>前面我们知道，Rust中，通过impl可以对一个结构体添加成员方法。同时我们也看到了<code>self</code>这样的关键字，同时，这个self也有好几种需要你仔细记忆的情况。</p>
<p>impl中的self,常见的有三种形式：<code>self</code>、 <code>&amp;self</code>、<code>&amp;mut self</code> ，我们分别来说。</p>
<a class="header" href="print.html#a被move的self" id="a被move的self"><h5>被move的self</h5></a>
<p>正如上面例子中的impl，我们实现了一个以 <code>self</code> 为第一个参数的函数，但是这样的函数实际上是有问题的。
问题在于Rust的所有权转移机制。</p>
<p>我曾经见过一个关于Rust的笑话：&quot;你调用了一下别人，然后你就不属于你了&quot;。</p>
<p>比如下面代码就会报出一个错误：</p>
<pre><pre class="playpen"><code class="language-rust">struct A {
    a: i32,
}
impl A {
    pub fn show(self) {
        println!(&quot;{}&quot;, self.a);
    }
}

fn main() {
    let ast = A{a: 12i32};
    ast.show();
    println!(&quot;{}&quot;, ast.a);
}
</code></pre></pre>
<p>错误：</p>
<pre><code>13:25 error: use of moved value: `ast.a` [E0382]
&lt;anon&gt;:13     println!(&quot;{}&quot;, ast.a);
</code></pre>
<p>为什么呢？因为 Rust 本身，在你调用一个函数的时候，如果传入的不是一个引用，那么无疑，这个参数将被这个函数吃掉，即其 owner 将被 move 到这个函数的参数上。同理，<code>impl</code> 中的 <code>self</code> ，如果你写的不是一个引用的话，也是会被默认的 move 掉哟！</p>
<p>那么如何避免这种情况呢？答案是 <code>Copy</code> 和 <code>Clone</code> ：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Copy, Clone)]
struct A {
    a: i32,
}
#}</code></pre></pre>
<p>这么写的话，会使编译通过。但是这么写实际上也是有其缺陷的。其缺陷就是： <code>Copy</code> 或者 <code>Clone</code> ，都会带来一定的运行时开销！事实上，被move的 <code>self</code> 其实是相对少用的一种情况，更多的时候，我们需要的是 <code>ref</code> 和 <code>ref mut</code> 。</p>
<a class="header" href="print.html#ref-和-ref-mut" id="ref-和-ref-mut"><h6>ref 和 ref mut</h6></a>
<p>关于 <code>ref</code> 和 <code>mut ref</code> 的写法和被 move 的 <code>self</code> 写法类似，只不过多了一个引用修饰符号，上面有例子，不多说。</p>
<p>需要注意的一点是，你不能在一个 <code>&amp;self</code> 的方法里调用一个 <code>&amp;mut ref</code> ，任何情况下都不行！</p>
<p>但是，反过来是可以的。代码如下：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Copy, Clone)]
struct A {
    a: i32,
}
impl A {
    pub fn show(&amp;self) {
        println!(&quot;{}&quot;, self.a);
        // compile error: cannot borrow immutable borrowed content `*self` as mutable
        // self.add_one();
    }
    pub fn add_two(&amp;mut self) {
        self.add_one();
        self.add_one();
        self.show();
    }
    pub fn add_one(&amp;mut self) {
        self.a += 1;
    }
}

fn main() {
    let mut ast = A{a: 12i32};
    ast.show();
    ast.add_two();
}
</code></pre></pre>
<p>需要注意的是，一旦你的结构体持有一个可变引用，你，只能在 <code>&amp;mut self</code> 的实现里去改变他！</p>
<p>Rust允许我们灵活的对一个 struct 进行你想要的实现，在编程的自由度上无疑有了巨大的提高。</p>
<p>至于更高级的关于 trait 和泛型的用法，我们将在以后的章节进行详细介绍。</p>
<a class="header" href="print.html#a枚举类型-enum" id="a枚举类型-enum"><h2>枚举类型 enum</h2></a>
<p>Rust的枚举(<code>enum</code>)类型，跟C语言的枚举有点接近，然而更强大，事实上它是一种代数数据类型(Algebraic Data Type)。</p>
<p>比如说，这是一个代表东南西北四个方向的枚举：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Direction {
    West,
    North,
    South,
    East,
}
#}</code></pre></pre>
<p>但是，rust 的枚举能做到的，比 C 语言的更多。
比如，枚举里面居然能包含一些你需要的，特定的数据信息！
这是常规的枚举所无法做到的，更像枚举类，不是么？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpecialPoint {
    Point(i32, i32),
    Special(String),
}
#}</code></pre></pre>
<p>你还可以给里面的字段命名，如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpecialPoint {
    Point {
        x: i32,
        y: i32,
    },
    Special(String),
}
#}</code></pre></pre>
<a class="header" href="print.html#a使用枚举" id="a使用枚举"><h3>使用枚举</h3></a>
<p>和struct的成员访问符号 <code>.</code> 不同的是，枚举类型要想访问其成员，几乎无一例外的要用到模式匹配。并且， 你可以写一个 <code>Direction::West</code>，但是你现在还不能写成 <code>Direction.West</code>, 除非你显式的 <code>use</code> 它 。虽然编译器足够聪明能发现你这个粗心的毛病。</p>
<p>关于模式匹配，我不会说太多，还是举个栗子</p>
<pre><pre class="playpen"><code class="language-rust">enum SpecialPoint {
    Point(i32, i32),
    Special(String),
}

fn main() {
    let sp = SpecialPoint::Point(0, 0);
    match sp {
        SpecialPoint::Point(x, y) =&gt; {
            println!(&quot;I'am SpecialPoint(x={}, y={})&quot;, x, y);
        }
        SpecialPoint::Special(why) =&gt; {
            println!(&quot;I'am Special because I am {}&quot;, why);
        }
    }
}
</code></pre></pre>
<p>呐呐呐，这就是模式匹配取值啦。
当然了， <code>enum</code> 其实也是可以 <code>impl</code> 的，一般人我不告诉他！</p>
<p>对于带有命名字段的枚举，模式匹配时可指定字段名</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
match sp {
    SpecialPoint::Point { x: x, y: y } =&gt; {
        // ...
    },
    SpecialPoint::Special(why) =&gt; {}
}
#}</code></pre></pre>
<p>对于带有字段名的枚举类型，其模式匹配语法与匹配 <code>struct</code> 时一致。如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let point = Point { x: 1, y: 2 };

let Point { x: x, y: y } = point;
// 或
let Point { x, y } = point;
// 或
let Point { x: x, .. } = point;
#}</code></pre></pre>
<p>模式匹配的语法与 <code>if let</code> 和 <code>let</code> 是一致的，所以在后面的内容中看到的也支持同样的语法。</p>
<a class="header" href="print.html#a枚举-enums" id="a枚举-enums"><h1>枚举 (Enums)</h1></a>
<a class="header" href="print.html#a结构体-struct" id="a结构体-struct"><h1>结构体 (Struct)</h1></a>
<a class="header" href="print.html#a微内核类型" id="a微内核类型"><h1>微内核类型</h1></a>
<a class="header" href="print.html#a元类型-unit" id="a元类型-unit"><h1>元类型 (unit)</h1></a>
<p>The unit type (), whose only possible value is an empty tuple: ()</p>
<p>元编程部分的使用的基础类型。</p>
<a class="header" href="print.html#a引用类型-reference" id="a引用类型-reference"><h1>引用类型 (reference)</h1></a>
<a class="header" href="print.html#a集合类型" id="a集合类型"><h1>集合类型</h1></a>
<p>就像C++的stl一样，Rust提供了一系列的基础且通用的容器类型。善用这些集合类型，可以让Rust编程更加方便轻松，但每种数据结构都会有其局限性，合理的选型方能维持更好的效率。</p>
<p>本章目录：</p>
<ul>
<li><a href="vec.md">Vec</a></li>
<li><a href="hashmap.md">HashMap</a></li>
</ul>
<a class="header" href="print.html#a动态数组vec" id="a动态数组vec"><h1>动态数组Vec</h1></a>
<p>在第七章我们粗略介绍了一下Vec的用法。实际上，作为Rust中一个非常重要的数据类型，熟练掌握Vec的用法能大大提升我们在Rust世界中的编码能力。</p>
<a class="header" href="print.html#a特性及声明方式" id="a特性及声明方式"><h2>特性及声明方式</h2></a>
<p>和我们之前接触到的Array不同，<code>Vec</code>具有动态的添加和删除元素的能力，并且能够以<code>O(1)</code>的效率进行随机访问。同时，对其尾部进行push或者pop操作的效率也是平摊<code>O(1)</code>的。
同时，有一个非常重要的特性（虽然我们编程的时候大部分都不会考量它）就是，Vec的所有内容项都是生成在堆空间上的，也就是说，你可以轻易的将Vec move出一个栈而不用担心内存拷贝影响执行效率——毕竟只是拷贝的栈上的指针。</p>
<p>另外的就是，<code>Vec&lt;T&gt;</code>中的泛型<code>T</code>必须是<code>Sized</code>的，也就是说必须在编译的时候就知道存一个内容项需要多少内存。对于那些在编译时候未知大小的项（函数类型等），我们可以用<code>Box</code>将其包裹，当成一个指针。</p>
<a class="header" href="print.html#new" id="new"><h3>new</h3></a>
<p>我们可以用<code>std::vec::Vec::new()</code>的方式来声明一个Vec。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v1: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p>这里需要注意的是，<code>new</code>函数并没有提供一个能显式规定其泛型类型的参数，也就是说，上面的代码能根据<code>v1</code>的类型自动推导出<code>Vec</code>的泛型;但是，你不能写成如下的形式：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v1 = Vec::new::&lt;i32&gt;();
// 与之对比的,collect函数就能指定：
// let mut v2 = (0i32..5).collect::&lt;Vec&lt;i32&gt;&gt;();
#}</code></pre></pre>
<p>这是因为这两个函数的声明形式以及实现形式，在此，我们不做深究。</p>
<a class="header" href="print.html#a宏声明" id="a宏声明"><h3>宏声明</h3></a>
<p>相比调用new函数，Rust提供了一种更加直观便捷的方式声明一个动态数组： <code>vec!</code> 宏。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = vec![];

// 以下语句相当于：
// let mut temp = Vec::new();
// temp.push(1);
// temp.push(2);
// temp.push(3);
// let v = temp;
let v = vec![1, 2, 3];

let v = vec![0; 10]; //注意分号，这句话声明了一个 内容为10个0的动态数组
#}</code></pre></pre>
<a class="header" href="print.html#a从迭代器生成" id="a从迭代器生成"><h3>从迭代器生成</h3></a>
<p>因为Vec实现了<code>FromIterator</code>这个trait，因此，借助collect，我们能将任意一个迭代器转换为Vec。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;_&gt; = (1..5).collect();
#}</code></pre></pre>
<a class="header" href="print.html#a访问及修改" id="a访问及修改"><h2>访问及修改</h2></a>
<a class="header" href="print.html#a随机访问" id="a随机访问"><h3>随机访问</h3></a>
<p>就像数组一样，因为Vec借助<code>Index</code>和<code>IndexMut</code>提供了随机访问的能力，我们通过<code>[index]</code>来对其进行访问，当然，既然存在随机访问就会出现越界的问题。而在Rust中，一旦越界的后果是极其严重的，可以导致Rust当前线程panic。因此，除非你确定自己在干什么或者在<code>for</code>循环中，不然我们不推荐通过下标访问。</p>
<p>以下是例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = vec![1, 2, 3];
assert_eq!(a[1usize], 2);
#}</code></pre></pre>
<p>那么，Rust中有没有安全的下标访问机制呢？答案是当然有：—— <code>.get(n: usize)</code> （<code>.get_mut(n: usize)</code>） 函数。
对于一个数组，这个函数返回一个<code>Option&lt;&amp;T&gt;</code> (<code>Option&lt;&amp;mut T&gt;</code>)，当Option==None的时候，即下标越界，其他情况下，我们能安全的获得一个Vec里面元素的引用。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v =vec![1, 2, 3];
assert_eq!(v.get(1), Some(&amp;2));
assert_eq!(v.get(3), None);
#}</code></pre></pre>
<a class="header" href="print.html#a迭代器" id="a迭代器"><h3>迭代器</h3></a>
<p>对于一个可变数组，Rust提供了一种简单的遍历形式—— for 循环。
我们可以获得一个数组的引用、可变引用、所有权。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
for i in &amp;v { .. } // 获得引用
for i in &amp;mut v { .. } // 获得可变引用
for i in v { .. } // 获得所有权，注意此时Vec的属主将会被转移！！
#}</code></pre></pre>
<p>但是，这么写很容易出现多层<code>for</code>循环嵌套，因此，<code>Vec</code>提供了一个<code>into_iter()</code>方法，能显式地将自己转换成一个迭代器。然而迭代器怎么用呢？我们下一章将会详细说明。</p>
<a class="header" href="print.html#push的效率研究" id="push的效率研究"><h3>push的效率研究</h3></a>
<p>前面说到，<code>Vec</code>有两个<code>O(1)</code>的方法，分别是<code>pop</code>和<code>push</code>，它们分别代表着将数据从尾部弹出或者装入。理论上来说，因为<code>Vec</code>是支持随机访问的，因此<code>push</code>效率应该是一致的。但是实际上，因为Vec的内部存在着内存拷贝和销毁，因此，如果你想要将一个数组，从零个元素开始，一个一个的填充直到最后生成一个非常巨大的数组的话，预先为其分配内存是一个非常好的办法。</p>
<p>这其中，有个关键的方法是reserve。</p>
<p>如下代码(注意：由于SystemTime API在1.8以后才稳定, 请使用1.8.0 stable 以及以上版本的rustc编译)：</p>
<pre><pre class="playpen"><code class="language-rust">use std::time;

fn push_1m(v: &amp;mut Vec&lt;usize&gt;, total: usize) {
    let e = time::SystemTime::now();
    for i in 1..total {
        v.push(i);
    }
    let ed = time::SystemTime::now();
    println!(&quot;time spend: {:?}&quot;, ed.duration_since(e).unwrap());
}

fn main() {
    let mut v: Vec&lt;usize&gt; = vec![];
    push_1m(&amp;mut v, 5_000_000);
    let mut v: Vec&lt;usize&gt; = vec![];
    v.reserve(5_000_000);
    push_1m(&amp;mut v, 5_000_000);
}
</code></pre></pre>
<p>在笔者自己的笔记本上，编译好了debug的版本，上面的代码跑出了：</p>
<pre><code>➜  debug git:(master) ✗ time ./demo
time spend: Duration { secs: 0, nanos: 368875346 }
time spend: Duration { secs: 0, nanos: 259878787 }
./demo  0.62s user 0.01s system 99% cpu 0.632 total

</code></pre>
<p>好像并没有太大差异？然而切换到release版本的时候:</p>
<pre><code>➜  release git:(master) ✗ time ./demo
time spend: Duration { secs: 0, nanos: 53389934 }
time spend: Duration { secs: 0, nanos: 24979520 }
./demo  0.06s user 0.02s system 97% cpu 0.082 total
</code></pre>
<p>注意消耗的时间的位数。可见，在去除掉debug版本的调试信息之后，是否预分配内存消耗时间降低了一倍！</p>
<p>这样的成绩，可见，预先分配内存确实有助于提升效率。</p>
<p>有人可能会问了，你这样纠结这点时间，最后不也是节省在纳秒级别的么，有意义么？当然有意义。</p>
<p>第一，纳秒也是时间，这还是因为这个测试的<code>Vec</code>只是最简单的内存结构。一旦涉及到大对象的拷贝，所花费的时间可就不一定这么少了。
第二，频繁的申请和删除堆空间，其内存一旦达到瓶颈的时候你的程序将会异常危险。</p>
<p>更多<code>Vec</code>的操作，请参照标准库的api。</p>
<a class="header" href="print.html#string-1" id="string-1"><h1>String</h1></a>
<p>这章我们来着重介绍一下字符串。</p>
<p>刚刚学习Rust的同学可能会被Rust的字符串搞混掉，比如<code>str</code>，<code>String</code>， <code>OsStr</code>， <code>CStr</code>，<code>CString</code>等等……
事实上，如果你不做 <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI</a> (Foreign Function Interface 外部功能接口, 也是高级语言之间的接口调用)的话，常用的字符串类型就只有前两种(<code>str</code>，<code>String</code>)。我们就来着重研究一下Rust的前两种字符串。</p>
<p>你要明白的是，Rust中的字符串实际上是被编码成UTF-8的一个字节数组。这么说比较拗口，简单来说，Rust字符串内部存储的是一个u8数组<code>[u8]</code>，但是这个数组是Unicode字符经过UTF-8编码得来的。因此，可以看成Rust原生就支持Unicode字符集（Python2的码农泪流满面）。</p>
<a class="header" href="print.html#str-1" id="str-1"><h2>str</h2></a>
<p>首先我们先来看一下<code>str</code>， 从字面意思上，Rust的string被表达为： <code>&amp;'static str</code>(看不懂这个表达式没关系，&amp;表示引用你知道吧，static表示静态你知道吧，好了，齐了)，即，你在代码里写的，所有的用<code>&quot;&quot;</code>包裹起来的字符串，都被声明成了一个不可变，静态的字符串。而我们的如下语句：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 下面这两种方式是等价的
let x = &quot;Hello&quot;;
let x:&amp;'static str = &quot;Hello&quot;;
#}</code></pre></pre>
<p>实际上是将 <code>&quot;Hello&quot;</code> 这个静态变量的引用传递给了<code>x</code>。同时，这里的字符串不可变！</p>
<p>字符串也支持转义字符：
比如如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let z = &quot;foo
bar&quot;;
let w = &quot;foo\nbar&quot;;
assert_eq!(z, w);
#}</code></pre></pre>
<p>也可以在字符串字面量前加上<code>r</code>来避免转义</p>
<pre><code>//没有转义序列
let d: &amp;'static str = r&quot;abc \n abc&quot;;
//等价于
let c: &amp;'static str = &quot;abc \\n abc&quot;;
</code></pre>
<a class="header" href="print.html#string-2" id="string-2"><h2>String</h2></a>
<p>光有<code>str</code>，确实不够什么卵用，毕竟我们在实际应用中要的更多的还是一个可变的，不定长的字符串。这时候，一种在堆上声明的字符串<code>String</code>被设计了出来。
它能动态的去增长或者缩减，那么怎么声明它呢？我们先介绍一种简单的方式，从<code>str</code>中转换：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x:&amp;'static str = &quot;hello&quot;;

let mut y:String = x.to_string();
println!(&quot;{}&quot;, y);
y.push_str(&quot;, world&quot;);
println!(&quot;{}&quot;, y);
#}</code></pre></pre>
<p>我知道你一定会问：——
那么如何将一个<code>String</code>重新变成<code>&amp;str</code>呢？
答：用 <code>&amp;*</code> 符号</p>
<pre><pre class="playpen"><code class="language-rust">fn use_str(s: &amp;str) {
    println!(&quot;I am: {}&quot;, s);
}

fn main() {
    let s = &quot;Hello&quot;.to_string();
    use_str(&amp;*s);
}
</code></pre></pre>
<p>我们来分析一下，以下部分将涉及到部分<code>Deref</code>的知识，可能需要你预习一下，如果不能理解大可跳过下一段：</p>
<p>首先呢， <code>&amp;*</code>是两个符号<code>&amp;</code>和<code>*</code>的组合，按照Rust的运算顺序，先对<code>String</code>进行<code>Deref</code>,也就是<code>*</code>操作。</p>
<p>由于<code>String</code>实现了 <code>impl Deref&lt;Target=str&gt; for String</code>，这相当于一个运算符重载，所以你就能通过<code>*</code>获得一个<code>str</code>类型。但是我们知道，单独的<code>str</code>是不能在Rust里直接存在的，因此，我们需要先给他进行<code>&amp;</code>操作取得<code>&amp;str</code>这个结果。</p>
<p>有人说了，我发现只要用<code>&amp;</code>一个操作符就能将使上面的编译通过。
这其实是一个编译器的锅，因为Rust的编译器会在<code>&amp;</code>后面插入足够多的<code>*</code>来尽可能满足<code>Deref</code>这个特性。这个特性会在某些情况下失效，因此，为了不给自己找麻烦，还是将操作符写全为好。</p>
<p>需要知道的是，将<code>String</code>转换成<code>&amp;str</code>是非常轻松的，几乎没有任何开销。但是反过来，将<code>&amp;str</code>转换成<code>String</code>是需要在堆上请求内存的，因此，要慎重。</p>
<p>我们还可以将一个UTF-8编码的字节数组转换成String，如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 存储在Vec里的一些字节
let miao = vec![229,150,181];

// 我们知道这些字节是合法的UTF-8编码字符串，所以直接unwrap()
let meow = String::from_utf8(miao).unwrap();

assert_eq!(&quot;喵&quot;, meow);
#}</code></pre></pre>
<a class="header" href="print.html#a索引访问" id="a索引访问"><h2>索引访问</h2></a>
<p>有人会把Rust中的字符串和其惯用的字符串等同起来，于是就出现了如下代码</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = &quot;hello&quot;.to_string();
x[1]; //编译错误！
#}</code></pre></pre>
<p>Rust的字符串实际上是不支持通过下标访问的，但是呢，我们可以通过将其转变成数组的方式访问</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = &quot;哎哟我去&quot;.to_string();
for i in x.as_bytes() {
    print!(&quot;{} &quot;, i);
}

println!(&quot;&quot;);

for i in x.chars() {
    print!(&quot;{}&quot;, i);
}

x.chars().nth(2);
#}</code></pre></pre>
<a class="header" href="print.html#a字符串切片" id="a字符串切片"><h2>字符串切片</h2></a>
<p>对字符串切片是一件非常危险的事，虽然Rust支持，但是我并不推荐。因为Rust的字符串Slice实际上是切的bytes。这也就造成了一个严重后果，如果你切片的位置正好是一个Unicode字符的内部，Rust会发生Runtime的panic，导致整个程序崩溃。
因为这个操作是如此的危险，所以我就不演示了……</p>
<a class="header" href="print.html#a哈希表-hashmap" id="a哈希表-hashmap"><h1>哈希表 HashMap</h1></a>
<p>和动态数组<code>Vec</code>一样，哈希表(HashMap)也是Rust内置的集合类型之一，同属<code>std::collections</code>模块下。</p>
<p>它提供了一个平均复杂度为<code>O(1)</code>的查询方法，是实现快速搜索必备的类型之一。</p>
<p>这里呢，主要给大家介绍一下HashMap的几种典型用法。</p>
<a class="header" href="print.html#hashmap的要求" id="hashmap的要求"><h2>HashMap的要求</h2></a>
<p>顾名思义, HashMap 要求一个可哈希（实现 Hash trait）的Key类型，和一个编译时知道大小的Value类型。
同时，Rust还要求你的Key类型必须是可比较的，在Rust中，你可以为你的类型轻易的加上编译器属性：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Eq, Hash)]
#}</code></pre></pre>
<p>这样，即可将你的类型转换成一个可以作为Hash的Key的类型。
但是，如果你想要自己实现<code>Hash</code>这个trait的话，你需要谨记两点：</p>
<ul>
<li>
<ol>
<li>如果 Key1==Key2 ,那么一定有 Hash(Key1) == Hash(Key2)</li>
</ol>
</li>
<li>
<ol start="2">
<li>你的Hash函数本身不能改变你的Key值，否则将会引发一个逻辑错误（很难排查，遇到就完的那种）</li>
</ol>
</li>
</ul>
<p>什么？你看到 <code>std::hash::Hash</code> 这个 trait 中的函数没有<code>&amp;mut self</code>的啊！但是，你不要忘了Rust中还有<code>Cell</code>和<code>RefCell</code>这种存在，他们提供了不可变对象的内部可变性，具体怎么变呢，请参照第20章。</p>
<p>另外，要保证你写的Hash函数不会被很轻易的碰撞，即 <code>Key1! = Key2</code>，但 <code>Hash(Key1)==Hash(Key2)</code>，碰撞的严重了，HashMap甚至有可能退化成链表！</p>
<p>这里笔者提议，别费劲，就按最简单的来就好。</p>
<a class="header" href="print.html#a增删改查" id="a增删改查"><h2>增删改查</h2></a>
<p>对于这种实用的类型，我们推荐用一个例子来解释：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

// 声明
let mut come_from = HashMap::new();
// 插入
come_from.insert(&quot;WaySLOG&quot;, &quot;HeBei&quot;);
come_from.insert(&quot;Marisa&quot;, &quot;U.S.&quot;);
come_from.insert(&quot;Mike&quot;, &quot;HuoGuo&quot;);

// 查找key
if !come_from.contains_key(&quot;elton&quot;) {
    println!(&quot;Oh, 我们查到了{}个人，但是可怜的Elton猫还是无家可归&quot;, come_from.len());
}

// 根据key删除元素
come_from.remove(&quot;Mike&quot;);
println!(&quot;Mike猫的家乡不是火锅！不是火锅！不是火锅！虽然好吃！&quot;);

// 利用get的返回判断元素是否存在
let who = [&quot;MoGu&quot;, &quot;Marisa&quot;];
for person in &amp;who {
    match come_from.get(person) {
        Some(location) =&gt; println!(&quot;{} 来自: {}&quot;, person, location),
        None =&gt; println!(&quot;{} 也无家可归啊.&quot;, person),
    }
}

// 遍历输出
println!(&quot;那么，所有人呢？&quot;);
for (name, location) in &amp;come_from {
    println!(&quot;{}来自: {}&quot;, name, location);
}
#}</code></pre></pre>
<p>这段代码输出：</p>
<pre><code>Oh, 我们查到了3个人，但是可怜的Elton猫还是无家可归
Mike猫的家乡不是火锅！不是火锅！不是火锅！虽然好吃！
MoGu 也无家可归啊.
Marisa 来自: U.S.
那么，所有人呢？
Marisa来自: U.S.
WaySLOG来自: HeBei
</code></pre>
<a class="header" href="print.html#entry" id="entry"><h2>entry</h2></a>
<p>我们在编程的过程中，经常遇到这样的场景，统计一个字符串中所有的字符总共出现过几次。借助各种语言内置的Map类型我们总能完成这件事，但是完成的几乎都并不令人满意。很多人讨厌的一点是：为什么我要判断这个字符在字典中有没有出现，就要写一个大大的if条件！烦不烦？烦！于是，现代化的编程语言开始集成了类似Python里<code>setdefault</code>类似的特性（方法），下面是一段Python代码：</p>
<pre><code class="language-python">val = {}
for c in &quot;abcdefasdasdawe&quot;:
    val[c] = 1 + val.setdefault(c, 0)
print val
</code></pre>
<p>唔，总感觉怪怪的。那么Rust是怎么解决这个问题的呢？
以下内容摘自标注库api注释：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut letters = HashMap::new();

for ch in &quot;a short treatise on fungi&quot;.chars() {
    let counter = letters.entry(ch).or_insert(0);
    *counter += 1;
}

assert_eq!(letters[&amp;'s'], 2);
assert_eq!(letters[&amp;'t'], 3);
assert_eq!(letters[&amp;'u'], 1);
assert_eq!(letters.get(&amp;'y'), None);
#}</code></pre></pre>
<p>Rust为我们提供了一个名叫 <code>entry</code> 的api，它很有意思，和Python相比，我们不需要在一次迭代的时候二次访问原map，只需要借用 entry 出来的Entry类型（这个类型持有原有HashMap的引用）即可对原数据进行修改。就语法来说，毫无疑问Rust在这个方面更加直观和具体。</p>
<a class="header" href="print.html#a常用数据结构实现" id="a常用数据结构实现"><h1>常用数据结构实现</h1></a>
<p>本章讲解如何使用 Rust 进行一些常用数据结构的实现。实现的代码仅作示例用，并不一定十分高效。真正使用的时候，请使用标准库或第三方成熟库中的数据结构。</p>
<a class="header" href="print.html#a栈" id="a栈"><h1>栈</h1></a>
<a class="header" href="print.html#a栈简介" id="a栈简介"><h2>栈简介</h2></a>
<ul>
<li>
<p>栈作为一种数据结构，是一种只能在<strong>一端</strong>进行<strong>插入</strong>和<strong>删除</strong>操作的特殊线性表。</p>
</li>
<li>
<p>它按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</p>
</li>
</ul>
<blockquote>
<p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
</blockquote>
<a class="header" href="print.html#a栈的实现步骤" id="a栈的实现步骤"><h2>栈的实现步骤：</h2></a>
<ul>
<li>定义一个栈结构<code>Stack</code></li>
<li>定义组成栈结构的栈点<code>StackNode</code></li>
<li>实现栈的初始化函数<code>new( )</code></li>
<li>实现进栈函数<code>push( )</code></li>
<li>实现退栈函数<code>pop( )</code></li>
</ul>
<a class="header" href="print.html#a定义一个栈结构stack" id="a定义一个栈结构stack"><h2>定义一个栈结构<code>Stack</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Stack&lt;T&gt; {
    top: Option&lt;Box&lt;StackNode&lt;T&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>让我们一步步来分析</p>
<ul>
<li>第一行的<code>#[derive(Debug)]</code>是为了让<code>Stack</code>结构体可以打印调试。</li>
<li>第二行是定义了一个<code>Stack</code>结构体，这个结构体包含一个泛型参数<code>T</code>。</li>
<li>第三行比较复杂，在定义<code>StackNode</code>的时候介绍</li>
</ul>
<a class="header" href="print.html#a定义组成栈结构的栈点stacknode" id="a定义组成栈结构的栈点stacknode"><h2>定义组成栈结构的栈点<code>StackNode</code></h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Clone,Debug)]
struct StackNode&lt;T&gt; {
    val: T,
    next: Option&lt;Box&lt;StackNode&lt;T&gt;&gt;&gt;,
}
#}</code></pre></pre>
<p>在这段代码的第三行， 我们定义了一个<code>val</code>保存<code>StackNode</code>的值。</p>
<blockquote>
<p>现在我们重点来看看第四行：
我们<strong>从里到外</strong>拆分来看看，首先是<code>Box&lt;StackNode&lt;T&gt;</code>，这里的<code>Box</code>是 Rust 用来显式分配堆内存的类型：</p>
</blockquote>
<blockquote>
<p><code>pub struct Box&lt;T&gt; where T: ?Sized(_);</code><br />
<a href="http://doc.rust-lang.org/nightly/std/boxed/struct.Box.html">详细文档请参考Rust的标准库</a></p>
</blockquote>
<blockquote>
<p>在 Rust 里面用强大的类型系统做了统一的抽象。在这里相当于在堆空间里申请了一块内存保存<code>StackNode&lt;T&gt;</code>。</p>
</blockquote>
<blockquote>
<p><strong>为什么要这么做了？如果不用Box封装会怎么样呢？</strong></p>
</blockquote>
<blockquote>
<p>如果不用 Box 封装，rustc 编译器会报错，在 Rust 里面，rustc 默认使用栈空间，但是这里的<code>StackNode</code>定义的时候使用了递归的数据结构，next 属性的类型是 <code>StackNode&lt;T&gt;</code>，而这个类型是无法确定大小的，所有这种无法确定大小的类型，都不能保存在栈空间。所以需要使用<code>Box</code>来封装。这样的话<code>next</code>的类型就是一个指向某一块堆空间的指针，而指针是可以确定大小的，因此能够保存在栈空间。</p>
</blockquote>
<blockquote>
<p><strong>那么为什么还需要使用<code>Option</code>来封装呢？</strong></p>
</blockquote>
<blockquote>
<p><code>Option</code>是 Rust 里面的一个抽象类型，定义如下：</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub enum Option&lt;T&gt; {
    None,
    Some(T),
}
#}</code></pre></pre>
<p>Option 里面包括元素，None 和 Some(T) ，这样就很轻松的描述了 next 指向栈尾的元素的时候，都是在 Option 类型下，方便了功能实现，也方便了错误处理。Option 还有很多强大的功能，读者可以参考下面几个连接：</p>
<p><a href="http://doc.rust-lang.org/nightly/std/option/enum.Option.html">Option标准库文档</a></p>
<p><a href="http://blog.burntsushi.net/rust-error-handling/">Error Handling in Rust</a></p>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/error.html">rustbyexample 的 Error handling</a></p>
<a class="header" href="print.html#a实现-new--push--pop-" id="a实现-new--push--pop-"><h2>实现 <code>new( ) push( ) pop( )</code></h2></a>
<p>接下来是实现 stack 的主要功能了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Stack&lt;T&gt; {
    fn new() -&gt; Stack&lt;T&gt; {
        Stack{ top: None }
    }

    fn push(&amp;mut self, val: T) {
        let mut node = StackNode::new(val);
        let next = self.top.take();
        node.next = next;
        self.top = Some(Box::new(node));
    }

    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        let val = self.top.take();
        match val {
            None =&gt; None,
            Some(mut x) =&gt; {
                self.top = x.next.take();
                Some(x.val)
            },
        }
    }
}
#}</code></pre></pre>
<ul>
<li>
<p><code>new( )</code>比较简单，Stack 初始化的时候为空，栈顶元素 <code>top</code> 就没有任何值，所以 <code>top</code> 为 <code>None</code>。</p>
</li>
<li>
<p><code>push( )</code>的主要功能是往栈里面推入元素，把新的 StackNode 指向 Stack 里面旧的值，同时更新 Stack 栈顶指向新进来的值。</p>
</li>
</ul>
<blockquote>
<p>这里有个需要注意的地方是第8行代码里面，<code>let next = self.top.take();</code>，使用了 Option 类型的 take 方法：<br />
<code>fn take(&amp;mut self) -&gt; Option&lt;T&gt;</code>
它会把 Option 类型的值取走，并把它的元素改为 None</p>
</blockquote>
<ul>
<li><code>pop( )</code>的功能是取出栈顶的元素，如果栈顶为 None 则返回 None。</li>
</ul>
<a class="header" href="print.html#a完整代码包含简单的测试" id="a完整代码包含简单的测试"><h2>完整代码（包含简单的测试）</h2></a>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Stack&lt;T&gt; {
    top: Option&lt;Box&lt;StackNode&lt;T&gt;&gt;&gt;,
}

#[derive(Clone,Debug)]
struct StackNode&lt;T&gt; {
    val: T,
    next: Option&lt;Box&lt;StackNode&lt;T&gt;&gt;&gt;,
}

impl &lt;T&gt; StackNode&lt;T&gt; {
    fn new(val: T) -&gt; StackNode&lt;T&gt; {
        StackNode { val: val, next: None }
    }
}

impl&lt;T&gt; Stack&lt;T&gt; {
    fn new() -&gt; Stack&lt;T&gt; {
        Stack{ top: None }
    }

    fn push(&amp;mut self, val: T) {
        let mut node = StackNode::new(val);
        let next = self.top.take();
        node.next = next;
        self.top = Some(Box::new(node));
    }

    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        let val = self.top.take();
        match val {
            None =&gt; None,
            Some(mut x) =&gt; {
                self.top = x.next.take();
                Some(x.val)
            },
        }
    }
}

fn main() {
    #[derive(PartialEq,Eq,Debug)]
    struct TestStruct {
        a: i32,
    }

    let a = TestStruct{ a: 5 };
    let b = TestStruct{ a: 9 };

    let mut s = Stack::&lt;&amp;TestStruct&gt;::new();
    assert_eq!(s.pop(), None);

    s.push(&amp;a);
    s.push(&amp;b);
    println!(&quot;{:?}&quot;, s);

    assert_eq!(s.pop(), Some(&amp;b));
    assert_eq!(s.pop(), Some(&amp;a));
    assert_eq!(s.pop(), None);
}
</code></pre></pre>
<a class="header" href="print.html#a队列" id="a队列"><h1>队列</h1></a>
<a class="header" href="print.html#a队列简介" id="a队列简介"><h2>队列简介</h2></a>
<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p>
<blockquote>
<p>在队列的形成过程中，可以利用线性链表的原理，来生成一个队列。基于链表的队列，要动态创建和删除节点，效率较低，但是可以动态增长。队列采用的 <strong>FIFO(first in first out)</strong>，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。</p>
</blockquote>
<a class="header" href="print.html#a队列实现" id="a队列实现"><h2>队列实现</h2></a>
<p>下面看一下我们使用 Vec 来实现的简单 Queue：</p>
<p>主要实现的<code>new( ), push( ), pop( )</code>三个方法</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Queue&lt;T&gt; {
    qdata: Vec&lt;T&gt;,
}

impl &lt;T&gt; Queue&lt;T&gt; {
    fn new() -&gt; Self {
        Queue{qdata: Vec::new()}
    }

    fn push(&amp;mut self, item:T) {
        self.qdata.push(item);
    }

    fn pop(&amp;mut self) -&gt; T{
        self.qdata.remove(0)
    }
}

fn main() {
    let mut q = Queue::new();
    q.push(1);
    q.push(2);
    println!(&quot;{:?}&quot;, q);
    q.pop();
    println!(&quot;{:?}&quot;, q);
    q.pop();
}
</code></pre></pre>
<a class="header" href="print.html#a练习" id="a练习"><h2>练习</h2></a>
<p>看起来比我们在上一节实现的Stack简单多了。不过这个Queue实现是有Bug的。</p>
<p>练习：在这个代码的上找到 Bug，并修改。</p>
<p>提示：<code>pop( )</code>方法有 Bug，请参考 Stack 小节的实现，利用 Option 来处理。</p>
<a class="header" href="print.html#a二叉树" id="a二叉树"><h1>二叉树</h1></a>
<a class="header" href="print.html#a二叉树简介" id="a二叉树简介"><h2>二叉树简介</h2></a>
<p>在计算机科学中，二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p>
<blockquote>
<p>二叉查找树的子节点与父节点的键一般满足一定的顺序关系，习惯上，左节点的键少于父亲节点的键，右节点的键大于父亲节点的键。</p>
</blockquote>
<blockquote>
<p>二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。二叉堆有两种：最大堆和最小堆。最大堆：父结点的键总是大于或等于任何一个子节点的键；最小堆：父结点的键总是小于或等于任何一个子节点的键。</p>
</blockquote>
<blockquote>
<p>二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2^{i-1}个结点；深度为k的二叉树至多有2^k-1个结点；对任何一棵二叉树T，如果其终端结点数为n_0，度为2的结点数为n_2，则n_0=n_2+1。</p>
</blockquote>
<blockquote>
<p>一棵深度为k，且有2^k-1个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p>
</blockquote>
<a class="header" href="print.html#a二叉树与树的区别" id="a二叉树与树的区别"><h2>二叉树与树的区别</h2></a>
<p>二叉树<em>不是</em>树的一种特殊情形，尽管其与树有许多相似之处，但树和二叉树有两个主要差别：</p>
<ol>
<li>树中结点的最大度数没有限制，而二叉树结点的最大度数为2。</li>
<li>树的结点无左、右之分，而二叉树的结点有左、右之分。</li>
</ol>
<a class="header" href="print.html#a定义二叉树的结构" id="a定义二叉树的结构"><h2>定义二叉树的结构</h2></a>
<p>二叉树的每个节点由键key、值value与左右子树left/right组成，这里我们把节点声明为一个泛型结构。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type TreeNode&lt;K,V&gt; = Option&lt;Box&lt;Node&lt;K,V&gt;&gt;&gt;;
#[derive(Debug)]
struct Node&lt;K,V: std::fmt::Display&gt; {
   left: TreeNode&lt;K,V&gt;,
   right: TreeNode&lt;K,V&gt;,
   key: K,
   value: V,
}
#}</code></pre></pre>
<a class="header" href="print.html#a实现二叉树的初始化与二叉查找树的插入" id="a实现二叉树的初始化与二叉查找树的插入"><h2>实现二叉树的初始化与二叉查找树的插入</h2></a>
<p>由于二叉查找树要求键可排序，我们要求K实现PartialOrd</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait BinaryTree&lt;K,V&gt; {
    fn pre_order(&amp;self);
    fn in_order(&amp;self);
    fn pos_order(&amp;self);
}
trait BinarySearchTree&lt;K:PartialOrd,V&gt;:BinaryTree&lt;K,V&gt; {
    fn insert(&amp;mut self, key:K,value: V);
}
impl&lt;K,V:std::fmt::Display&gt; Node&lt;K,V&gt; {
    fn new(key: K,value: V) -&gt; Self {
        Node{
            left: None,
            right: None,
            value: value,
            key: key,
        }
    }
}
impl&lt;K:PartialOrd,V:std::fmt::Display&gt; BinarySearchTree&lt;K,V&gt; for Node&lt;K,V&gt;{
    fn insert(&amp;mut self, key:K,value:V) {
        if self.key &lt; key {
            if let Some(ref mut right) = self.right {
                right.insert(key,value);
            } else {
                self.right = Some(Box::new(Node::new(key,value)));
            }
        } else {
            if let Some(ref mut left) = self.left {
                left.insert(key,value);
            } else {
                self.left = Some(Box::new(Node::new(key,value)));
            }
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a二叉树的遍历" id="a二叉树的遍历"><h2>二叉树的遍历</h2></a>
<ul>
<li>先序遍历：首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树。</li>
<li>中序遍历：首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树。</li>
<li>后序遍历：首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根。</li>
</ul>
<p>下面是代码实现：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;K,V:std::fmt::Display&gt; BinaryTree&lt;K,V&gt; for Node&lt;K,V&gt; {
    fn pre_order(&amp;self) {
        println!(&quot;{}&quot;, self.value);

        if let Some(ref left) = self.left {
            left.pre_order();
        }
        if let Some(ref right) = self.right {
            right.pre_order();
        }
    }

    fn in_order(&amp;self) {
        if let Some(ref left) = self.left {
            left.in_order();
        }
        println!(&quot;{}&quot;, self.value);
        if let Some(ref right) = self.right {
            right.in_order();
        }
    }
    fn pos_order(&amp;self) {
        if let Some(ref left) = self.left {
            left.pos_order();
        }
        if let Some(ref right) = self.right {
            right.pos_order();
        }
        println!(&quot;{}&quot;, self.value);
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a测试代码" id="a测试代码"><h2>测试代码</h2></a>
<pre><pre class="playpen"><code class="language-rust">type BST&lt;K,V&gt; = Node&lt;K,V&gt;;

fn test_insert() {
    let mut root = BST::&lt;i32,i32&gt;::new(3,4);
    root.insert(2,3);
    root.insert(4,6);
    root.insert(5,5);
    root.insert(6,6);
    root.insert(1,8);
    if let Some(ref left) = root.left {
        assert_eq!(left.value, 3);
    }

    if let Some(ref right) = root.right {
        assert_eq!(right.value, 6);
        if let Some(ref right) = right.right {
            assert_eq!(right.value, 5);
        }
    }
    println!(&quot;Pre Order traversal&quot;);
    root.pre_order();
    println!(&quot;In Order traversal&quot;);
    root.in_order();
    println!(&quot;Pos Order traversal&quot;);
    root.pos_order();
}

fn main() {
    test_insert();
}
</code></pre></pre>
<a class="header" href="print.html#a练习-1" id="a练习-1"><h2>练习</h2></a>
<p>基于以上代码，修改成二叉堆的形式。</p>
<a class="header" href="print.html#a优先队列" id="a优先队列"><h1>优先队列</h1></a>
<a class="header" href="print.html#a简介-3" id="a简介-3"><h2>简介</h2></a>
<p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （largest-in，first-out）的行为特征。</p>
<blockquote>
<p>优先队列是0个或多个元素的集合，每个元素都有一个优先权或值，对优先队列执行的操作有：</p>
</blockquote>
<ol>
<li>查找;</li>
<li>插入一个新元素;</li>
<li>删除。</li>
</ol>
<p>在最小优先队列(min priority queue)中，查找操作用来搜索优先权最小的元素，删除操作用来删除该元素；对于最大优先队列(max priority queue)，查找操作用来搜索优先权最大的元素，删除操作用来删除该元素。优先权队列中的元素可以有相同的优先权，查找与删除操作可根据任意优先权进行。</p>
<a class="header" href="print.html#a优先队列的实现" id="a优先队列的实现"><h2>优先队列的实现：</h2></a>
<p>首先定义 PriorityQueue 结构体</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct PriorityQueue&lt;T&gt; where T: PartialOrd + Clone {
    pq: Vec&lt;T&gt;
}
#}</code></pre></pre>
<p>第二行的<code>where T: PartialOrd + Clone</code>指的是 PriorityQueue 存储的泛型 T 是满足 <code>PartialOrd</code> 和 <code>Clone</code> trait 约束的，意味着泛型 T 是可排序和克隆的。</p>
<p>后面是一些基本的方法实现，比较简单，就直接看代码吧。这个优先队列是基于Vec实现的，有O(1)的插入和O(n)的最大/最小值出列。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; PriorityQueue&lt;T&gt; where T: PartialOrd + Clone {
    fn new() -&gt; PriorityQueue&lt;T&gt; {
        PriorityQueue { pq: Vec::new() }
    }

    fn len(&amp;self) -&gt; usize {
        self.pq.len()
    }

    fn is_empty(&amp;self) -&gt; bool {
        self.pq.len() == 0
    }

    fn insert(&amp;mut self, value: T) {
        self.pq.push(value);
    }

    fn max(&amp;self) -&gt; Option&lt;T&gt; {
        if self.is_empty() { return None }
        let max = self.max_index();
        Some(self.pq[max].clone())
    }

    fn min(&amp;self) -&gt; Option&lt;T&gt; {
        if self.is_empty() { return None }
        let min = self.min_index();
        Some(self.pq[min].clone())
    }

    fn delete_max(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_empty() { return None; }
        let max = self.max_index();
        Some(self.pq.remove(max).clone())
    }

    fn delete_min(&amp;mut self) -&gt; Option&lt;T&gt; {
        if self.is_empty() { return None; }
        let min = self.min_index();
        Some(self.pq.remove(min).clone())
    }

    fn max_index(&amp;self) -&gt; usize {
        let mut max = 0;
        for i in 1..self.pq.len() - 1 {
            if self.pq[max] &lt; self.pq[i] {
                max = i;
            }
        }
        max
    }

    fn min_index(&amp;self) -&gt; usize {
        let mut min = 0;
        for i in 0..self.pq.len() - 1 {
            if self.pq[i] &lt; self.pq[i + 1] {
                min = i;
            }
        }
        min
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a测试代码-1" id="a测试代码-1"><h2>测试代码：</h2></a>
<pre><pre class="playpen"><code class="language-rust">fn test_keep_min() {
    let mut pq = PriorityQueue::new();
    pq.insert(3);
    pq.insert(2);
    pq.insert(1);
    pq.insert(4);
    assert!(pq.min().unwrap() == 1);
}

fn test_keep_max() {
    let mut pq = PriorityQueue::new();
    pq.insert(2);
    pq.insert(4);
    pq.insert(1);
    pq.insert(3);
    assert!(pq.max().unwrap() == 4);
}

fn test_is_empty() {
    let mut pq = PriorityQueue::new();
    assert!(pq.is_empty());
    pq.insert(1);
    assert!(!pq.is_empty());
}

fn test_len() {
    let mut pq = PriorityQueue::new();
    assert!(pq.len() == 0);
    pq.insert(2);
    pq.insert(4);
    pq.insert(1);
    assert!(pq.len() == 3);
}

fn test_delete_min() {
    let mut pq = PriorityQueue::new();
    pq.insert(3);
    pq.insert(2);
    pq.insert(1);
    pq.insert(4);
    assert!(pq.len() == 4);
    assert!(pq.delete_min().unwrap() == 1);
    assert!(pq.len() == 3);
}

fn test_delete_max() {
    let mut pq = PriorityQueue::new();
    pq.insert(2);
    pq.insert(10);
    pq.insert(1);
    pq.insert(6);
    pq.insert(3);
    assert!(pq.len() == 5);
    assert!(pq.delete_max().unwrap() == 10);
    assert!(pq.len() == 4);
}

fn main() {
    test_len();
    test_delete_max();
    test_delete_min();
    test_is_empty();
    test_keep_max();
    test_keep_min();
}
</code></pre></pre>
<a class="header" href="print.html#a练习-2" id="a练习-2"><h2>练习</h2></a>
<p>基于二叉堆实现一个优先队列，以达到O(1)的出列和O(log n)的入列</p>
<a class="header" href="print.html#a链表" id="a链表"><h1>链表</h1></a>
<a class="header" href="print.html#a链表简介" id="a链表简介"><h2>链表简介</h2></a>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 由于不必须按顺序存储，链表在给定位置插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是在有序数据中查找一个节点或者访问特定下标的节点则需要O(n)的时间，而线性表相应的时间复杂度分别是O(logn)和O(1)。</p>
<blockquote>
<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在内存或磁盘上的顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。</p>
</blockquote>
<p>下面看我们一步步实现链表：</p>
<a class="header" href="print.html#a定义链表结构" id="a定义链表结构"><h2>定义链表结构</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use List::*;

enum List {
    // Cons: 包含一个元素和一个指向下一个节点的指针的元组结构
    Cons(u32, Box&lt;List&gt;),
    // Nil: 表示一个链表节点的末端
    Nil,
}
#}</code></pre></pre>
<a class="header" href="print.html#a实现链表的方法" id="a实现链表的方法"><h2>实现链表的方法</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl List {
    // 创建一个空链表
    fn new() -&gt; List {
        // `Nil` 是 `List`类型的。因为前面我们使用了 `use List::*;`
        // 所以不需要 List::Nil 这样使用
        Nil
    }

    // 在前面加一个元素节点，并且链接旧的链表和返回新的链表
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` 也是 List 类型的
        Cons(elem, Box::new(self))
    }

    // 返回链表的长度
    fn len(&amp;self) -&gt; u32 {
        // `self` 的类型是 `&amp;List`, `*self` 的类型是 `List`,
        // 匹配一个类型 `T` 好过匹配一个引用 `&amp;T`
        match *self {
            // 因为`self`是借用的，所以不能转移 tail 的所有权
            // 因此使用 tail 的引用
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // 基本规则：所以空的链表长度都是0
            Nil =&gt; 0
        }
    }

    // 返回连链表的字符串表达形式
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` 和 `print!` 很像
                // 但是返回一个堆上的字符串去替代打印到控制台
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a代码测试" id="a代码测试"><h2>代码测试</h2></a>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut list = List::new();

    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<a class="header" href="print.html#a练习-3" id="a练习-3"><h2>练习</h2></a>
<p>基于以上代码实现一个双向循环链表。</p>
<blockquote>
<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。
循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。</p>
</blockquote>
<a class="header" href="print.html#a图" id="a图"><h1>图</h1></a>
<a class="header" href="print.html#a图的存储结构" id="a图的存储结构"><h2>图的存储结构</h2></a>
<p>图的存储结构除了要存储图中各个顶点的本身信息外，同时还要存储顶点与顶点之间的所有关系(边的信息)，因此，图的结构比较复杂，很难以数据元素在存储区中的物理位置来表示元素之间的关系，但也正是由于其任意的特性，故物理表示方法很多。常用的图的存储结构有邻接矩阵、邻接表等。</p>
<a class="header" href="print.html#a邻接矩阵表示法" id="a邻接矩阵表示法"><h2>邻接矩阵表示法</h2></a>
<p>对于一个具有n个结点的图，可以使用n*n的矩阵(二维数组)来表示它们间的邻接关系。矩阵 A(i,j) = 1 表示图中存在一条边 (Vi,Vj),而A(i,j)=0表示图中不存在边 (Vi,Vj)。
实际编程时，当图为不带权图时，可以在二维数组中存放 bool 值。</p>
<ul>
<li>A(i,j) = true 表示存在边 (Vi,Vj),</li>
<li>A(i,j) = false 表示不存在边 (Vi,Vj);</li>
</ul>
<p>当图带权值时，则可以直接在二维数值中存放权值，A(i,j) = null 表示不存在边 (Vi,Vj)。</p>
<p>下面看看我们使用邻接矩阵实现的图结构：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Node {
    nodeid: usize,
    nodename: String,
}

#[derive(Debug,Clone)]
struct Edge {
    edge: bool,
}

#[derive(Debug)]
struct Graphadj {
    nodenums: usize,
    graphadj: Vec&lt;Vec&lt;Edge&gt;&gt;,
}

impl Node {
    fn new(nodeid: usize, nodename: String) -&gt; Node {
        Node{
            nodeid: nodeid,
            nodename: nodename,
        }
    }
}
impl Edge {
    fn new() -&gt; Edge {
        Edge{
            edge: false,
        }
    }
    fn have_edge() -&gt; Edge {
        Edge{
            edge: true,
        }
    }
}

impl Graphadj {
    fn new(nums:usize) -&gt; Graphadj {
        Graphadj {
            nodenums: nums,
            graphadj: vec![vec![Edge::new();nums]; nums],
        }
    }

    fn insert_edge(&amp;mut self, v1: Node, v2:Node) {
        match v1.nodeid &lt; self.nodenums &amp;&amp; v2.nodeid&lt;self.nodenums {
            true =&gt; {
                self.graphadj[v1.nodeid][v2.nodeid] = Edge::have_edge();
                //下面这句注释去掉相当于把图当成无向图
                //self.graphadj[v2.nodeid][v1.nodeid] = Edge::have_edge();
            }
            false =&gt; {
                panic!(&quot;your nodeid is bigger than nodenums!&quot;);
            }
        }
    }
}

fn main() {
    let mut g = Graphadj::new(2);
    let v1 = Node::new(0, &quot;v1&quot;.to_string());
    let v2 = Node::new(1, &quot;v2&quot;.to_string());
    g.insert_edge(v1,v2);
    println!(&quot;{:?}&quot;, g);
}
</code></pre></pre>
<a class="header" href="print.html#a邻接表表示法" id="a邻接表表示法"><h2>邻接表表示法</h2></a>
<p>邻接表是图的一种最主要存储结构，用来描述图上的每一个点。</p>
<blockquote>
<p>**实现方式：**对图的每个顶点建立一个容器（n个顶点建立n个容器），第i个容器中的结点包含顶点Vi的所有邻接顶点。实际上我们常用的邻接矩阵就是一种未离散化每个点的边集的邻接表。</p>
</blockquote>
<ul>
<li>在有向图中，描述每个点向别的节点连的边（点 a-&gt;点 b 这种情况）。</li>
<li>在无向图中，描述每个点所有的边(点 a-&gt;点 b这种情况)</li>
</ul>
<p>与邻接表相对应的存图方式叫做边集表，这种方法用一个容器存储所有的边。</p>
<a class="header" href="print.html#a练习-4" id="a练习-4"><h2><strong>练习：</strong></h2></a>
<p>实现链接表表示法的图结构。</p>
<a class="header" href="print.html#a变量" id="a变量"><h1>变量</h1></a>
<a class="header" href="print.html#a什么是变量" id="a什么是变量"><h1>什么是变量?</h1></a>
<a class="header" href="print.html#a变量绑定-1" id="a变量绑定-1"><h1>变量绑定</h1></a>
<a class="header" href="print.html#a变量可变性" id="a变量可变性"><h1>变量可变性</h1></a>
<a class="header" href="print.html#a变量作用域" id="a变量作用域"><h1>变量作用域</h1></a>
<a class="header" href="print.html#a所有权系统" id="a所有权系统"><h1>所有权系统</h1></a>
<a class="header" href="print.html#a概述" id="a概述"><h2>概述</h2></a>
<p>所有权系统（Ownership System）是Rust语言最基本最独特也是最重要的特性之一。</p>
<p>Rust追求的目标是内存安全与运行效率，但是它却没有golang, java, python等语言的内存垃圾回收机制<code>GC</code>。</p>
<p>Rust语言声称，只要编译通过就不会崩溃（内存安全）；拥有着零或者极小的运行时开销（运行效率）。这些优点也都得益于Rust的所有权系统。</p>
<p>所有权系统，包括三个重要的组成部分：</p>
<ul>
<li><strong>Ownership</strong>（所有权）</li>
<li><strong>Borrowing</strong>（借用）</li>
<li><strong>Lifetimes</strong>（生命周期）</li>
</ul>
<p>这三个特性之间相互关联，后面章节会依次全面讲解。</p>
<blockquote>
<p><strong>提示:</strong>
Rust的所有权系统对很多初学者来说，可能会觉得难以理解，Rust的内存检查是在编译阶段完成，这个检查是非常严谨的，所以初学者在编译代码的时候，刚开始可能很难一次编译通过。
不过不要害怕：），当你一旦了解熟悉它后你会喜欢上它，并且在日后的编程中受益颇多。所有权系统需要读者慢慢体会其中的奥秘，学习过程中也可以参考官方文档。</p>
</blockquote>
<a class="header" href="print.html#a什么是所有权" id="a什么是所有权"><h1>什么是所有权？</h1></a>
<p>Rust 的核心功能（之一）是 <strong>所有权</strong>（<em>ownership</em>）。虽然该功能很容易解释，但它对语言的其他部分有着深刻的影响。</p>
<p>所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。</p>
<p>因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应。好消息是随着你对 Rust 和所有权系统的规则越来越有经验，你就越能自然地编写出安全和高效的代码。持之以恒！</p>
<p>当你理解了所有权，你将有一个坚实的基础来理解那些使 Rust 独特的功能。在本章中，你将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：字符串。</p>
<a class="header" href="print.html#a所有权规则" id="a所有权规则"><h2>所有权规则</h2></a>
<p>首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：</p>
<blockquote>
<ol>
<li>Rust 中的每一个值(或称为：资源)都有一个被称为其 <strong>所有者</strong>（<em>owner</em>）的变量。</li>
<li>值(或资源)，有且只有一个所有者。</li>
<li>当所有者（就是变量）离开作用域，相对应的值(或资源)将被丢弃。</li>
</ol>
</blockquote>
<a class="header" href="print.html#a变量作用域-1" id="a变量作用域-1"><h2>变量作用域</h2></a>
<p>我们已经在第二章完成一个 Rust 程序示例。既然我们已经掌握了基本语法，将不会在之后的例子中包含 <code>fn main() {</code> 代码，所以如果你是一路跟过来的，必须手动将之后例子的代码放入一个 <code>main</code> 函数中。这样，例子将显得更加简明，使我们可以关注实际细节而不是样板代码。</p>
<p>在所有权的第一个例子中，我们看看一些变量的 <strong>作用域</strong>（<em>scope</em>）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;hello&quot;;
#}</code></pre></pre>
<p>变量 <code>s</code> 绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的。示例 4-1 的注释标明了变量 <code>s</code> 在何处是有效的。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{                      // s 在这里无效, 它尚未声明
    let s = &quot;hello&quot;;   // 从此处起，s 是有效的

    // 使用 s
}                      // 此作用域已结束，s 不再有效
#}</code></pre></pre>
<p><span class="caption">示例 4-1：一个变量和其有效的作用域</span></p>
<p>换句话说，这里有两个重要的时间点：</p>
<ul>
<li>当 <code>s</code> <strong>进入作用域</strong> 时，它就是有效的。</li>
<li>这一直持续到它 <strong>离开作用域</strong> 为止。</li>
</ul>
<p>目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍 <code>String</code> 类型。</p>
<a class="header" href="print.html#string-类型" id="string-类型"><h2><code>String</code> 类型</h2></a>
<p>为了演示所有权的规则，我们需要一个比第三章 “数据类型” 中讲到的都要复杂的数据类型。前面介绍的类型都是存储在栈上的并且当离开作用域时被移出栈，不过我们需要寻找一个存储在堆上的数据来探索 Rust 是如何知道该在何时清理数据的。</p>
<p>这里使用 <code>String</code> 作为例子，并专注于 <code>String</code> 与所有权相关的部分。这些方面也同样适用于标准库提供的或你自己创建的其他复杂数据类型。在第八章会更深入地讲解 <code>String</code>。</p>
<p>我们已经见过字符串字面值，字符串值被硬编码进程序里。字符串字面值是很方便的，不过他们并不适合使用文本的每一种场景。原因之一就是他们是不可变的。另一个原因是并不是所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，<code>String</code>。这个类型被分配到堆上，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面值来创建 <code>String</code>，如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello&quot;);
#}</code></pre></pre>
<p>这两个冒号（<code>::</code>）是运算符，允许将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间（namespace）下，而不需要使用类似 <code>string_from</code> 这样的名字。在第五章的 “方法语法”（“Method Syntax”）部分会着重讲解这个语法而且在第七章的 “模块定义” 中会讲到模块的命名空间。</p>
<p><strong>可以</strong> 修改此类字符串 ：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值

println!(&quot;{}&quot;, s); // 将打印 `hello, world!`
#}</code></pre></pre>
<p>那么这里有什么区别呢？为什么 <code>String</code> 可变而字面值却不行呢？区别在于两个类型对内存的处理上。</p>
<a class="header" href="print.html#a内存与分配" id="a内存与分配"><h2>内存与分配</h2></a>
<p>就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p>
<p>对于 <code>String</code> 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p>
<ul>
<li>必须在运行时向操作系统请求内存。</li>
<li>需要一个当我们处理完 <code>String</code> 时将内存返回给操作系统的方法。</li>
</ul>
<p>第一部分由我们完成：当调用 <code>String::from</code> 时，它的实现 (<em>implementation</em>) 请求其所需的内存。这在编程语言中是非常通用的。</p>
<p>然而，第二部分实现起来就各有区别了。在有 <strong>垃圾回收</strong>（<em>garbage collector</em>，<em>GC</em>）的语言中， GC 记录并清除不再使用的内存，而我们并不需要关心它。没有 GC 的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 <code>allocate</code> 配对一个 <code>free</code>。</p>
<p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例 4-1 中作用域例子的一个使用 <code>String</code> 而不是字符串字面值的版本：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的

    // 使用 s
}                                  // 此作用域已结束，
                                   // s 不再有效
#}</code></pre></pre>
<p>这是一个将 <code>String</code> 需要的内存返回给操作系统的很自然的位置：当 <code>s</code> 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <code>drop</code>，在这里 <code>String</code> 的作者可以放置释放内存的代码。Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>。</p>
<blockquote>
<p>注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 <strong>资源获取即初始化</strong>（<em>Resource Acquisition Is Initialization (RAII)</em>）。如果你使用过 RAII 模式的话应该对 Rust 的 <code>drop</code> 函数并不陌生。</p>
</blockquote>
<p>这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。</p>
<a class="header" href="print.html#a变量与数据交互的方式一移动" id="a变量与数据交互的方式一移动"><h3>变量与数据交互的方式（一）：移动</h3></a>
<p>Rust 中的多个变量可以采用一种独特的方式与同一数据交互。让我们看看示例 4-2 中一个使用整型的例子。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;
#}</code></pre></pre>
<p><span class="caption">示例 4-2：将变量 <code>x</code> 的整数值赋给 <code>y</code></span></p>
<p>我们大致可以猜到这在干什么：“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”。现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。这也正是事实上发生了的，因为正数是有已知固定大小的简单值，所以这两个 <code>5</code> 被放入了栈中。</p>
<p>现在看看这个 <code>String</code> 版本：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
#}</code></pre></pre>
<p>这看起来与上面的代码非常类似，所以我们可能会假设他们的运行方式也是类似的：也就是说，第二行可能会生成一个 <code>s1</code> 的拷贝并绑定到 <code>s2</code> 上。不过，事实上并不完全是这样。</p>
<p>看看图 4-1 以了解 <code>String</code> 的底层会发生什么。<code>String</code> 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。</p>
<p><img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-1：将值 <code>&quot;hello&quot;</code> 绑定给 <code>s1</code> 的 <code>String</code> 在内存中的表现形式</span></p>
<p>长度表示 <code>String</code> 的内容当前使用了多少字节的内存。容量是 <code>String</code> 从操作系统总共获取了多少字节的内存。长度与容量的区别是很重要的，不过在当前上下文中并不重要，所以现在可以忽略容量。</p>
<p>当我们将 <code>s1</code> 赋值给 <code>s2</code>，<code>String</code> 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。换句话说，内存中数据的表现如图 4-2 所示。</p>
<p><img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-2：变量 <code>s2</code> 的内存表现，它有一份 <code>s1</code> 指针、长度和容量的拷贝</span></p>
<p>这个表现形式看起来 <strong>并不像</strong> 图 4-3 中的那样，如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。如果 Rust 这么做了，那么操作 <code>s2 = s1</code> 在堆上数据比较大的时候会对运行时性能造成非常大的影响。</p>
<p><img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-3：另一个 <code>s2 = s1</code> 时可能的内存表现，如果 Rust 同时也拷贝了堆上的数据的话</span></p>
<p>之前我们提到过当变量离开作用域后，Rust 自动调用 <code>drop</code> 函数并清理变量的堆内存。不过图 4-2 展示了两个数据指针指向了同一位置。这就有了一个问题：当 <code>s2</code> 和 <code>s1</code> 离开作用域，他们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放</strong>（<em>double free</em>）的错误，也是之前提到过的内存安全性 bug 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p>
<p>为了确保内存安全，这种场景下 Rust 的处理有另一个细节值得注意。与其尝试拷贝被分配的内存，Rust 则认为 <code>s1</code> 不再有效，因此 Rust 不需要在 <code>s1</code> 离开作用域后清理任何东西。看看在 <code>s2</code> 被创建之后尝试使用 <code>s1</code> 会发生什么；这段代码不能运行：</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<p>你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>如果你在其他语言中听说过术语 <strong>浅拷贝</strong>（<em>shallow copy</em>）和 <strong>深拷贝</strong>（<em>deep copy</em>），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 <strong>移动</strong>（<em>move</em>），而不是浅拷贝。上面的例子可以解读为 <code>s1</code> 被 <strong>移动</strong> 到了 <code>s2</code> 中。那么具体发生了什么，如图 4-4 所示。</p>
<p><img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">图 4-4：<code>s1</code> 无效之后的内存表现</span></p>
<p>这样就解决了我们的问题！因为只有 <code>s2</code> 是有效的，当其离开作用域，它就释放自己的内存，完毕。</p>
<p>另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 <strong>自动</strong> 的复制可以被认为对运行时性能影响较小。</p>
<a class="header" href="print.html#a变量与数据交互的方式二克隆" id="a变量与数据交互的方式二克隆"><h3>变量与数据交互的方式（二）：克隆</h3></a>
<p>如果我们 <strong>确实</strong> 需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的通用函数。第五章会讨论方法语法，不过因为方法在很多语言中是一个常见功能，所以之前你可能已经见过了。</p>
<p>这是一个实际使用 <code>clone</code> 方法的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>这段代码能正常运行，并且明确产生图 4-3 中行为，这里堆上的数据 <strong>确实</strong> 被复制了。</p>
<p>当出现 <code>clone</code> 调用时，你知道一些特定的代码被执行而且这些代码可能相当消耗资源。你很容易察觉到一些不寻常的事情正在发生。</p>
<a class="header" href="print.html#a只在栈上的数据拷贝" id="a只在栈上的数据拷贝"><h3>只在栈上的数据：拷贝</h3></a>
<p>这里还有一个没有提到的小窍门。这些代码使用了整型并且是有效的，他们是示例 4-2 中的一部分：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过 <code>x</code> 依然有效且没有被移动到 <code>y</code> 中。</p>
<p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它。</p>
<p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上（第十章详细讲解 trait）。如果一个类型拥有 <code>Copy</code> trait，一个旧的变量在将其赋值给其他变量后仍然可用。Rust 不允许自身或其任何部分实现了 <code>Drop</code> trait 的类型使用 <code>Copy</code> trait。如果我们对其值离开作用域时需要特殊处理的类型使用 <code>Copy</code> 注解，将会出现一个编译时错误。要学习如何为你的类型增加 <code>Copy</code> 注解，请阅读附录 C 中的 “可派生的 trait”。</p>
<p>那么什么类型是 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则，任何简单标量值的组合可以是 <code>Copy</code> 的，不需要分配内存或某种形式资源的类型是 <code>Copy</code> 的。如下是一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型，比如 <code>u32</code>。</li>
<li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li>
<li>所有浮点数类型，比如 <code>f64</code>。</li>
<li>字符类型，<code>char</code>。</li>
<li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li>
</ul>
<a class="header" href="print.html#a所有权与函数" id="a所有权与函数"><h2>所有权与函数</h2></a>
<p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。示例 4-3 使用注释展示变量何时进入和离开作用域：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s 进入作用域

    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
  // 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!(&quot;{}&quot;, some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!(&quot;{}&quot;, some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
</code></pre></pre>
<p><span class="caption">示例 4-3：带有所有权和作用域注释的函数</span></p>
<p>当尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code> 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 <code>main</code> 函数中添加使用 <code>s</code> 和 <code>x</code> 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。</p>
<a class="header" href="print.html#a返回值与作用域" id="a返回值与作用域"><h2>返回值与作用域</h2></a>
<p>返回值也可以转移所有权。示例 4-4 与示例 4-3 一样带有类似的注释。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership 将返回值
                                        // 移给 s1

    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到
                                        // takes_and_gives_back 中, 
                                        // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
  // 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -&gt; String {             // gives_ownership 将返回值移动给
                                             // 调用它的函数

    let some_string = String::from(&quot;hello&quot;); // some_string 进入作用域.

    some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域

    a_string  // 返回 a_string 并移出给调用的函数
}
</code></pre></pre>
<p><span class="caption">示例 4-4: 转移返回值的所有权</span></p>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p>
<p>在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p>
<p>我们可以使用元组来返回多个值，如示例 4-5 所示。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() 返回字符串的长度

    (s, length)
}
</code></pre></pre>
<p><span class="caption">示例 4-5: 返回参数的所有权</span></p>
<p>但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个功能，叫做 <strong>引用</strong>（<em>references</em>）。</p>
<a class="header" href="print.html#a所有权ownership" id="a所有权ownership"><h1><strong>所有权（Ownership)</strong></h1></a>
<p>在进入正题之前，大家先回忆下一般的编程语言知识。
对于一般的编程语言，通常会先声明一个变量，然后初始化它。
例如在C语言中：</p>
<pre><code class="language-c">int* foo() {
    int a;          // 变量a的作用域开始
    a = 100;
    char *c = &quot;xyz&quot;;   // 变量c的作用域开始
    return &amp;a;
}                   // 变量a和c的作用域结束
</code></pre>
<p>尽管可以编译通过，但这是一段非常糟糕的代码，现实中我相信大家都不会这么去写。变量a和c都是局部变量，函数结束后将局部变量a的地址返回，但局部变量<code>a</code>存在栈中，在离开作用域后，局部变量所申请的栈上内存都会被系统回收，从而造成了(悬挂指针)<code>Dangling Pointer</code>的问题。<strong>这是一个非常典型的内存安全问题。很多编程语言都存在类似这样的内存安全问题</strong>。再来看变量<code>c</code>，<code>c</code>的值是常量字符串，存储于常量区，可能这个函数我们只调用了一次，我们可能不再想使用这个字符串，但<code>xyz</code>只有当整个程序结束后系统才能回收这片内存，这点让程序员是不是也很无奈？</p>
<blockquote>
<p>备注：对于<code>xyz</code>，可根据实际情况，通过堆的方式，手动管理（申请和释放）内存。</p>
</blockquote>
<p>所以，内存安全和内存管理通常是程序员眼中的两大头疼问题。
令人兴奋的是，Rust 语言却不再让你担心内存安全问题，也不用再操心内存管理的麻烦，那Rust是如何做到这一点的？请往下看。</p>
<a class="header" href="print.html#a绑定binding" id="a绑定binding"><h2><strong>绑定（Binding）</strong></h2></a>
<p><strong>重要</strong>：首先必须强调下，准确地说Rust中并没有<code>变量</code>这一概念，而应该称为<code>标识符</code>，目标<code>资源</code>(内存，存放value)<code>绑定</code>到这个<code>标识符</code>：那么，以后经常说的<code>赋值</code>概念在Rust编程中，要尽量用<code>绑定</code>这个说法。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let x: i32;       // 标识符x, 没有绑定任何资源
    let y: i32 = 100; // 标识符y，绑定资源100
}
#}</code></pre></pre>
<p>好了，我们继续看下以下一段Rust代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let a: i32;
    println!(&quot;{}&quot;, a);
}
#}</code></pre></pre>
<p>上面定义了一个i32类型的标识符<code>a</code>，如果你直接<code>println!</code>，你会收到一个error报错：</p>
<pre><code class="language-text">&gt; error: use of possibly uninitialized variable: `a`
</code></pre>
<p>这是<strong>因为Rust并不会像其他语言一样可以为变量默认初始化值，Rust明确规定变量的初始值必须由程序员自己决定</strong>。</p>
<p>正确的做法：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let a: i32;
    a = 100; //必须初始化a
    println!(&quot;{}&quot;, a);
}
#}</code></pre></pre>
<p>其实，<code>let</code>关键字并不只是声明变量的意思，它还有一层特殊且重要的概念-<code>绑定</code>。通俗的讲，<code>let</code>关键字可以把一个标识符和一段内存区域做“绑定”，绑定后，这段内存就被这个标识符所拥有，这个标识符也成为这段内存的唯一<strong>所有者</strong>。
所以，<code>a = 100</code>发生了这么几个动作，首先在栈内存上分配一个<code>i32</code>的资源，并填充值<code>100</code>，随后，把这个资源与<code>a</code>做绑定，让<code>a</code>成为资源的所有者(Owner)。</p>
<a class="header" href="print.html#a作用域" id="a作用域"><h2><strong>作用域</strong></h2></a>
<p>像C语言一样，Rust通过<code>{}</code>大括号定义作用域：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    {
        let a: i32 = 100;
    }
    println!(&quot;{}&quot;, a);
}
#}</code></pre></pre>
<p>编译后会得到如下<code>error</code>错误：</p>
<pre><code class="language-text">error: unresolved name `a` [E0425]
println!(&quot;{}&quot;, a);
</code></pre>
<p>像C语言一样，在局部变量离开作用域后，变量随即会被销毁；<strong>但不同是，Rust会连同变量绑定的内存，不管是否为常量字符串，连同所有者变量一起被销毁释放</strong>。所以上面的例子，a销毁后再次访问a就会提示无法找到变量<code>a</code>的错误。这些所有的一切都是在编译过程中完成的。</p>
<a class="header" href="print.html#a移动语义move" id="a移动语义move"><h2><strong>移动语义（move）</strong></h2></a>
<p>先看如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let a: String = String::from(&quot;xyz&quot;);
    let b = a;
    println!(&quot;{}&quot;, a);
}
#}</code></pre></pre>
<p>编译后会得到如下的报错：</p>
<pre><code class="language-text">&gt; c.rs:4:20: 4:21 error: use of moved value: `a` [E0382]
c.rs:4     println!(&quot;{}&quot;, a);
</code></pre>
<p>错误的意思是在<code>println</code>中访问了被<code>moved</code>的变量<code>a</code>。那为什么会有这种报错呢？具体含义是什么？
在Rust中，和“绑定”概念相辅相成的另一个机制就是“转移move所有权”，意思是，<strong>可以把资源的所有权(ownership)从一个绑定转移（move）到另一个绑定上</strong>，这个操作同样通过<code>let</code>关键字完成，和绑定不同的是，<code>=</code>两边的左值和右值均为两个标识符：</p>
<pre><code class="language-rust ignore">语法：
    let 标识符A = 标识符B;  // 把“B”绑定资源的所有权转移给“A”
</code></pre>
<p>move前后的内存示意如下：</p>
<blockquote>
<p><strong>Before move:</strong><br />
a  &lt;=&gt; 内存(地址：<strong>A</strong>，内容：&quot;xyz&quot;)<br />
<strong>After move:</strong><br />
a<br />
b  &lt;=&gt; 内存(地址：<strong>A</strong>，内容：&quot;xyz&quot;)</p>
</blockquote>
<p>被move的变量不可以继续被使用。否则提示错误<code>error: use of moved value</code>。</p>
<p>这里有些人可能会疑问，move后，如果变量A和变量B离开作用域，所对应的内存会不会造成 <code>双释放</code>“Double Free”的问题？
答案是否定的，
<strong>Rust规定，只有资源的所有者销毁后才释放内存，而无论这个资源是否被多次<code>move</code>，同一时刻只有一个<code>owner</code>，所以该资源的内存也只会被<code>free</code>一次</strong>。
通过这个机制，就保证了内存安全。是不是觉得很强大？</p>
<a class="header" href="print.html#copy特性" id="copy特性"><h2><strong>Copy特性</strong></h2></a>
<p>有读者仿照“move”小节中的例子写了下面一个例子，然后说“a被move后是可以访问的”：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: i32 = 100;
let b = a;
println!(&quot;{}&quot;, a);
#}</code></pre></pre>
<p>编译确实可以通过，输出为<code>100</code>。这是为什么呢，是不是跟move小节里的结论相悖了？
其实不然，这其实是根据变量类型是否实现<code>Copy</code>特性决定的。对于实现<code>Copy</code>特性的变量，在move时会拷贝资源到新内存区域，并把新内存区域的资源<code>binding</code>为<code>b</code>。</p>
<blockquote>
<p><strong>Before move:</strong><br />
a  &lt;=&gt; 内存(地址：<strong>A</strong>，内容：100)<br />
<strong>After move:</strong><br />
a  &lt;=&gt; 内存(地址：<strong>A</strong>，内容：100)<br />
b  &lt;=&gt; 内存(地址：<strong>B</strong>，内容：100)</p>
</blockquote>
<p>move前后的<code>a</code>和<code>b</code>对应资源内存的地址不同。</p>
<p>在Rust中，基本数据类型(Primitive Types)均实现了Copy特性，包括i8, i16, i32, i64, usize, u8, u16, u32, u64, f32, f64, (), bool, char等等。其他支持Copy的数据类型可以参考官方文档的<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html" title="Copy Trait">Copy章节</a>。</p>
<a class="header" href="print.html#a浅拷贝与深拷贝" id="a浅拷贝与深拷贝"><h2><strong>浅拷贝与深拷贝</strong></h2></a>
<p>前面例子中 <strong><code>move</code></strong>, String和i32用法的差异，其实和很多面向对象编程语言中“浅拷贝”和“深拷贝”的区别类似。</p>
<ul>
<li>对于基本数据类型来说，“深拷贝”和“浅拷贝“产生的效果相同。</li>
<li>对于引用对象类型来说，”浅拷贝“更像仅仅拷贝了对象的内存地址。</li>
</ul>
<p>如果我们想实现对<code>String</code>的”深拷贝“怎么办？  可以直接调用<code>String</code>的<code>Clone</code>特性实现对内存的值拷贝而不是简单的地址拷贝。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let a: String = String::from(&quot;xyz&quot;);
    let b = a.clone();  // &lt;-注意此处的clone
    println!(&quot;{}&quot;, a);
}
#}</code></pre></pre>
<p>这个时候可以编译通过，并且成功打印&quot;xyz&quot;。</p>
<p>clone后的效果等同如下：</p>
<blockquote>
<p><strong>Before move:</strong><br />
a  &lt;=&gt; 内存(地址：<strong>A</strong>，内容：&quot;xyz&quot;)<br />
<strong>After move:</strong><br />
a  &lt;=&gt; 内存(地址：<strong>A</strong>，内容：&quot;xyz&quot;)<br />
b  &lt;=&gt; 内存(地址：<strong>B</strong>，内容：&quot;xyz&quot;)</p>
</blockquote>
<p>注意，然后a和b对应的资源值相同，但是内存地址并不一样。</p>
<a class="header" href="print.html#a可变性" id="a可变性"><h2><strong>可变性</strong></h2></a>
<p>通过上面，我们已经已经了解了<code>变量声明</code>、<code>值（资源）绑定</code>、以及<code>移动move语义</code>等等相关知识，但是还没有进行过修改<code>变量值</code>（<sub>我们暂且还这么叫，这样才能觉得和其他语言感觉一样</sub>）这么简单的操作，在其他语言中看似简单到不值得一提的事，却在<code>Rust</code>中暗藏玄机。</p>
<p>按照其他编程语言思维，修改一个<code>变量值</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: i32 = 100;
a = 200;
#}</code></pre></pre>
<p>很抱歉，这么简单的操作依然还会报错：</p>
<blockquote>
<p>error: re-assignment of immutable variable <code>a</code> [E0384]
<anon>:3     a = 200;</p>
</blockquote>
<p>不能对<strong>不可变绑定</strong>变量重新赋值（绑定资源）。如果要修改值，必须用关键字mut声明绑定为可变的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut a: i32 = 100;  // 通过关键字mut声明a是可变的
a = 200;
#}</code></pre></pre>
<p>想到“不可变绑定”，我们第一时间会想到了<code>const</code>常量，但<strong>不可变绑定</strong>与<code>const</code>常量是完全不同的两种概念；</p>
<p>首先，“不可变”准确地应该称为“不可变绑定”，是用来约束绑定行为的，“不可变绑定”后不能通过原“所有者”更改资源内容。</p>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = vec![1, 2, 3];  //不可变绑定, a &lt;=&gt; 内存区域A(1,2,3)
let mut a = a;  //可变绑定， a &lt;=&gt; 内存区域A(1,2,3), 注意此a已非上句a，只是名字一样而已
a.push(4);
println!(&quot;{:?}&quot;, a);  //打印：[1, 2, 3, 4]
#}</code></pre></pre>
<p>“可变绑定”后，<code>目标内存</code>(就是资源所有者标识，如：let a 中的a)，还是同一块，只不过，可以通过新绑定的a去修改这片内存了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut a: &amp;str = &quot;abc&quot;;   //可变绑定,           a &lt;=&gt; 内存区域A(&quot;abc&quot;)
a = &quot;xyz&quot;;                 //绑定到另一内存区域, a &lt;=&gt; 内存区域B(&quot;xyz&quot;)
println!(&quot;{:?}&quot;, a);       //打印：&quot;xyz&quot;
#}</code></pre></pre>
<p>上面这种情况不要混淆了，<code>a = &quot;xyz&quot;</code>表示<code>a</code>绑定目标资源发生了变化。</p>
<p>其实，Rust中也有const常量，常量不存在“绑定”之说，和其他语言的常量含义相同：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const PI:f32 = 3.14;
#}</code></pre></pre>
<blockquote>
<p>重点：
可变性的目的就是严格区分绑定的可变性，以便编译器可以更好的优化，也提高了内存安全性。</p>
</blockquote>
<a class="header" href="print.html#a高级copy特性" id="a高级copy特性"><h2><strong>高级Copy特性</strong></h2></a>
<p>在前面的小节有简单了解Copy特性，接下来我们来深入了解下这个特性。
Copy特性定义在标准库<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html">std::marker::Copy</a>中：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Copy: Clone { }
#}</code></pre></pre>
<p>一旦一种类型实现了Copy特性，这就意味着这种类型可以通过的简单的位(bits)拷贝实现拷贝。从前面知识我们知道“绑定”存在move语义（所有权转移），但是，一旦这种类型实现了Copy特性，会先拷贝内容到<strong>新内存区域</strong>，然后把新内存区域和这个标识符做绑定。</p>
<p><strong>哪些情况下我们自定义的类型（如某个Struct等）可以实现Copy特性？</strong>
只要这种类型的属性类型都实现了Copy特性，那么这个类型就可以实现Copy特性。</p>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo {     // 可实现Copy特性
    a: i32,      // 该属性已经实现了Copy特性
    b: bool,     // 该属性已经实现了Copy特性
}

struct Bar {     // 无法实现Copy特性
    l: Vec&lt;i32&gt;, // 该属性没有实现Copy特性
}
#}</code></pre></pre>
<p>因为<code>Foo</code>的属性<code>a</code>和<code>b</code>的类型<code>i32</code>和<code>bool</code>均实现了<code>Copy</code>特性，所以<code>Foo</code>也是可以实现Copy特性的。但对于<code>Bar</code>来说，它的属性<code>l</code>是<code>Vec&lt;T&gt;</code>类型，这种类型并没有实现<code>Copy</code>特性，所以<code>Bar</code>也是无法实现<code>Copy</code>特性的。</p>
<p><strong>那么我们如何来实现<code>Copy</code>特性呢？</strong>
有两种方式可以实现。</p>
<ol>
<li>
<p><strong>通过<code>derive</code>让Rust编译器自动实现</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Copy, Clone)]
struct Foo {
    a: i32,
    b: bool,
}
#}</code></pre></pre>
<p>编译器会自动检查<code>Foo</code>的所有属性是否实现了<code>Copy</code>特性，一旦检查通过，便会为<code>Foo</code>自动实现<code>Copy</code>特性。</p>
</li>
<li>
<p><strong>手动实现<code>Clone</code>和<code>Copy</code> trait</strong></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Foo {
    a: i32,
    b: bool,
}
impl Copy for Foo {}
impl Clone for Foo {
    fn clone(&amp;self) -&gt; Foo {
        Foo{a: self.a, b: self.b}
    }
}
fn main() {
    let x = Foo{ a: 100, b: true};
    let mut y = x;
    y.b = false;

    println!(&quot;{:?}&quot;, x);  //打印：Foo { a: 100, b: true }
    println!(&quot;{:?}&quot;, y);  //打印：Foo { a: 100, b: false }
}

</code></pre></pre>
<p>从结果我们发现<code>let mut y = x</code>后，<code>x</code>并没有因为所有权<code>move</code>而出现不可访问错误。
因为<code>Foo</code>继承了<code>Copy</code>特性和<code>Clone</code>特性，所以例子中我们实现了这两个特性。</p>
</li>
</ol>
<a class="header" href="print.html#a高级move-移动语义" id="a高级move-移动语义"><h2><strong>高级move 移动语义</strong></h2></a>
<p>我们从前面的小节了解到，<code>let</code>绑定会发生所有权转移的情况，但<code>ownership</code>转移却因为资源类型是否实现<code>Copy</code>特性而行为不同：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: T = something;
let y = x;
#}</code></pre></pre>
<ul>
<li>类型<code>T</code>没有实现<code>Copy</code>特性：<code>x</code>所有权转移到<code>y</code>。</li>
<li>类型<code>T</code>实现了<code>Copy</code>特性：拷贝<code>x</code>所绑定的<code>资源</code>为<code>新资源</code>，并把<code>新资源</code>的所有权绑定给<code>y</code>，<code>x</code>依然拥有原资源的所有权。</li>
</ul>
<a class="header" href="print.html#move关键字" id="move关键字"><h3><strong>move关键字</strong></h3></a>
<p>move关键字常用在闭包中，强制闭包获取所有权。</p>
<p>例子1：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: i32 = 100;
    let some_closure_fn = move |i: i32| i + x;
    let y = some_closure_fn(2);
    println!(&quot;x={}, y={}&quot;, x, y);

    let other_closure_fn = |i: i32| i + x;
    let z = other_closure_fn(5);
    println!(&quot;x={}, z={}&quot;, x, z);
}
</code></pre></pre>
<p>结果：</p>
<pre><code class="language-text igorn">x=100, y=102
x=100, z=105
</code></pre>
<p>注意:</p>
<p><strong>例子1，是比较特别的。使用 <code>move</code> ，或者不使用 <code>move</code> 对结果都没什么影响。</strong></p>
<p>因为<code>x</code>绑定的资源是<code>i32</code>类型，属于 <code>primitive type</code> （原始类型），原生都实现了 <code>Copy trait</code>，所以在闭包使用 <code>move</code> 的时候，是先 copy 了<code>x</code> ，在 move 的时候是 move 了这份 clone 的 <code>x</code>，所以后面的 <code>println!</code>引用 <code>x</code> 的时候没有报错。</p>
<p>例子2：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = move |c: char| x.push(c);
    let y = some_closure('d');
    println!(&quot;x={:?}&quot;, x);
}
</code></pre></pre>
<p>报错：</p>
<pre><code class="language-text">error: use of moved value: `x` [E0382]
&lt;anon&gt;:5     println!(&quot;x={:?}&quot;, x);
</code></pre>
<p>由于，String 类型，没有实现 <code>Copy trait</code>,
所以在使用 <code>move</code> 关键字，会把闭包中的外部变量的所有权move到包体内，发生了所有权转移，这是问题的关键所在。
所以<code>println</code>访问 <code>x</code> 会出现如上错误。如果我们去掉<code>println</code>就可以编译通过。</p>
<p>那么，如果我们想在包体外依然访问x，即x不失去所有权，怎么办？</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    {
        let mut some_closure = |c: char| x.push(c);
        some_closure('d');
    }
    println!(&quot;x={:?}&quot;, x);  //成功打印：x=&quot;abcd&quot;
}
</code></pre></pre>
<p>我们只是去掉了<code>move</code> 关键字，去掉<code>move</code> 关键字后，<strong>闭包包体内</strong> 就会对 <code>x</code> 进行了<strong>可变借用</strong>，而不是“剥夺”<code>x</code>的所有权，细心的同学还注意到我们在前后还加了<code>{}</code>大括号作用域，是为了作用域结束后让<strong>可变借用</strong>失效，这样<code>println</code>才可以成功访问并打印我们期待的内容。</p>
<p>关于“<strong>Borrowing借用</strong>”知识我们会在下一个大节中详细讲解。</p>
<a class="header" href="print.html#a引用借用referencesborrowing" id="a引用借用referencesborrowing"><h1><strong>引用&amp;借用（References&amp;Borrowing）</strong></h1></a>
<p>例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    {
        let mut some_closure = |c: char| x.push(c);
        some_closure('d');
    }
    println!(&quot;x={:?}&quot;, x);  //成功打印：x=&quot;abcd&quot;
}
</code></pre></pre>
<p>我们只是去掉了<code>move</code> 关键字，去掉<code>move</code> 关键字后，<strong>闭包包体内</strong> 就会对 <code>x</code> 进行了<strong>可变借用</strong>，而不是“剥夺”<code>x</code>的所有权，细心的同学还注意到我们在前后还加了<code>{}</code>大括号作用域，是为了作用域结束后让<strong>可变借用</strong>失效，这样<code>println</code>才可以成功访问并打印我们期待的内容。</p>
<hr />
<p>如上所示，<code>Owership</code> 让我们改变一个变量的值变得“复杂”，那能否像其他编程语言那样随意改变变量的值呢？</p>
<p>答案是有的。</p>
<p><strong>所有权系统</strong>允许我们通过<code>“Borrowing”</code>的方式达到这个目的。
这个机制非常像其他编程语言中的“读写锁”，即同一时刻，只能拥有一个“写锁”，或只能拥有多个“读锁”，不允许“写锁”和“读锁”在同一时刻同时出现。当然这也是数据读写过程中保障一致性的典型做法。只不过Rust是在编译中完成这个(Borrowing)检查的，而不是在运行时，这也就是为什么其他语言程序在运行过程中，容易出现死锁或者野指针的问题。</p>
<p>通过 <code>&amp;</code> 符号完成<code>Borrowing</code>：</p>
<p>在继续说明之前，我们先把上面的例子做几个大胆尝试。可能，会让你大吃一惊。</p>
<ol>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = |c: char| &amp;x.push(c);
    some_closure('E');
    println!(&quot;x={:?}&quot;, x); // BIG PROBLEM
}
</code></pre></pre>
</li>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = |c: char| &amp;x.push(c);
    some_closure('E');
    println!(&quot;x={:?}&quot;, &amp;x); // BIG PROBLEM
}
</code></pre></pre>
</li>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = |c: char| mut &amp;x.push(c);
    some_closure('E');
    println!(&quot;x={:?}&quot;, x);
}
</code></pre></pre>
</li>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = |c: char| &amp;mut x.push(c);
    some_closure('E');
    println!(&quot;x={:?}&quot;, x);
}
</code></pre></pre>
</li>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = move |c: char| x.push(c);
    some_closure('F');
    println!(&quot;x={:?}&quot;, x);
}
</code></pre></pre>
</li>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = move |c: char| &amp;x.push(c);
    some_closure('F');
    println!(&quot;x={:?}&quot;, x);
}
</code></pre></pre>
</li>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = move |c: char| &amp;x.push(c);
    some_closure('F');
    println!(&quot;x={:?}&quot;, &amp;x);
}
</code></pre></pre>
</li>
<li>
<p>代码</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: String = String::from(&quot;abc&quot;);
    let mut some_closure = move |c: char| x.push(c);
    some_closure('F');
    x = String::from(&quot;246654&quot;);
    println!(&quot;x={:?}&quot;, x);
}
</code></pre></pre>
</li>
</ol>
<p>关键要理解：</p>
<ul>
<li>
<p>没有<code>move</code> 关键字的时候，<strong>闭包包体内</strong> 就会对 <code>x</code> 进行了<strong>可变借用</strong>，而不是“剥夺”<code>x</code>的所有权。</p>
</li>
<li>
<p>有<code>move</code>关键字的时候，<code>x</code>所绑定的资源，发生了<code>所有权</code>移动，转移到了<strong>闭包包体内</strong>，这是作用域的变化，跳出该<strong>闭包包体内</strong>的作用域之外，就无法通过 <code>x</code> 获得该资源的所有权。</p>
</li>
</ul>
<hr />
<p>现在，我们继续来说明<code>“Borrowing”</code>的方式。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);
    let y = &amp;x;
    println!(&quot;x={:?}, y={:?}&quot;, x, y);
}
</code></pre></pre>
<p><code>Borrowing(&amp;x)</code> 并不会发生<code>所有权</code> moved (移动语义)，所以<code>println!</code>可以同时访问x和y。
通过引用，就可以对普通类型完成修改。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: i32 = 100;
    {
        let y: &amp;mut i32 = &amp;mut x;
        *y += 2;
    }
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<a class="header" href="print.html#a借用与引用的区别" id="a借用与引用的区别"><h2>借用与引用的区别</h2></a>
<p>借用与引用是一种相辅相成的关系，说白了，就是一个意思。若B是对A的引用，也可称之为B借用了A。</p>
<p>很相近对吧，但是借用一词本意为要归还。所以在Rust用引用时，一定要注意应该在何处何时正确的“归回”借用/引用。
最后面的“高级”小节会详细举例。</p>
<a class="header" href="print.html#a规则" id="a规则"><h3>规则</h3></a>
<ol>
<li>同一时刻，可变变量绑定，最多只有一个可变借用（&amp;mut T）。</li>
<li>同一时刻，不可变变量绑定，可有0个或多个不可变借用（&amp;T）但不能有任何可变借用。</li>
<li>借用在离开作用域后释放。</li>
<li>在可变借用释放前不可访问源变量。</li>
</ol>
<a class="header" href="print.html#a可变性-1" id="a可变性-1"><h3>可变性</h3></a>
<p><code>Borrowing</code>也分“不可变借用”（默认，<code>&amp;T</code>）和“可变借用”（<code>&amp;mut T</code>）。</p>
<p>顾名思义，“不可变借用”是只读的，不可更新被引用的内容。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);

    //可同时有多个不可变借用
    let y = &amp;x;
    let z = &amp;x;
    let m = &amp;x;

    //ok
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, x, y, z, m);
}
</code></pre></pre>
<p>再次强调下，同一时刻只能有一个可变借用(&amp;mut T)，且被借用的变量本身必须有可变性 :</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // 源变量x为可变性
    let mut x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);

    // 只能有一个可变借用
    let y = &amp;mut x; // ok
    // let z = &amp;mut x; //错误
    y.push(100);

    //ok
    println!(&quot;{:?}&quot;, y);

    // 错误，可变借用未释放，源变量不可访问
    // println!(&quot;{:?}&quot;, x);

} //y在此处销毁
</code></pre></pre>
<a class="header" href="print.html#a高级例子" id="a高级例子"><h3>高级例子</h3></a>
<p>下面的复杂例子，进行了详细的注释，即使看不懂也没关系，可以在完成Lifetimes（生命周期）的学习后再仔细思考本例子。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);

    //更新数组
    //push中对数组进行了可变借用，并在push函数退出时销毁这个借用
    x.push(10);

    // 构建新的作用域
    {
        //可变借用(1)
        let mut y = &amp;mut x; //ok. 不在同一时刻.
        //这个时候，可以理解x 没有任何资源，不能借用、使用
        y.push(100);
        println!(&quot;{:?}&quot;, y); //打印: [1, 2, 3, 10, 100]

        // println!(&quot;{:?}&quot;, x); //[err] 因为，资源所有权已经被“可变借用”给了y, 不能再不可变借用给x

        //可变借用(2)，注意：此处是对y的借用，不可再对x进行借用，
        //因为y在此时依然存活。
        let z = &amp;mut y;
        //这个时候，可以理解y 没有任何资源，不能借用、使用
        z.push(1000);

        println!(&quot;{:?}&quot;, z); //打印: [1, 2, 3, 10, 100, 1000]

        // println!(&quot;{:?}&quot;, y); //[err] 因为，资源所有权已经被“可变借用”给了z, 不能再不可变借用给x
    } //y和z在此处被销毁，并释放借用, 还给 x


    //访问x正常
    println!(&quot;{:?}&quot;, x); //打印: [1, 2, 3, 10, 100, 1000]
}

</code></pre></pre>
<a class="header" href="print.html#a总结-1" id="a总结-1"><h3>总结</h3></a>
<ol>
<li>借用不改变内存的所有者（Owner），借用只是对源内存的临时引用。</li>
<li>在借用周期内，借用方可以读写这块内存，所有者被禁止读写内存；且所有者保证在有“借用”存在的情况下，不会释放或转移内存。</li>
<li>失去所有权的变量不可以被借用（访问）。</li>
<li>在租借期内，内存所有者保证不会释放/转移/可变租借这块内存，但如果是在<strong>非可变租借</strong>的情况下，所有者是允许继续<strong>非可变租借</strong>出去的。</li>
<li>借用周期满后，所有者收回读写权限</li>
<li>借用周期小于被借用者（所有者）的生命周期。</li>
</ol>
<blockquote>
<p>备注：
借用周期，指的是借用的有效时间段。</p>
</blockquote>
<p>下面是一些实例代码：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);

    let y = &amp;x;  // 不可变借用给y [ok]
    let z = &amp;x;  // 不可变借用给z [ok]

    println!(&quot;{:?}, {:?}, {:?}&quot;, x, y, z); // [ok]
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // x 是内存的所有者(Owner)
    let mut x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);
    let w = &amp;mut x;
    println!(&quot;{:?}&quot;, w); // [ok]
    println!(&quot;{:?}&quot;, x); // [err]  因为，资源所有权已经被“可变借用”给了w, 不能再以“不可变”或“可变”借用给x
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // 源变量x为可变性
    let mut x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);

    // 只能有一个可变借用
    let y = &amp;mut x; // ok
    // let z = &amp;mut x; //错误
    y.push(100);

    //ok
    println!(&quot;{:?}&quot;, y);

    // 错误，可变借用未释放，源变量不可访问
    println!(&quot;{:?}&quot;, x);
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);

    let y = &amp;x;  // 不可变借用给y [ok]
    let z = &amp;x;  // 不可变借用给z [ok]

    println!(&quot;{:?}, {:?}, {:?}&quot;, x, y, z); // [ok]

    let w = &amp;mut x; //[err] x 已经被借用了，同一时刻，就不能再获得x的任何可变借用。
    w.push(100);
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x: Vec&lt;i32&gt; = vec!(1i32, 2, 3);

    // 构建新的作用域
    {
        let u = &amp;mut x;  //[ok] x&quot;可变&quot;借用给 ---&gt; 不可变的u
        u.push(991199);  //[ok] 虽然，u 是不可变的，但是u绑定的资源是可变的，因此，可以修改资源内存
        println!(&quot;{:?}&quot;, u); // [ok]
    }// u 在此处销毁，并释放借用，还给x

    let y = &amp;x;      // x&quot;不可变&quot;借用给 ---&gt; 不可变的y [ok]
    let z = &amp;x;      // x&quot;不可变&quot;借用给 ---&gt; 不可变的z [ok]
    let mut m = &amp;x;  // x&quot;不可变&quot;借用给 ---&gt; 可变得m [ok]

    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, x, y, z, m); // [ok]

    // 构建新的作用域
    {
        //let w = &amp;mut x; //[err]. x 已经被“不可变”借用，就不能再“可变”借用给其他变量
        //let w = &amp;mut y; //[err]  y 是&quot;不可变&quot;变量，所以，不能可变借用给其他变量
        //let w = &amp;mut z; //[err]  z 是“不可变”变量，所以，不能可变借用给其他变量
        //let w = &amp;mut m; // [ok]
        let mut w = &amp;mut m;
        //w.push(100);  // [err], w 借用的真正资源是不可变的, 所以不能修改资源的内存
        println!(&quot;{:?}&quot;, w); // [ok]

        {
            //let v = &amp;mut m; // m已经被“可变借用”给了w, 不能再以“不可变”或“可变”借用给其他变量
            let v = &amp;w; //[ok]
            let j = &amp;w; //[ok]

            println!(&quot;{:?}, {:?}&quot;, v, j); // [ok]


            //let k = &amp;mut w; //[err]  w 已经被“不可变”借用，就不能再“可变”借用给其他变量
            let mut h = &amp;w; //[ok]
            println!(&quot;{:?}, {:?}, {:?}&quot;, v, j, h); // [ok]

            {
                let n = &amp;mut h; //[ok]
                // 或使用
                //let mut g = &amp;mut h;

                //println!(&quot;{:?}&quot;, h); // [err] h已经被“可变借用”给了w, 不能再以“不可变”或“可变”借用给其他变量

                //let e = &amp;h; //[err] h已经被“可变借用”给了w, 不能再以“不可变”或“可变”借用给其他变量
                //let t = &amp;h; //[err] h已经被“可变借用”给了w, 不能再以“不可变”或“可变”借用给其他变量

                println!(&quot;{:?}&quot;, n); // [ok]

            }
        }

    } // w 在此处销毁，并释放借用，还给 x

    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, x, y, z, m); // [ok]
}
</code></pre></pre>
<a class="header" href="print.html#a生命周期-lifetime-" id="a生命周期-lifetime-"><h1>生命周期（ Lifetime ）</h1></a>
<p>下面是一个资源借用的例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 100_i32;

    {
        let x = &amp;a;
    }  // x 作用域结束
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<p>编译时，我们会看到一个严重的错误提示：</p>
<blockquote>
<p>error: unresolved name <code>x</code>.</p>
</blockquote>
<p>错误的意思是“无法解析 <code>x</code> 标识符”，也就是找不到 <code>x</code> , 这是因为像很多编程语言一样，Rust中也存在作用域概念，当资源离开离开作用域后，资源的内存就会被释放回收，当借用/引用离开作用域后也会被销毁，所以 <code>x</code> 在离开自己的作用域后，无法在作用域之外访问。</p>
<p>上面的涉及到几个概念：</p>
<ul>
<li><strong>Owner</strong>: 资源的所有者 <code>a</code></li>
<li><strong>Borrower</strong>: 资源的借用者 <code>x</code></li>
<li><strong>Scope</strong>: 作用域，资源被借用/引用的有效期</li>
</ul>
<p>强调下，无论是资源的所有者还是资源的借用/引用，都存在在一个有效的存活时间或区间，这个时间区间称为<strong>生命周期</strong>， 也可以直接以<strong>Scope作用域</strong>去理解。</p>
<p>所以上例子代码中的生命周期/作用域图示如下：</p>
<pre><code class="language-text">            {    a    {    x    }    *    }
所有者 a:         |________________________|
借用者 x:                   |____|            x = &amp;a
  访问 x:                             |       失败：访问 x
</code></pre>
<p>可以看到，借用者 <code>x</code> 的生命周期是资源所有者 <code>a</code> 的生命周期的<strong>子集</strong>。但是 <code>x</code> 的生命周期在第一个 <code>}</code> 时结束并销毁，在接下来的 <code>println!</code> 中再次访问便会发生严重的错误。</p>
<p>我们来修正上面的例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 100_i32;

    {
        let x = &amp;a;
        println!(&quot;{}&quot;, x);
    }  // x 作用域结束

}
</code></pre></pre>
<p>这里我们仅仅把 <code>println!</code> 放到了中间的 <code>{}</code>, 这样就可以在 <code>x</code>的生命周期内正常的访问 <code>x</code> ，此时的Lifetime图示如下：</p>
<pre><code class="language-text">            {    a    {    x    *    }    }
所有者 a:         |________________________|
借用者 x:                   |_________|       x = &amp;a
  访问 x:                        |            OK：访问 x
</code></pre>
<a class="header" href="print.html#a隐式lifetime" id="a隐式lifetime"><h2>隐式Lifetime</h2></a>
<p>我们经常会遇到参数或者返回值为引用类型的函数：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: &amp;str) -&gt; &amp;str {
    x
}
#}</code></pre></pre>
<p>上面函数在实际应用中并没有太多用处，<code>foo</code> 函数仅仅接受一个 <code>&amp;str</code> 类型的参数（<code>x</code>为对某个<code>string</code>类型资源<code>Something</code>的借用），并返回对资源<code>Something</code>的一个新的借用。</p>
<p>实际上，上面函数包含该了隐性的生命周期命名，这是由编译器自动推导的，相当于：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>在这里，约束返回值的<code>Lifetime</code>必须大于或等于参数<code>x</code>的<code>Lifetime</code>。下面函数写法也是合法的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 注意：'a 中 “'” 符号，是英文状态下的单引号。
fn foo&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str {
    &quot;hello, world!&quot;
}
#}</code></pre></pre>
<p>为什么呢？这是因为字符串&quot;hello, world!&quot;的类型是<code>&amp;'static str</code>，我们知道<code>static</code>类型的Lifetime是整个程序的运行周期，所以她比任意传入的参数的Lifetime<code>'a</code>都要长，即<code>'static &gt;= 'a</code>满足。</p>
<p>在上例中Rust可以自动推导Lifetime，所以并不需要程序员显式指定Lifetime <code>'a</code> 。</p>
<p><code>'a</code>是什么呢？它是Lifetime的标识符，这里的<code>a</code>也可以用<code>b</code>、<code>c</code>、<code>d</code>、<code>e</code>、...，甚至可以用<code>this_is_a_long_name</code>等，当然实际编程中并不建议用这种冗长的标识符，这样会严重降低程序的可读性。<code>foo</code>后面的<code>&lt;'a&gt;</code>为Lifetime的声明，可以声明多个，如<code>&lt;'a, 'b&gt;</code>等等。</p>
<p>另外，除非编译器无法自动推导出Lifetime，否则不建议显式指定Lifetime标识符，会降低程序的可读性。</p>
<a class="header" href="print.html#a显式lifetime" id="a显式lifetime"><h2>显式Lifetime</h2></a>
<p>当输入参数为多个借用/引用时会发生什么呢？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if true {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>这时候再编译，就没那么幸运了：</p>
<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn foo(x: &amp;str, y: &amp;str) -&gt; &amp;str {
                            ^~~~
</code></pre>
<p>编译器告诉我们，需要我们显式指定Lifetime标识符，因为这个时候，编译器无法推导出返回值的Lifetime应该是比 <code>x</code>长，还是比<code>y</code>长。虽然我们在函数中中用了 <code>if true</code> 确认一定可以返回<code>x</code>，但是要知道，编译器是在编译时候检查，而不是运行时，所以编译期间会同时检查所有的输入参数和返回值。</p>
<p>修复后的代码如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if true {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#lifetime推导" id="lifetime推导"><h2>Lifetime推导</h2></a>
<p>要推导Lifetime是否合法，先明确两点：</p>
<ul>
<li>输出值（也称为返回值）依赖哪些输入值</li>
<li>输入值的Lifetime大于或等于输出值的Lifetime (准确来说：子集，而不是大于或等于)</li>
</ul>
<p><strong>Lifetime推导公式：</strong>
当输出值R依赖输入值X Y Z ...，当且仅当输出值的Lifetime为所有输入值的Lifetime交集的子集时，生命周期合法。</p>
<pre><code class="language-text">    Lifetime(R) ⊆ ( Lifetime(X) ∩ Lifetime(Y) ∩ Lifetime(Z) ∩ Lifetime(...) )
</code></pre>
<p>对于例子1：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if true {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>因为返回值同时依赖输入参数<code>x</code>和<code>y</code>，所以</p>
<pre><code class="language-text">    Lifetime(返回值) ⊆ ( Lifetime(x) ∩ Lifetime(y) )

    即：

    'a ⊆ ('a ∩ 'a)  // 成立
</code></pre>
<a class="header" href="print.html#a定义多个lifetime标识符" id="a定义多个lifetime标识符"><h3>定义多个Lifetime标识符</h3></a>
<p>那我们继续看个更复杂的例子，定义多个Lifetime标识符：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    if true {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>先看下编译，又报错了：</p>
<pre><code class="language-text">&lt;anon&gt;:5:3: 5:4 error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements [E0495]
&lt;anon&gt;:5 		y
                 ^
&lt;anon&gt;:1:1: 7:2 help: consider using an explicit lifetime parameter as shown: fn foo&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str
&lt;anon&gt;:1 fn bar&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
&lt;anon&gt;:2 	if true {
&lt;anon&gt;:3 		x
&lt;anon&gt;:4 	} else {
&lt;anon&gt;:5 		y
&lt;anon&gt;:6 	}
</code></pre>
<p>编译器说自己无法正确地推导返回值的Lifetime，读者可能会疑问，“我们不是已经指定返回值的Lifetime为<code>'a</code>了吗？&quot;。</p>
<p>这儿我们同样可以通过生命周期推导公式推导：</p>
<p>因为返回值同时依赖<code>x</code>和<code>y</code>，所以</p>
<pre><code class="language-text">    Lifetime(返回值) ⊆ ( Lifetime(x) ∩ Lifetime(y) )

    即：

    'a ⊆ ('a ∩ 'b)  //不成立
</code></pre>
<p>很显然，上面我们根本没法保证成立。</p>
<p>所以，这种情况下，我们可以显式地告诉编译器<code>'b</code>比<code>'a</code>长（<code>'a</code>是<code>'b</code>的子集），只需要在定义Lifetime的时候, 在<code>'b</code>的后面加上<code>: 'a</code>, 意思是<code>'b</code>比<code>'a</code>长，<code>'a</code>是<code>'b</code>的子集:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;'a, 'b: 'a&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
    if true {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>这里我们根据公式继续推导：</p>
<pre><code class="language-text">    条件：Lifetime(x) ⊆ Lifetime(y)
    推导：Lifetime(返回值) ⊆ ( Lifetime(x) ∩ Lifetime(y) )

    即：

    条件： 'a ⊆ 'b
    推导：'a ⊆ ('a ∩ 'b) // 成立
</code></pre>
<p>上面是成立的，所以可以编译通过。</p>
<p>需要注意的是， 多个Lifetime标识符出现的时候，推导过程中，任意两个Lifetime标识符，只存在一种关系，即：<code>'a</code> 不等于 <code>'b</code> (要么<code>'a</code> &gt; <code>'b</code>，要么<code>'a</code> &lt; <code>'b</code>, 如果<code>'a</code> == <code>'b</code>，就要统一使用一个Lifetime标识符)</p>
<a class="header" href="print.html#a推导总结" id="a推导总结"><h3>推导总结</h3></a>
<p>通过上面的学习相信大家可以很轻松完成Lifetime的推导，总之，记住两点：</p>
<ol>
<li>输出值依赖哪些输入值。</li>
<li>推导公式。</li>
</ol>
<a class="header" href="print.html#lifetime-in-struct" id="lifetime-in-struct"><h2>Lifetime in struct</h2></a>
<p>上面我们更多讨论了函数中Lifetime的应用，在<code>struct</code>中Lifetime同样重要。</p>
<p>我们来定义一个<code>Person</code>结构体：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Person {
    age: &amp;u8,
}
#}</code></pre></pre>
<p>编译时我们会得到一个error：</p>
<pre><code class="language-text">&lt;anon&gt;:2:8: 2:12 error: missing lifetime specifier [E0106]
&lt;anon&gt;:2 	age: &amp;u8,
</code></pre>
<p>之所以会报错，这是因为Rust要确保<code>Person</code>的Lifetime不会比它的<code>age</code>借用长，不然会出现<code>Dangling Pointer</code>的严重内存问题。所以我们需要为<code>age</code>借用声明Lifetime：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Person&lt;'a&gt; {
    age: &amp;'a u8,
}
#}</code></pre></pre>
<p>不需要对<code>Person</code>后面的<code>&lt;'a&gt;</code>感到疑惑，这里的<code>'a</code>并不是指<code>Person</code>这个<code>struct</code>的Lifetime，仅仅是一个泛型参数而已，<code>struct</code>可以有多个Lifetime参数用来约束不同的<code>field</code>，实际的Lifetime应该是所有<code>field</code>Lifetime交集的子集。例如：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 20_u8;
    let stormgbs = Person {
                        age: &amp;x,
                     };
}
</code></pre></pre>
<p>这里，生命周期/Scope的示意图如下：</p>
<pre><code class="language-text">                  {   x    stormgbs      *     }
所有者 x:              |________________________|
所有者 stormgbs:                |_______________|  'a
借用者 stormgbs.age:            |_______________|  stormgbs.age = &amp;x
</code></pre>
<p>既然<code>&lt;'a&gt;</code>作为<code>Person</code>的泛型参数，所以在为<code>Person</code>实现方法时也需要加上<code>&lt;'a&gt;</code>，不然：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Person {
    fn print_age(&amp;self) {
        println!(&quot;Person.age = {}&quot;, self.age);
    }
}
#}</code></pre></pre>
<p>报错：</p>
<pre><code class="language-text">&lt;anon&gt;:5:6: 5:12 error: wrong number of lifetime parameters: expected 1, found 0 [E0107]
&lt;anon&gt;:5 impl Person {
              ^~~~~~
</code></pre>
<p><strong>正确的做法是</strong>：</p>
<ul>
<li>Rust 2015 格式写法：
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    struct Person&lt;'a&gt; {
        age: &amp;'a u8,
    }
    struct Ref&lt;'a, T: 'a&gt; {
        field: &amp;'a T
    }

    impl&lt;'a&gt; Person&lt;'a&gt; {
        fn print_age(&amp;self) {
            println!(&quot;Person.age = {}&quot;, self.age);
        }
    }
#}</code></pre></pre>
</li>
<li>Rust 2018 格式写法
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    struct Person&lt;'a&gt; {
        age: &amp;'a u8,
    }
    struct Ref&lt;'a, T&gt; {
        field: &amp;'a T
    }

    impl Person&lt;'_&gt; {
        fn print_age(&amp;self) {
            println!(&quot;Person.age = {}&quot;, self.age);
        }
    }
#}</code></pre></pre>
</li>
</ul>
<p>这样加上<code>&lt;'a&gt;</code>后就可以了。读者可能会疑问，为什么<code>print_age</code>中不需要加上<code>'a</code>？这是个好问题。因为<code>print_age</code>的输出参数为<code>()</code>，也就是可以不依赖任何输入参数, 所以编译器此时可以不必关心和推导Lifetime。即使是<code>fn print_age(&amp;self, other_age: &amp;i32) {...}</code>也可以编译通过。</p>
<p><strong>如果<code>Person</code>的方法存在输出值（借用）呢？</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'a&gt; Person&lt;'a&gt; {
    fn get_age(&amp;self) -&gt; &amp;u8 {
        self.age
    }
}
#}</code></pre></pre>
<p><code>get_age</code>方法的输出值依赖一个输入值<code>&amp;self</code>，这种情况下，Rust编译器可以自动推导为：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'a&gt; Person&lt;'a&gt; {
    fn get_age(&amp;'a self) -&gt; &amp;'a u8 {
        self.age
    }
}
#}</code></pre></pre>
<p><strong>如果输出值（借用）依赖了多个输入值呢？</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'a, 'b&gt; Person&lt;'a&gt; {
    fn get_max_age(&amp;'a self, p: &amp;'a Person) -&gt; &amp;'a u8 {
        if self.age &gt; p.age {
            self.age
        } else {
            p.age
        }
    }
}
#}</code></pre></pre>
<p>类似之前的Lifetime推导章节，当返回值（借用）依赖多个输入值时，需显示声明Lifetime。和函数Lifetime同理。</p>
<p><strong>其他</strong>:</p>
<p>无论在函数还是在<code>struct</code>中，甚至在<code>enum</code>中，Lifetime理论知识都是一样的。希望大家可以慢慢体会和吸收，做到举一反三。</p>
<a class="header" href="print.html#a总结-2" id="a总结-2"><h2>总结</h2></a>
<p>Rust正是通过所有权、借用以及生命周期，以高效、安全的方式近乎完美地管理了内存。没有手动管理内存的负载和安全性，也没有GC造成的程序暂停问题。</p>
<a class="header" href="print.html#a常量" id="a常量"><h1>常量</h1></a>
<a class="header" href="print.html#a常量值" id="a常量值"><h1>常量值</h1></a>
<a class="header" href="print.html#a常量函数" id="a常量函数"><h1>※常量函数</h1></a>
<a class="header" href="print.html#a运算符" id="a运算符"><h1>运算符</h1></a>
<a class="header" href="print.html#a操作符" id="a操作符"><h1>操作符</h1></a>
<p>现在的Rust资料，无论是Book还是RustByExample都没有统一而完全的介绍Rust的操作符。一个很重要的原因就是，Rust的操作符号和C++大部分都是一模一样的。</p>
<ol>
<li><a href="print.html#%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6">一元运算</a></li>
</ol>
<a class="header" href="print.html#a一元操作符" id="a一元操作符"><h2>一元操作符</h2></a>
<p>顾名思义，一元操作符是专门对一个Rust元素进行操纵的操作符，主要包括以下几个:</p>
<ul>
<li><code>-</code>: 取负，专门用于数值类型。</li>
<li><code>*</code>: 解引用。这是一个很有用的符号，和<code>Deref</code>（<code>DerefMut</code>）这个trait关联密切。</li>
<li><code>!</code>: 取反。取反操作相信大家都比较熟悉了，不多说了。有意思的是，当这个操作符对数字类型使用的时候，会将其每一位都置反！也就是说，你对一个<code>1u8</code>进行<code>!</code>的话你将会得到一个<code>254u8</code>。</li>
<li><code>&amp;</code>和<code>&amp;mut</code>: 租借，borrow。向一个owner租借其使用权，分别是租借一个只读使用权和读写使用权。</li>
</ul>
<a class="header" href="print.html#a二元操作符" id="a二元操作符"><h2>二元操作符</h2></a>
<a class="header" href="print.html#a算数操作符" id="a算数操作符"><h3>算数操作符</h3></a>
<p>算数运算符都有对应的trait的，他们都在<code>std::ops</code>下：</p>
<ul>
<li><code>+</code>: 加法。实现了<code>std::ops::Add</code>。</li>
<li><code>-</code>: 减法。实现了<code>std::ops::Sub</code>。</li>
<li><code>*</code>: 乘法。实现了<code>std::ops::Mul</code>。</li>
<li><code>/</code>: 除法。实现了<code>std::ops::Div</code>。</li>
<li><code>%</code>: 取余。实现了<code>std::ops::Rem</code>。</li>
</ul>
<a class="header" href="print.html#a位运算符" id="a位运算符"><h3>位运算符</h3></a>
<p>和算数运算符差不多的是，位运算也有对应的trait。</p>
<ul>
<li><code>&amp;</code>: 与操作。实现了<code>std::ops::BitAnd</code>。</li>
<li><code>|</code>: 或操作。实现了<code>std::ops::BitOr</code>。</li>
<li><code>^</code>: 异或。实现了<code>std::ops::BitXor</code>。</li>
<li><code>&lt;&lt;</code>: 左移运算符。实现了<code>std::ops::Shl</code>。</li>
<li><code>&gt;&gt;</code>: 右移运算符。实现了<code>std::ops::Shr</code>。</li>
</ul>
<a class="header" href="print.html#a惰性boolean运算符" id="a惰性boolean运算符"><h3>惰性boolean运算符</h3></a>
<p>逻辑运算符有三个，分别是<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>。其中前两个叫做惰性boolean运算符，之所以叫这个名字。是因为在Rust里也会出现其他类C语言的逻辑短路问题。所以取了这么一个高大上然并卵的名字。
其作用和C语言里的一毛一样啊！哦，对了，有点不同的是Rust里这个运算符只能用在bool类型变量上。什么 <code>1 &amp;&amp; 1</code> 之类的表达式给我死开。</p>
<a class="header" href="print.html#a比较运算符" id="a比较运算符"><h3>比较运算符</h3></a>
<p>比较运算符其实也是某些trait的语法糖啦，不同的是比较运算符所实现的trait只有两个<code>std::cmp::PartialEq</code>和<code>std::cmp::PartialOrd</code></p>
<p>其中， <code>==</code>和<code>!=</code>实现的是<code>PartialEq</code>。
而，<code>&lt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code>实现的是<code>PartialOrd</code>。</p>
<p>边看本节边翻开标准库（好习惯，鼓励）的同学一定会惊奇的发现，不对啊，<code>std::cmp</code>这个mod下明明有四个trait，而且从肉眼上来看更符合逻辑的<code>Ord</code>和<code>Eq</code>岂不是更好？其实，Rust对于这四个trait的处理是很明确的。分歧主要存在于浮点类型。
熟悉IEEE的同学一定知道浮点数有一个特殊的值叫<code>NaN</code>，这个值表示未定义的一个浮点数。在Rust中可以用<code>0.0f32 / 0.0f32</code>来求得其值。那么问题来了，这个数他是一个确定的值，但是它表示的是一个不确定的数！那么 <code>NaN != NaN</code> 的结果是啥？标准告诉我们，是 <code>true</code> 。但是这么写又不符合<code>Eq</code>的定义里<code>total equal</code>(每一位一样两个数就一样)的定义。因此有了<code>PartialEq</code>这么一个定义，我们只支持部分相等好吧，NaN这个情况我就给它特指了。</p>
<p>为了普适的情况，Rust的编译器选择了<code>PartialOrd</code>和<code>PartialEq</code>来作为其默认的比较符号的trait。我们也就和中央保持一致就好。</p>
<a class="header" href="print.html#a类型转换-as-运算符" id="a类型转换-as-运算符"><h1>类型转换 as 运算符</h1></a>
<p>其实这个并不算运算符，因为他是个单词<code>as</code>。</p>
<p>这个就是C语言中各位熟悉的显式类型转换了。</p>
<p>show u the code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn avg(vals: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(vals);
    let num: f64 = len(vals) as f64;
    sum / num
}
#}</code></pre></pre>
<a class="header" href="print.html#a运算符重载" id="a运算符重载"><h1>运算符重载</h1></a>
<p>Rust可以让我们对某些运算符进行重载，这其中大部分的重载都是对<code>std::ops</code>下的trait进行重载而实现的。</p>
<a class="header" href="print.html#a重载运算符" id="a重载运算符"><h2>重载运算符</h2></a>
<p>上面说了很多trait。有人会问了，你说这么多干啥？</p>
<p>答，为了运算符重载！</p>
<p>Rust是支持运算符重载的（某咖啡语言哭晕在厕所）。</p>
<p>关于这部分呢，在本书的第30节会有很详细的叙述，因此在这里我就不铺开讲了，上个栗子给大家，仅作参考：</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::{Add, Sub};

#[derive(Copy, Clone)]
struct A(i32);

impl Add for A {
    type Output = A;
    fn add(self, rhs: A) -&gt; A {
        A(self.0 + rhs.0)
    }
}

impl Sub for A {
    type Output = A;
    fn sub(self, rhs: A) -&gt; A{
        A(self.0 - rhs.0)
    }
}

fn main() {
    let a1 = A(10i32);
    let a2 = A(5i32);
    let a3 = a1 + a2;
    println!(&quot;{}&quot;, (a3).0);
    let a4 = a1 - a2;
    println!(&quot;{}&quot;, (a4).0);
}
</code></pre></pre>
<p>output:</p>
<pre><code class="language-shell">15
5
</code></pre>
<a class="header" href="print.html#a重载加法" id="a重载加法"><h2>重载加法</h2></a>
<p>我们现在来实现一个只支持加法的阉割版<a href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_%28%E6%95%B0%E5%AD%A6%29">复数</a>：</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug)]
struct Complex {
    a: f64,
    b: f64,
}

impl Add for Complex {
    type Output = Complex;
    fn add(self, other: Complex) -&gt; Complex {
        Complex {a: self.a+other.a, b: self.b+other.b}
    }
}

fn main() {
    let cp1 = Complex{a: 1f64, b: 2.0};
    let cp2 = Complex{a: 5.0, b:8.1};
    let cp3 = cp1 + cp2;
    print!(&quot;{:?}&quot;, cp3);
}
</code></pre></pre>
<p>输出:</p>
<pre><code>Complex { a: 6, b: 10.1}
</code></pre>
<p>这里我们实现了<code>std::ops::Add</code>这个trait。这时候有同学一拍脑门，原来如此，没错……其实Rust的大部分运算符都是<code>std::ops</code>下的trait的语法糖！</p>
<p>我们来看看<code>std::ops::Add</code>的具体结构</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Add&lt;i32&gt; for Point {
    type Output = f64;

    fn add(self, rhs: i32) -&gt; f64 {
        // add an i32 to a Point and get an f64
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a神奇的output以及动态分发" id="a神奇的output以及动态分发"><h2>神奇的Output以及动态分发</h2></a>
<p>有的同学会问了，这个<code>Output</code>是肿么回事？答，类型转换哟亲！
举个不太恰当的栗子，我们在现实中会出现<code>0.5+0.5=1</code>这样的算式，用Rust的语言来描述就是： 两个<code>f32</code>相加得到了一个<code>i8</code>。显而易见，Output就是为这种情况设计的。</p>
<p>还是看代码：</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug)]
struct Complex {
    a: f64,
    b: f64,
}

impl Add for Complex {
    type Output = Complex;
    fn add(self, other: Complex) -&gt; Complex {
        Complex {a: self.a+other.a, b: self.b+other.b}
    }
}

impl Add&lt;i32&gt; for Complex {
    type Output = f64;
    fn add(self, other: i32) -&gt; f64 {
        self.a + self.b + (other as f64)
    }
}

fn main() {
    let cp1 = Complex{a: 1f64, b: 2.0};
    let cp2 = Complex{a: 5.0, b:8.1};
    let cp3 = Complex{a: 9.0, b:20.0};
    let complex_add_result = cp1 + cp2;
    print!(&quot;{:?}\n&quot;, complex_add_result);
    print!(&quot;{:?}&quot;, cp3 + 10i32);
}
</code></pre></pre>
<p>输出结果：</p>
<pre><code>Complex { a: 6, b: 10.1 }
39
</code></pre>
<a class="header" href="print.html#a对范型的限制" id="a对范型的限制"><h2>对范型的限制</h2></a>
<p>Rust的运算符是基于trait系统的，同样的，运算符可以被当成一种对范型的限制，我们可以这么要求<code>范型T必须实现了trait Mul&lt;Output=T&gt;</code>。
于是，我们得到了如下的一份代码：</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Mul;

trait HasArea&lt;T&gt; {
    fn area(&amp;self) -&gt; T;
}

struct Square&lt;T&gt; {
    x: T,
    y: T,
    side: T,
}

impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy {
    fn area(&amp;self) -&gt; T {
        self.side * self.side
    }
}

fn main() {
    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 12.0f64,
    };

    println!(&quot;Area of s: {}&quot;, s.area());
}
</code></pre></pre>
<p>对于trait <code>HasArea&lt;T&gt;</code>和 struct <code>Square&lt;T&gt;</code>，我们通过<code>where T: Mul&lt;Output=T&gt; + Copy</code> 限制了<code>T</code>必须实现乘法。同时Copy则限制了Rust不再将self.side给move到返回值里去。</p>
<p>写法简单，轻松愉快。</p>
<a class="header" href="print.html#a流程控制" id="a流程控制"><h1>流程控制</h1></a>
<a class="header" href="print.html#a判断条件" id="a判断条件"><h1>判断/条件</h1></a>
<ul>
<li>if</li>
<li>if let</li>
<li>match</li>
</ul>
<a class="header" href="print.html#if-表达式" id="if-表达式"><h2>if 表达式</h2></a>
<p>Rust 中的 if 表达式基本就是如下几种形式：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 形式 1
if expr1 {

}

// 形式 2
if expr1 {

}
else {

}

// 形式 3
if expr1 {

}
else if expr2 {
    // else if 可多重
}
else {

}

#}</code></pre></pre>
<p>相对于 C 系语言，Rust 的 if 表达式的显著特点是：</p>
<ol>
<li>判断条件不用小括号括起来；</li>
<li>它是表达式，而不是语句。</li>
</ol>
<p>鉴于上述第二点，因为是表达式，所以我们可以写出如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

let y = if x == 5 {
    10
} else {
    15
}; // y: i32
#}</code></pre></pre>
<p>或者压缩成一行：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
#}</code></pre></pre>
<a class="header" href="print.html#if-let" id="if-let"><h2>if let</h2></a>
<p>我们在代码中常常会看到 <code>if let</code> 成对出现，这实际上是一个 match 的简化用法。直接举例来说明：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = Some(5);

if let Some(y) = x {
    println!(&quot;{}&quot;, y);      // 这里输出为：5
}

let z = if let Some(y) = x {
    y
}
else {
    0
};
// z 值为 5

#}</code></pre></pre>
<p>上面代码等价于</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = Some(5);
match x {
    Some(y) =&gt; println!(&quot;{}&quot;, y),
    None =&gt; ()
}

let z = match x {
    Some(y) =&gt; y,
    None =&gt; 0
};
#}</code></pre></pre>
<p>设计这个特性的目的是，在条件判断的时候，直接做一次模式匹配，方便代码书写，使代码更紧凑。</p>
<a class="header" href="print.html#match-1" id="match-1"><h2>match</h2></a>
<p>Rust 中没有类似于 C 的 <code>switch</code> 关键字，但它有用于模式匹配的 <code>match</code>，能实现同样的功能，并且强大太多。</p>
<p>match 的使用非常简单，举例如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    1 =&gt; {
        println!(&quot;one&quot;)
    },
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    4 =&gt; println!(&quot;four&quot;),
    5 =&gt; println!(&quot;five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
#}</code></pre></pre>
<p>注意，match 也是一个表达式。match 后面会专门论述，请参见 <strong>模式匹配</strong> 这一章。</p>
<a class="header" href="print.html#a循环" id="a循环"><h1>循环</h1></a>
<ul>
<li>for</li>
<li>while</li>
<li>loop</li>
<li>break 与 continue</li>
<li>label</li>
</ul>
<a class="header" href="print.html#for-1" id="for-1"><h2>for</h2></a>
<p>for 语句用于遍历一个迭代器。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for var in iterator {
    code
}
#}</code></pre></pre>
<p>Rust 迭代器返回一系列的元素，每个元素是循环中的一次重复。然后它的值与 var 绑定，它在循环体中有效。每当循环体执行完后，我们从迭代器中取出下一个值，然后我们再重复一遍。当迭代器中不再有值时，for 循环结束。</p>
<p>比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    println!(&quot;{}&quot;, x); // x: i32
}
#}</code></pre></pre>
<p>输出</p>
<pre><code>0
1
2
3
4
5
6
7
8
9
</code></pre>
<p>不熟悉迭代器概念的同学可能傻眼了，下面不妨用 C 形式的 for 语句做下对比：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// C 语言的 for 循环例子
for (x = 0; x &lt; 10; x++) {
    printf( &quot;%d\n&quot;, x );
}
#}</code></pre></pre>
<p>两者输出是相同的，那么，为何 Rust 要这样来设计 for 语句呢？</p>
<ol>
<li>简化边界条件的确定，减少出错；</li>
<li>减少运行时边界检查，提高性能。</li>
</ol>
<p>即使对于有经验的 C 语言开发者来说，要手动控制要循环的每个元素也都是复杂并且易于出错的。</p>
<p>for 语句就是迭代器遍历的语法糖。</p>
<p>上述迭代器的形式虽好，但是好像在循环过程中，少了索引信息。Rust 考虑到了这一点，当你需要记录你已经循环了多少次了的时候，你可以使用 <code>.enumerate()</code> 函数。比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for (i,j) in (5..10).enumerate() {
    println!(&quot;i = {} and j = {}&quot;, i, j);
}
#}</code></pre></pre>
<p>输出：</p>
<pre><code>i = 0 and j = 5
i = 1 and j = 6
i = 2 and j = 7
i = 3 and j = 8
i = 4 and j = 9
</code></pre>
<p>再比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let lines = &quot;Content of line one
Content of line two
Content of line three
Content of line four&quot;.lines();
for (linenumber, line) in lines.enumerate() {
    println!(&quot;{}: {}&quot;, linenumber, line);
}
#}</code></pre></pre>
<p>输出：</p>
<pre><code>0: Content of line one
1: Content of line two
2: Content of line three
3: Content of line four
</code></pre>
<p>关于迭代器的知识，详见 <strong>迭代器</strong> 章节。</p>
<a class="header" href="print.html#while-1" id="while-1"><h2>while</h2></a>
<p>Rust 提供了 while 语句，条件表达式为真时，执行语句体。当你不确定应该循环多少次时可选择 while。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
while expression {
    code
}
#}</code></pre></pre>
<p>比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#loop" id="loop"><h2>loop</h2></a>
<p>有一种情况，我们经常会遇到，就是写一个无限循环：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
while true {
    // do something
}
#}</code></pre></pre>
<p>针对这种情况，Rust 专门优化提供了一个语句 loop。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
loop {
    // do something
}
#}</code></pre></pre>
<p><code>loop</code> 与 <code>while true</code> 的主要区别在编译阶段的静态分析。</p>
<p>比如说，如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut a;
loop {
     a = 1;
     // ... break ...
}
do_something(a)
#}</code></pre></pre>
<p>如果是<code>loop</code>循环，编译器会正确分析出变量<code>a</code>会被正确初始化，而如果换成<code>while true</code>，则会发生编译错误。这个微小的区别也会影响生命周期分析。</p>
<a class="header" href="print.html#break-和-continue" id="break-和-continue"><h2>break 和 continue</h2></a>
<p>与 C 语言类似，Rust 也提供了 break 和 continue 两个关键字用来控制循环的流程。</p>
<ul>
<li>break 用来跳出当前层的循环；</li>
<li>continue 用来执行当前层的下一次迭代。</li>
</ul>
<p>像上面那个 while 例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let mut done = false;

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
#}</code></pre></pre>
<p>可以优化成：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;

loop {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 { break; }
}
#}</code></pre></pre>
<p>这样感觉更直观一点。</p>
<p>下面这个例子演示 continue 的用法：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    if x % 2 == 0 { continue; }

    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p>它的作用是打印出 <code>0~9</code> 的奇数。结果如下：</p>
<pre><code>1
3
5
7
9
</code></pre>
<a class="header" href="print.html#label" id="label"><h2>label</h2></a>
<p>你也许会遇到这样的情形，当你有嵌套的循环而希望指定你的哪一个 break 或 continue 该起作用。就像大多数语言，默认 break 或 continue 将会作用于当前层的循环。当你想要一个 break 或 continue 作用于一个外层循环，你可以使用标签来指定你的 break 或 continue 语句作用的循环。</p>
<p>如下代码只会在 x 和 y 都为奇数时打印他们：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // continues the loop over x
        if y % 2 == 0 { continue 'inner; } // continues the loop over y
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#a函数-1" id="a函数-1"><h1>函数</h1></a>
<p>尽管Rust是一门<code>多范式</code>的编程语言。</p>
<p><code>多范式</code>，就是多种编程方法的意思。有哪些编程方法呢？目前说来，有面向过程，面向对象，泛型，函数式四种程序设计方法。</p>
<p>但Rust的编程风格是更偏向于函数式的，函数在Rust中是“一等公民”——<code>first-class type</code>。这意味着，函数是可以作为数据在程序中进行传递，如：作为函数的参数。跟C、C++一样，rust程序也有一个唯一的程序入口-main函数。Rust的main函数形式如下：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  //statements
}
</code></pre></pre>
<p>Rust使用 <code>fn</code> 关键字来声明和定义函数，<code>fn</code> 关键字隔一个空格后跟函数名，函数名后跟着一个括号，函数参数定义在括号内。rust使用<code>snake_case</code>风格来命名函数，即所有字母小写并使用下划线类分隔单词，如：<code>foo_bar</code>。如果函数有返回值，则在括号后面加上箭头 <strong>-&gt;</strong> ，在箭头后加上返回值的类型。</p>
<p>这一章我们将学习以下与函数相关的知识：</p>
<ol>
<li><a href="arguement.md">函数参数</a></li>
<li><a href="return_value.md">函数返回值</a></li>
<li><a href="statement_expression.md">语句和表达式</a></li>
<li><a href="higher_order_function.md">高阶函数</a></li>
</ol>
<a class="header" href="print.html#a函数参数" id="a函数参数"><h1>函数参数</h1></a>
<a class="header" href="print.html#a参数声明" id="a参数声明"><h2>参数声明</h2></a>
<p>Rust的函数参数声明和一般的变量声明相仿，也是参数名后加冒号，冒号后跟参数类型，不过不需要<code>let</code>关键字。
需要注意的是，普通变量声明(let语句)是可以省略变量类型的，而<strong>函数参数的声明则不能省略参数类型</strong>。
来看一个简单例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  say_hi(&quot;ruster&quot;);
}

fn say_hi(name: &amp;str) {
  println!(&quot;Hi, {}&quot;, name);
}

</code></pre></pre>
<p>上例中，<code>say_hi</code>函数拥有一个参数，名为<code>name</code>，类型为<code>&amp;str</code>。</p>
<a class="header" href="print.html#a将函数作为参数" id="a将函数作为参数"><h2>将函数作为参数</h2></a>
<p>在Rust中，函数是一等公民（可以储存在变量/数据结构中，可以作为参数传入函数，可以作为返回值），所以， Rust的函数参数不仅可以是一般的类型，也可以是函数。如：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let xm = &quot;xiaoming&quot;;
  let xh = &quot;xiaohong&quot;;
  say_what(xm, hi);
  say_what(xh, hello);
}

fn hi(name: &amp;str) {
  println!(&quot;Hi, {}.&quot;, name);
}

fn hello(name: &amp;str) {
  println!(&quot;Hello, {}.&quot;, name);
}

fn say_what(name: &amp;str, func: fn(&amp;str)) {
  func(name)
}
</code></pre></pre>
<p>上例中，<code>hi</code>函数和<code>hello</code>函数都是只有一个<code>&amp;str</code>类型的参数且没有返回值。而<code>say_what</code>函数则有两个参数，一个是<code>&amp;str</code>类型，另一个则是函数类型（function type），它是只有一个<code>&amp;str</code>类型参数且没有返回值的函数类型。</p>
<a class="header" href="print.html#a模式匹配" id="a模式匹配"><h2>模式匹配</h2></a>
<p>支持模式匹配，让rust平添了许多的灵活性，用起来也是十分的舒爽。模式匹配不仅可以用在变量声明（let语句）中，也可以用在函数参数声明中，如：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let xm = (&quot;xiaoming&quot;, 54);
  let xh = (&quot;xiaohong&quot;, 66);
  print_id(xm);
  print_id(xh);
  print_name(xm);
  print_age(xh);
  print_name(xm);
  print_age(xh);
}

fn print_id((name, age): (&amp;str, i32)) {
  println!(&quot;I'm {},age {}.&quot;, name, age);
}

fn print_age((_, age): (&amp;str, i32)) {
  println!(&quot;My age is  {}&quot;, age);
}

fn print_name((name,_): (&amp;str, i32)) {
  println!(&quot;I am  {}&quot;, name);
}
</code></pre></pre>
<p>上例是一个<code>元组(Tuple)</code>匹配的例子，当然也可以是其他可在<code>let</code>语句中使用的类型。
参数的模式匹配跟<code>let</code>语句的匹配一样，也可以使用下划线(<code>_</code>)来表示丢弃一个值。</p>
<a class="header" href="print.html#a函数返回值" id="a函数返回值"><h1>函数返回值</h1></a>
<p>在Rust中，任何函数都有返回类型，当函数返回时，会返回一个该类型的值。我们先来看看main函数：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  //statements
}
</code></pre></pre>
<p>之前有说过，函数的返回值类型是在参数列表后，加上箭头和类型来指定的。不过，一般我们看到的main函数的定义并没有这么做。这是因为main函数的返回值是<code>()</code>，在rust中，当一个函数返回<code>()</code>时，可以省略。main函数的完整形式如下：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() -&gt; () {
  //statements
}
</code></pre></pre>
<p>main函数的返回值类型是<code>()</code>，它是一个特殊的元组——没有元素的元组，称为<code>unit</code>，它表示一个函数没有任何信息需要返回。在Rust Reference的<a href="https://doc.rust-lang.org/reference/types.html#tuple-types">Types</a>中是的描述如下：</p>
<blockquote>
<p>For historical reasons and convenience, the tuple type with no elements (<code>()</code>) is often called ‘unit’ or ‘the unit type’.</p>
</blockquote>
<p><code>()</code>类型，其实类似于C/C++、Java、C#中的<code>void</code>类型。</p>
<p>下面来看一个有返回值的例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let a = 3;
  println!(&quot;{}&quot;, inc(a));
}

fn inc(n: i32) -&gt; i32 {
  n + 1
}
</code></pre></pre>
<p>上面的例子中，函数<code>inc</code>有一个<code>i32</code>类型的参数和返回值，作用是将参数加1返回。需要注意的是<code>inc</code>函数中只有<code>n+1</code>一个表达式，并没有像C/C++或Java、C#等语言有显式地<code>return</code>语句类返回一个值。这是因为，与其他基于语句的语言（如C语言）不同，Rust是基于表达式的语言，函数中最后一个表达式的值，默认作为返回值。当然，Rust中也有语句，关于rust的语句和表达式，请看<a href="statement_expression.md">下一节</a>。</p>
<a class="header" href="print.html#return关键字" id="return关键字"><h2>return关键字</h2></a>
<p>Rust也有<code>return</code>关键字，不过一般用于提前返回。来看一个简单地例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let a = [1,3,2,5,9,8];
  println!(&quot;There is 7 in the array: {}&quot;, find(7, &amp;a));
  println!(&quot;There is 8 in the array: {}&quot;, find(8, &amp;a));
}

fn find(n: i32, a: &amp;[i32]) -&gt; bool {
  for i in a {
    if *i == n {
      return true;
    }
  }
  false
}
</code></pre></pre>
<p>上例中，<code>find</code>函数，接受一个<code>i32</code>类型<code>n</code>和一个<code>i32</code>类型的切片(<code>slice</code>)<code>a</code>，返回一个<code>bool</code>值，若n是a的元素，则返回<code>true</code>，否则返回<code>false</code>。可以看到，<code>return</code>关键字，用在<code>for</code>循环的<code>if</code>表达式中，若此时a的元素与n相等，则立刻返回true，剩下的循环不必再进行，否则一直循环检测完整个切片(slice)，最后返回false。当然，return语句也可以用在最后返回，像C/C++一样使用：把<code>find</code>函数最后一句<code>false</code>改为<code>return false;</code>（注意分号不可省略）也是可以的，不过这就不是rust的编程风格了。这里需要注意的是，<code>for</code>循环中的<code>i</code>，其类型为<code>&amp;i32</code>，需要使用解引用操作符来变换为<code>i32</code>类型。另外，切片（slice）在这里可以看作是对数组的引用，关于切片与数组的详细解释可以看<a href="https://doc.rust-lang.org/reference.html#array-and-slice-types">Rust Reference</a>和<a href="http://rustbyexample.com/primitives/array.html">rustbyexample</a>中的相关内容。</p>
<a class="header" href="print.html#a返回多个值" id="a返回多个值"><h2>返回多个值</h2></a>
<p><strong>Rust 的函数不支持多返回值</strong>，但是我们可以利用元组来返回多个值，配合Rust的模式匹配，使用起来十分灵活。先看例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let (p2,p3) = pow_2_3(789);
  println!(&quot;pow 2 of 789 is {}.&quot;, p2);
  println!(&quot;pow 3 of 789 is {}.&quot;, p3);
}

fn pow_2_3(n: i32) -&gt; (i32, i32) {
  (n*n, n*n*n)
}
</code></pre></pre>
<p>可以看到，上例中，<code>pow_2_3</code>函数接收一个<code>i32</code>类型的值，返回其二次方和三次方的值，这两个值包装在一个元组中返回。在<code>main</code>函数中，<code>let</code>语句就可以使用模式匹配将函数返回的元组进行解构，将这两个返回值分别赋给<code>p2</code>和<code>p3</code>，从而可以得到<code>789</code>二次方的值和三次方的值。</p>
<a class="header" href="print.html#a发散函数" id="a发散函数"><h2>发散函数</h2></a>
<p>发散函数（diverging function）是Rust中的一个特性。发散函数不返回，它使用感叹号<code>!</code>作为返回类型表示：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  println!(&quot;hello&quot;);
  diverging();
  println!(&quot;world&quot;);
}

fn diverging() -&gt; ! {
  panic!(&quot;This function will never return&quot;);
}
</code></pre></pre>
<p>由于发散函数不会返回，所以就算其后再有其他语句也是不会执行的。倘若其后还有其他语句，会出现如下编译警告：<img src="../images/function-return-value.png" alt="error" />。当然了，我们要知道的是不发散的函数也是可以不返回的，比如无限循环之类的。
发散函数一般都以<code>panic!</code>宏调用或其他调用其他发散函数结束，所以，调用发散函数会导致当前线程崩溃。</p>
<p><a href="http://doc.rust-lang.org/reference.html#diverging-functions">Rust Reference 6.1.3.2 Diverging functions</a>中的描述如下：</p>
<blockquote>
<p>We call such functions &quot;diverging&quot; because they never return a value to the caller. Every control path in a diverging function must end with a panic!() or a call to another diverging function on every control path. The ! annotation does not denote a type.</p>
</blockquote>
<a class="header" href="print.html#a语句和表达式" id="a语句和表达式"><h1>语句和表达式</h1></a>
<p>Rust是一个基于表达式的语言，不过它也有语句。
Rust只有两种语句：</p>
<ul>
<li>声明语句</li>
<li>表达式语句</li>
</ul>
<p>基于表达式是函数式语言的一个重要特征，表达式总是返回值。</p>
<a class="header" href="print.html#a声明语句" id="a声明语句"><h2>声明语句</h2></a>
<p>Rust的声明语句，可以分为两种，一种为<code>变量声明语句</code>，另一种为<code>Item声明语句</code>。</p>
<ol>
<li>
<p>变量声明语句。主要是指<code>let</code>语句，如:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = 8;
let b: Vec&lt;f64&gt; = Vec::new();
let (a, c) = (&quot;hi&quot;, false);
#}</code></pre></pre>
<p>由于<code>let</code>是语句，所以不能将<code>let</code>语句绑定到其他值。如下形式是错误的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let b = (let a = 8);
#}</code></pre></pre>
<p>rustc编译器会给出错误信息：<img src="../images/function-statement-expression.png" alt="error" /></p>
</li>
<li>
<p>Item声明。是指<code>函数</code>（function）、<code>结构体</code>（structure）、<code>类型别名</code>（type）、<code>静态变量</code>（static）、<code>特质</code>（trait）、<code>实现</code>（implementation）或<code>模块</code>（module）的声明。这些声明可以嵌套在任意<code>块（block）</code>中。关于Item声明，Rust Reference中的描述如下：</p>
<blockquote>
<p>An item declaration statement has a syntactic form identical to an item declaration within a module. Declaring an item — a function, enumeration, structure, type, static, trait, implementation or module — locally within a statement block is simply a way of restricting its scope to a narrow region containing all of its uses; it is otherwise identical in meaning to declaring the item outside the statement block.</p>
</blockquote>
<p>当然，这里不能展开讲这些Item都是如何声明的，详情请看RustPrimer的其他相关章节。</p>
</li>
</ol>
<a class="header" href="print.html#a表达式语句" id="a表达式语句"><h2>表达式语句</h2></a>
<p>表达式语句，由一个表达式和一个分号组成，即在表达式后面加一个分号就将一个表达式转变为了一个语句。所以，有多少种表达式，就有多少种表达式语句。</p>
<p><strong>Rust有许多种表达式：</strong></p>
<ul>
<li>
<p>字面表达式（literal expression）</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
();         // unit type
&quot;hello&quot;;    // string type
'1';        // character type
15;         // integer type
#}</code></pre></pre>
</li>
<li>
<p>元组表达式(Tuple expression)：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(0.0, 4.5);
(&quot;a&quot;, 4usize, true);
#}</code></pre></pre>
<p>通常不使用一个元素的元组，不过如果你坚持的话，rust也是允许的，不过需要在元素后加一个逗号：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(0,); // single-element tuple
(0);  // zero in parentheses
#}</code></pre></pre>
</li>
<li>
<p>结构体表达式（structure expression）
由于结构体有多种形式，所以结构体表达式也有多种形式。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Point {x: 10.0, y: 20.0};
TuplePoint(10.0, 20.0);
let u = game::User {name: &quot;Joe&quot;, age: 35, score: 100_000};
some_fn::&lt;Cookie&gt;(Cookie);
#}</code></pre></pre>
<p>结构体表达式一般用于构造一个结构体对象，它除了以上从零构建的形式外，还可以在另一个对象的基础上进行构建：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let base = Point3d {x: 1, y: 2, z: 3};
Point3d {y: 0, z: 10, .. base};
#}</code></pre></pre>
</li>
<li>
<p>块表达式（block expression）：
块表达式就是用花括号<code>{}</code>括起来的一组表达式的集合，表达式间一般以分号分隔。块表达式的值，就是最后一个表达式的值。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i32 = { println!(&quot;Hello.&quot;); 5 };
#}</code></pre></pre>
<p>如果以语句结尾，则块表达式的值为<code>()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: () = { println!(&quot;Hello.&quot;); };
#}</code></pre></pre>
</li>
<li>
<p>范围表达式（range expression）:
可以使用范围操作符<code>..</code>来构建范围对象（variant of <code>std::ops::Range</code>）：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
#}</code></pre></pre>
</li>
<li>
<p>if表达式（if expression）：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = 9;
let b = if a%2 == 0 {&quot;even&quot;} else {&quot;odd&quot;};
#}</code></pre></pre>
</li>
<li>
<p>除了以上这些外，还有许多，如：</p>
<ul>
<li>path expression</li>
<li>mehond-call expression</li>
<li>field expression</li>
<li>array expression</li>
<li>index expression</li>
<li>unary operator expression</li>
<li>binary operator expression</li>
<li>return expression</li>
<li>grouped expression</li>
<li>match expression</li>
<li>if expression</li>
<li>lambda expression</li>
<li>... ...</li>
</ul>
<p>这里无法详细展开，读者可以到[Rust Reference][1]去查看。
[1]:http://doc.rust-lang.org/reference.html#statements-and-expressions</p>
</li>
</ul>
<blockquote>
<a class="header" href="print.html#a以上表达式语句中的部分例子引用自a-hrefhttpdocrust-langorgreferencehtmlrust-referencea" id="a以上表达式语句中的部分例子引用自a-hrefhttpdocrust-langorgreferencehtmlrust-referencea"><h4>以上表达式语句中的部分例子引用自<a href="http://doc.rust-lang.org/reference.html">Rust Reference</a></h4></a>
</blockquote>
<a class="header" href="print.html#a高阶函数-1" id="a高阶函数-1"><h1>高阶函数</h1></a>
<p>高阶函数与普通函数的不同在于，它可以使用一个或多个函数作为参数，可以将函数作为返回值。</p>
<p>Rust的函数是一等公民(first class type)，所以支持高阶函数。
而，由于Rust是一个强类型的语言，如果要将函数作为参数或返回值，首先需要搞明白函数的类型。
下面先说函数的类型，再说函数作为参数和返回值。</p>
<a class="header" href="print.html#a函数类型" id="a函数类型"><h2>函数类型</h2></a>
<p>前面说过，关键字<code>fn</code>可以用来定义函数。除此以外，它还用来构造函数类型。与函数定义主要的不同是，构造函数类型不需要函数名、参数名和函数体。在Rust Reference中的描述如下：</p>
<blockquote>
<p>The function type constructor fn forms new function types. A function type consists of a possibly-empty set of function-type modifiers (such as unsafe or extern), a sequence of input types and an output type.</p>
</blockquote>
<p>来看一个简单例子：</p>
<pre><pre class="playpen"><code class="language-rust">// 函数定义
fn inc(n: i32) -&gt; i32 {
  n + 1
}

// 构造函数类型
type IncType = fn(i32) -&gt; i32;

// 主函数
fn main() {
  let func: IncType = inc;
  println!(&quot;3 + 1 = {}&quot;, func(3));
}

</code></pre></pre>
<p>上例，首先使用<code>fn</code>定义了<code>inc</code>函数，它有一个<code>i32</code>类型参数，返回<code>i32</code>类型的值。然后再用<code>fn</code>定义了一个函数类型，这个函数类型有i32类型的参数和i32类型的返回值，并用<code>type</code>关键字定义了它的别名<code>IncType</code>。在<code>main</code>函数中定义了一个变量<code>func</code>，其类型就为<code>IncType</code>，并赋值为<code>inc</code>，然后在<code>pirntln</code>宏中调用：<code>func(3)</code>。可以看到，<code>inc</code>函数的类型其实就是<code>IncType</code>。</p>
<p>这里有一个问题，我们将<code>inc</code>绑定到<code>func</code>，而不是<code>&amp;inc</code>，这样是将<code>inc</code>函数的拥有权转给了<code>func</code>吗，赋值后还可以以<code>inc()</code>形式调用<code>inc</code>函数吗？先来看一个例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let func: IncType = inc;
  println!(&quot;3 + 1 = {}&quot;, func(3));
  println!(&quot;3 + 1 = {}&quot;, inc(3));
}

type IncType = fn(i32) -&gt; i32;

fn inc(n: i32) -&gt; i32 {
  n + 1
}
</code></pre></pre>
<p>我们将上例保存在rs源文件中，再用rustc编译，发现并没有报错，并且运行也得到我们想要的结果：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
3 + 1 = 4
3 + 1 = 4
#}</code></pre></pre>
<p>这说明，赋值时，<code>inc</code>函数的所有权并没有被转移到<code>func</code>变量上，而是更像不可变引用。在Rust中，函数的所有权是不能转移的，我们给函数类型的变量指定绑定时，绑定的一般是函数的指针，所以Rust中的函数类型，就像是C/C++中的函数指针，当然，Rust的函数类型更安全。可见，Rust的函数类型，其实应该是属于指针类型（Pointer Type）。</p>
<p>Rust的Pointer Type有两种，一种为引用（Reference<code>&amp;</code>），另一种为原始指针（Raw pointer <code>*</code>），详细内容请看<a href="http://doc.rust-lang.org/reference.html#pointer-types">Rust Reference 8.18 Pointer Types</a>。而Rust的函数类型应是引用类型，因为它是安全的，而原始指针则是不安全的，要使用原始指针，必须使用<code>unsafe</code>关键字声明。</p>
<a class="header" href="print.html#a函数作为参数" id="a函数作为参数"><h2>函数作为参数</h2></a>
<p>函数作为参数，其声明与普通参数一样。看下例：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  println!(&quot;3 + 1 = {}&quot;, process(3, inc));
  println!(&quot;3 - 1 = {}&quot;, process(3, dec));
}

fn inc(n: i32) -&gt; i32 {
  n + 1
}

fn dec(n: i32) -&gt; i32 {
  n - 1
}

fn process(n: i32, func: fn(i32) -&gt; i32) -&gt; i32 {
  func(n)
}
</code></pre></pre>
<p>例子中，<code>process</code>就是一个高阶函数，它有两个参数，一个类型为<code>i32</code>的<code>n</code>，另一个类型为<code>fn(i32)-&gt;i32</code>的函数<code>func</code>，返回一个<code>i32</code>类型的参数；它在函数体内以<code>n</code>作为参数调用<code>func</code>函数，返回<code>func</code>函数的返回值。运行可以得到以下结果：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
3 + 1 = 4
3 - 1 = 2
#}</code></pre></pre>
<p>不过，这不是函数作为参数的唯一声明方法，使用泛型函数配合特质（<code>trait</code>）也是可以的，因为Rust的函数都会实现一个<code>trait</code>:<code>FnOnce</code>、<code>Fn</code>或<code>FnMut</code>。将上例中的<code>process</code>函数定义换成以下形式是等价的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn process&lt;F&gt;(n: i32, func: F) -&gt; i32
    where F: Fn(i32) -&gt; i32 {
    func(n)
}
#}</code></pre></pre>
<a class="header" href="print.html#a函数作为返回值" id="a函数作为返回值"><h2>函数作为返回值</h2></a>
<p>将函数作为返回值，其声明与普通函数的返回值类型声明一样。看例子：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let a = [1,2,3,4,5,6,7];
   let mut b = Vec::&lt;i32&gt;::new();
   for i in &amp;a {
       b.push(get_func(*i)(*i));
   }
   println!(&quot;{:?}&quot;, b);
}

fn get_func(n: i32) -&gt; fn(i32) -&gt; i32 {
    // 函数定义
    fn inc(n: i32) -&gt; i32 {
        n + 1
    }

    // 函数定义
    fn dec(n: i32) -&gt; i32 {
        n - 1
    }

    // Note： 以下内容，返回函数
    if n % 2 == 0 {
        inc
    } else {
        dec
    }
}
</code></pre></pre>
<p>例子中的高阶函数为<code>get_func</code>，它接收一个<code>i32</code>类型的参数，返回一个类型为<code>fn(i32) -&gt; i32</code>的函数，若传入的参数为偶数，返回<code>inc</code>，否则返回<code>dec</code>。这里需要注意的是，<code>inc</code>函数和<code>dec</code>函数都定义在<code>get_func</code>内。</p>
<p>在函数内定义函数在很多其他语言中是不支持的，不过Rust支持，这也是Rust灵活和强大的一个体现。不过，在函数中定义的函数，不能包含函数中（环境中）的变量，若要包含，应该闭包（详看13章 闭包）。
所以下例：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let f = get_func();
  println!(&quot;{}&quot;, f(3));
}

fn get_func() -&gt; fn(i32)-&gt;i32 {
  let a = 1;
  fn inc(n:i32) -&gt; i32 {
    n + a
  }
  inc
}
</code></pre></pre>
<p>使用rustc编译，会出现如下错误：
<img src="../images/high-order-function.png" alt="error" /></p>
<a class="header" href="print.html#a闭包" id="a闭包"><h1>闭包</h1></a>
<p>闭包是什么？先来看看<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">维基百科</a>上的描述：</p>
<blockquote>
<p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是 <strong>引用了自由变量的函数</strong>。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。<br /><br />
闭包的概念出现于60年代，最早实现闭包的程序语言是Scheme。之后，闭包被广泛使用于函数式编程语言如ML语言和LISP。很多命令式程序语言也开始支持闭包。</p>
</blockquote>
<p>可以看到，第一句就已经说明了什么是闭包：闭包是引用了自由变量的函数。所以，闭包是一种特殊的函数。</p>
<p>在rust中，函数和闭包都是实现了<code>Fn</code>、<code>FnMut</code>或<code>FnOnce</code>特质（trait）的类型。任何实现了这三种特质其中一种的类型的对象，都是 <strong>可调用对象</strong> ，都能像函数和闭包一样通过这样<code>name()</code>的形式调用，<code>()</code>在rust中是一个操作符，操作符在rust中是可以重载的。rust的操作符重载是通过实现相应的<code>trait</code>来实现，而<code>()</code>操作符的相应<code>trait</code>就是<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>，所以，任何实现了这三个<code>trait</code>中的一种的类型，其实就是重载了<code>()</code>操作符。关于<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>的说明请看第二节闭包的实现。</p>
<p>本章主要分四节讲述：</p>
<ul>
<li><a href="overview.md">第一节 概要</a></li>
<li><a href="syntax.md">第二节 闭包的语法</a></li>
<li><a href="implementation.md">第三节 闭包的实现</a></li>
<li><a href="as_argument_return_value.md">第四节 闭包作为参数或返回值</a></li>
</ul>
<a class="header" href="print.html#a闭包的语法" id="a闭包的语法"><h1>闭包的语法</h1></a>
<a class="header" href="print.html#a基本形式" id="a基本形式"><h2>基本形式</h2></a>
<p>闭包看起来像这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
#}</code></pre></pre>
<p>我们创建了一个绑定，<code>plus_one</code>，并把它赋予一个闭包。闭包的参数位于管道（<code>|</code>）之中，而闭包体是一个表达式，在这个例子中，<code>x + 1</code>。记住<code>{}</code>是一个表达式，所以我们也可以拥有包含多行的闭包：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
#}</code></pre></pre>
<p>你会注意到闭包的一些方面与用<code>fn</code>定义的常规函数有点不同。第一个是我们并不需要标明闭包接收和返回参数的类型。我们可以：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let plus_one = |x: i32| -&gt; i32 { x + 1 };

assert_eq!(2, plus_one(1));
#}</code></pre></pre>
<p>不过我们并不需要这么写。为什么呢？基本上，这是出于“人体工程学”的原因。因为为命名函数指定全部类型有助于像文档和类型推断，而闭包的类型则很少有文档因为它们是匿名的，并且并不会产生像推断一个命名函数的类型这样的“远距离错误”。</p>
<p>第二个的语法大同小异。我会增加空格来使它们看起来更像一点：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn  plus_one_v1   (x: i32) -&gt; i32 { x + 1 }
let plus_one_v2 = |x: i32| -&gt; i32 { x + 1 };
let plus_one_v3 = |x: i32|          x + 1  ;
#}</code></pre></pre>
<a class="header" href="print.html#a捕获变量" id="a捕获变量"><h2>捕获变量</h2></a>
<p>之所以把它称为“闭包”是因为它们“包含在环境中”（close over their environment）。这看起来像：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = 5;
let plus_num = |x: i32| x + num;

assert_eq!(10, plus_num(5));
#}</code></pre></pre>
<p>这个闭包，<code>plus_num</code>，引用了它作用域中的<code>let</code>绑定：<code>num</code>。更明确的说，它借用了绑定。如果我们做一些会与这个绑定冲突的事，我们会得到一个错误。比如这个：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &amp;mut num;
#}</code></pre></pre>
<p>错误是：</p>
<pre><code class="language-text">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;

    let y = &amp;mut num;
}
^
</code></pre>
<p>一个啰嗦但有用的错误信息！如它所说，我们不能取得一个<code>num</code>的可变借用因为闭包已经借用了它。如果我们让闭包离开作用域，我们可以：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;
{
    let plus_num = |x: i32| x + num;

} // plus_num goes out of scope, borrow of num ends

let y = &amp;mut num;
#}</code></pre></pre>
<p>如果你的闭包需要它，Rust会取得所有权并移动环境：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

let takes_nums = || nums;

println!(&quot;{:?}&quot;, nums);
#}</code></pre></pre>
<p>这会给我们：</p>
<pre><code class="language-text">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let takes_nums = || nums;
                    ^~~~~~~
</code></pre>
<p><code>Vec&lt;T&gt;</code>拥有它内容的所有权，而且由于这个原因，当我们在闭包中引用它时，我们必须取得<code>nums</code>的所有权。这与我们传递<code>nums</code>给一个取得它所有权的函数一样。</p>
<a class="header" href="print.html#move闭包" id="move闭包"><h2>move闭包</h2></a>
<p>我们可以使用<code>move</code>关键字强制使我们的闭包取得它环境的所有权：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = 5;

let owns_num = move |x: i32| x + num;
#}</code></pre></pre>
<p>现在，即便关键字是<code>move</code>，变量遵循正常的移动语义。在这个例子中，<code>5</code>实现了<code>Copy</code>，所以<code>owns_num</code>取得一个<code>5</code>的拷贝的所有权。那么区别是什么呢？</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
#}</code></pre></pre>
<p>那么在这个例子中，我们的闭包取得了一个<code>num</code>的可变引用，然后接着我们调用了<code>add_num</code>，它改变了其中的值，正如我们期望的。我们也需要将<code>add_num</code>声明为<code>mut</code>，因为我们会改变它的环境。</p>
<p>如果我们加上<code>move</code>修饰闭包，会发生些不同：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
#}</code></pre></pre>
<p>我们只会得到<code>5</code>。这次我们没有获取到外部的<code>num</code>的可变借用，我们实际上是把 <code>num</code> move 进了闭包。因为 <code>num</code> 具有 Copy 属性，因此发生 move 之后，以前的变量生命周期并未结束，还可以继续在 <code>assert_eq!</code> 中使用。我们打印的变量和闭包内的变量是独立的两个变量。如果我们捕获的环境变量不是 Copy 的，那么外部环境变量被 move 进闭包后，
它就不能继续在原先的函数中使用了，只能在闭包内使用。</p>
<p>不过在我们讨论获取或返回闭包之前，我们应该更多的了解一下闭包实现的方法。作为一个系统语言，Rust给予你了大量的控制你代码的能力，而闭包也是一样。</p>
<blockquote>
<a class="header" href="print.html#a这部分引用自a-hrefhttpsgithubcomkaiseryrust-book-chineseblobmastercontentclosures20e997ade58c85mdthe-rust-programming-language中文版a" id="a这部分引用自a-hrefhttpsgithubcomkaiseryrust-book-chineseblobmastercontentclosures20e997ade58c85mdthe-rust-programming-language中文版a"><h3>这部分引用自<a href="https://github.com/KaiserY/rust-book-chinese/blob/master/content/Closures%20%E9%97%AD%E5%8C%85.md">The Rust Programming Language中文版</a></h3></a>
</blockquote>
<a class="header" href="print.html#a闭包的实现" id="a闭包的实现"><h1>闭包的实现</h1></a>
<p>Rust 的闭包实现与其它语言有些许不同。它们实际上是trait的语法糖。在这以前你会希望阅读<a href="https://doc.rust-lang.org/stable/book/traits.html">trait章节</a>，和<a href="https://doc.rust-lang.org/stable/book/trait-objects.html">trait对象</a>。</p>
<p>都理解吗？很好。</p>
<p>理解闭包底层是如何工作的关键有点奇怪：使用<code>()</code>调用函数，像<code>foo()</code>，是一个可重载的运算符。到此，其它的一切都会明了。在Rust中，我们使用trait系统来重载运算符。调用函数也不例外。我们有三个trait来分别重载：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
# }
#}</code></pre></pre>
<p>你会注意到这些 trait 之间的些许区别，不过一个大的区别是<code>self</code>：<code>Fn</code>获取<code>&amp;self</code>，<code>FnMut</code>获取<code>&amp;mut self</code>，而<code>FnOnce</code>获取<code>self</code>。这包含了所有3种通过通常函数调用语法的<code>self</code>。不过我们将它们分在 3 个 trait 里，而不是单独的 1 个。这给了我们大量的对于我们可以使用哪种闭包的控制。</p>
<p>闭包的<code>|| {}</code>语法是上面 3 个 trait 的语法糖。Rust 将会为了环境创建一个结构体，<code>impl</code>合适的 trait，并使用它。</p>
<blockquote>
<a class="header" href="print.html#a这部分引用自a-hrefhttpsgithubcomkaiseryrust-book-chineseblobmastercontentclosures20e997ade58c85mdthe-rust-programming-language中文版a-1" id="a这部分引用自a-hrefhttpsgithubcomkaiseryrust-book-chineseblobmastercontentclosures20e997ade58c85mdthe-rust-programming-language中文版a-1"><h3>这部分引用自<a href="https://github.com/KaiserY/rust-book-chinese/blob/master/content/Closures%20%E9%97%AD%E5%8C%85.md">The Rust Programming Language中文版</a></h3></a>
</blockquote>
<a class="header" href="print.html#a闭包作为参数和返回值" id="a闭包作为参数和返回值"><h1>闭包作为参数和返回值</h1></a>
<a class="header" href="print.html#a闭包作为参数taking-closures-as-arguments" id="a闭包作为参数taking-closures-as-arguments"><h2>闭包作为参数（Taking closures as arguments）</h2></a>
<p>现在我们知道了闭包是 trait，我们已经知道了如何接受和返回闭包；就像任何其它的 trait！</p>
<p>这也意味着我们也可以选择静态或动态分发。首先，让我们写一个获取可调用结构的函数，调用它，然后返回结果：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {

    some_closure(1)
}

let answer = call_with_one(|x| x + 2);

assert_eq!(3, answer);
#}</code></pre></pre>
<p>我们传递我们的闭包，<code>|x| x + 2</code>，给<code>call_with_one</code>。它正做了我们说的：它调用了闭包，<code>1</code>作为参数。</p>
<p>让我们更深层的解析<code>call_with_one</code>的签名：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
#    where F : Fn(i32) -&gt; i32 {
#    some_closure(1) }
#}</code></pre></pre>
<p>我们获取一个参数，而它有类型<code>F</code>。我们也返回一个<code>i32</code>。这一部分并不有趣。下一部分是：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {
#   some_closure(1) }
#}</code></pre></pre>
<p>因为<code>Fn</code>是一个trait，我们可以用它限制我们的泛型。在这个例子中，我们的闭包取得一个<code>i32</code>作为参数并返回<code>i32</code>，所以我们用泛型限制是<code>Fn(i32) -&gt; i32</code>。</p>
<p>还有一个关键点在于：因为我们用一个trait限制泛型，它会是单态的，并且因此，我们在闭包中使用静态分发。这是非常简单的。在很多语言中，闭包固定在堆上分配，所以总是进行动态分发。在Rust中，我们可以在栈上分配我们闭包的环境，并静态分发调用。这经常发生在迭代器和它们的适配器上，它们经常取得闭包作为参数。</p>
<p>当然，如果我们想要动态分发，我们也可以做到。trait对象处理这种情况，通常：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    some_closure(1)
}

let answer = call_with_one(&amp;|x| x + 2);

assert_eq!(3, answer);
#}</code></pre></pre>
<p>现在我们取得一个trait对象，一个<code>&amp;Fn</code>。并且当我们将我们的闭包传递给<code>call_with_one</code>时我们必须获取一个引用，所以我们使用<code>&amp;||</code>。</p>
<a class="header" href="print.html#a函数指针和闭包" id="a函数指针和闭包"><h2>函数指针和闭包</h2></a>
<p>一个函数指针有点像一个没有环境的闭包。因此，你可以传递一个函数指针给任何函数除了作为闭包参数，下面的代码可以工作：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    some_closure(1)
}

fn add_one(i: i32) -&gt; i32 {
    i + 1
}

let f = add_one;

let answer = call_with_one(&amp;f);

assert_eq!(2, answer);
#}</code></pre></pre>
<p>在这个例子中，我们并不是严格的需要这个中间变量<code>f</code>，函数的名字就可以了：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let answer = call_with_one(&amp;add_one);
#}</code></pre></pre>
<a class="header" href="print.html#a返回闭包returning-closures" id="a返回闭包returning-closures"><h2>返回闭包（Returning closures）</h2></a>
<p>对于函数式风格代码来说在各种情况返回闭包是非常常见的。如果你尝试返回一个闭包，你可能会得到一个错误。在刚接触的时候，这看起来有点奇怪，不过我们会搞清楚。当你尝试从函数返回一个闭包的时候，你可能会写出类似这样的代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn factory() -&gt; (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
#}</code></pre></pre>
<p>编译的时候会给出这一长串相关错误：</p>
<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; i32` [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(i32) -&gt; i32` [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</code></pre>
<p>为了从函数返回一些东西，Rust 需要知道返回类型的大小。不过<code>Fn</code>是一个 trait，它可以是各种大小(size)的任何东西。比如说，返回值可以是实现了<code>Fn</code>的任意类型。一个简单的解决方法是：返回一个引用。因为引用的大小(size)是固定的，因此返回值的大小就固定了。因此我们可以这样写：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
#}</code></pre></pre>
<p>不过这样会出现另外一个错误：</p>
<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>
<p>对。因为我们有一个引用，我们需要给它一个生命周期。不过我们的<code>factory()</code>函数不接收参数，所以省略不能用在这。我们可以使用什么生命周期呢？<code>'static</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn factory() -&gt; &amp;'static (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
#}</code></pre></pre>
<p>不过这样又会出现另一个错误：</p>
<pre><code class="language-text">error: mismatched types:
 expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
    found `[closure@&lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>
<p>这个错误让我们知道我们并没有返回一个<code>&amp;'static Fn(i32) -&gt; i32</code>，而是返回了一个<code>[closure &lt;anon&gt;:7:9: 7:20]</code>。等等，什么？</p>
<p>因为每个闭包生成了它自己的环境<code>struct</code>并实现了<code>Fn</code>和其它一些东西，这些类型是匿名的。它们只在这个闭包中存在。所以Rust把它们显示为<code>closure &lt;anon&gt;</code>，而不是一些自动生成的名字。</p>
<p>这个错误也指出了返回值类型期望是一个引用，不过我们尝试返回的不是。更进一步，我们并不能直接给一个对象<code>'static</code>声明周期。所以我们换一个方法并通过<code>Box</code>装箱<code>Fn</code>来返回一个 trait 对象。这个<em>几乎</em>可以成功运行：</p>
<pre><pre class="playpen"><code class="language-rust">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre></pre>
<p>这还有最后一个问题：</p>
<pre><code class="language-text">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>
<p>好吧，正如我们上面讨论的，闭包借用他们的环境。而且在这个例子中。我们的环境基于一个栈分配的<code>5</code>，<code>num</code>变量绑定。所以这个借用有这个栈帧的生命周期。所以如果我们返回了这个闭包，这个函数调用将会结束，栈帧也将消失，那么我们的闭包指向了被释放的内存环境！再有最后一个修改，我们就可以让它运行了：</p>
<pre><pre class="playpen"><code class="language-rust">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre></pre>
<p>通过把内部闭包添加<code>move</code>关键字，我们强制闭包使用 move 的方式捕获环境变量。因为这里的 num 类型是 i32，实际上这里的 move 执行的是 copy, 这样一来，闭包就不再拥有指向环境的指针，而是完整拥有了被捕获的变量。并允许它离开我们的栈帧。</p>
<blockquote>
<a class="header" href="print.html#a这部分引用自a-hrefhttpsgithubcomkaiseryrust-book-chineseblobmastercontentclosures20e997ade58c85mdthe-rust-programming-language中文版a-2" id="a这部分引用自a-hrefhttpsgithubcomkaiseryrust-book-chineseblobmastercontentclosures20e997ade58c85mdthe-rust-programming-language中文版a-2"><h3>这部分引用自<a href="https://github.com/KaiserY/rust-book-chinese/blob/master/content/Closures%20%E9%97%AD%E5%8C%85.md">The Rust Programming Language中文版</a></h3></a>
</blockquote>
<a class="header" href="print.html#a模式匹配-1" id="a模式匹配-1"><h1>模式匹配</h1></a>
<p>除了我们常见的控制语句之外，Rust还提供了一个更加强大的关键字——<code>match</code> 。但是，需要指出的一点是，match只是<em>匹配</em>，要发挥其全部威力，还需要<em>模式</em>的配合。本章，我们就将的对Rust的模式匹配进行一番探索。</p>
<p>本章内容：</p>
<ul>
<li><a href="match.md">match关键字</a></li>
<li><a href="pattern.md">模式</a></li>
</ul>
<a class="header" href="print.html#match关键字" id="match关键字"><h1>match关键字</h1></a>
<p>模式匹配，多出现在函数式编程语言之中，为其复杂的类型系统提供一个简单轻松的解构能力。比如从enum等数据结构中取出数据等等，但是在书写上，相对比较复杂。我们来看一个例子:</p>
<pre><pre class="playpen"><code class="language-rust">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        Direction::North | Direction::South =&gt; {
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(&quot;West&quot;),
    };
}
</code></pre></pre>
<p>这是一个没什么实际意义的程序，但是能清楚的表达出match的用法。看到这里，你肯定能想起一个常见的控制语句——<code>switch</code>。没错，match可以起到和switch相同的作用。不过有几点需要注意：</p>
<ol>
<li>match所罗列的匹配，必须穷举出其所有可能。当然，你也可以用 <strong>_</strong> 这个符号来代表其余的所有可能性情况，就类似于switch中的<code>default</code>语句。</li>
<li>match的每一个分支都必须是一个表达式，并且，除非一个分支一定会触发panic，这些分支的所有表达式的最终返回值类型必须相同。</li>
</ol>
<p>关于第二点，有的同学可能不明白。这么说吧，你可以把match整体视为一个表达式，既然是一个表达式，那么就一定能求得它的结果。因此，这个结果当然就可以被赋予一个变量咯。
看代码：</p>
<pre><pre class="playpen"><code class="language-rust">enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    // let d_panic = Direction::South;
    let d_west = Direction::West;
    let d_str = match d_west {
        Direction::East =&gt; &quot;East&quot;,
        Direction::North | Direction::South =&gt; {
            panic!(&quot;South or North&quot;);
        },
        _ =&gt; &quot;West&quot;,
    };

    println!(&quot;{}&quot;, d_str);
}
</code></pre></pre>
<a class="header" href="print.html#a解构初窥" id="a解构初窥"><h2>解构初窥</h2></a>
<p>match还有一个非常重要的作用就是对现有的数据结构进行解构，轻易的可以拿出其中的数据部分来。
比如，以下是比较常见的例子：</p>
<pre><pre class="playpen"><code class="language-rust">enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let action = Action::Say(&quot;Hello Rust&quot;.to_string());
    match action {
        Action::Say(s) =&gt; {
            println!(&quot;{}&quot;, s);
        },
        Action::MoveTo(x, y) =&gt; {
            println!(&quot;point from (0, 0) move to ({}, {})&quot;, x, y);
        },
        Action::ChangeColorRGB(r, g, _) =&gt; {
            println!(&quot;change color into '(r:{}, g:{}, b:0)', 'b' has been ignored&quot;,
                r, g,
            );
        }
    }
}
</code></pre></pre>
<p>有人说了，从这来看也并不觉得match有多神奇啊！别急，请看下一小节——&gt;<a href="pattern.md">模式</a></p>
<a class="header" href="print.html#a模式" id="a模式"><h1>模式</h1></a>
<p>模式，是Rust另一个强大的特性。它可以被用在<code>let</code>和<code>match</code>表达式里面。相信大家应该还记得我们在<a href="../type/compound-types.md">复合类型</a>中提到的关于在let表达式中解构元组的例子，实际上这就是一个模式。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tup = (0u8, 1u8);
let (x, y) = tup;
#}</code></pre></pre>
<p>而且我们需要知道的是，如果一个模式中出现了和当前作用域中已存在的同名的绑定，那么它会覆盖掉外部的绑定。比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;
let c = 'c';

match c {
    x =&gt; println!(&quot;x: {} c: {}&quot;, x, c),
}

println!(&quot;x: {}&quot;, x);
#}</code></pre></pre>
<p>它的输出结果是:</p>
<pre><code>x: c c: c
x: 1
</code></pre>
<p>在以上代码中，match作用域里的<code>x</code>这个绑定被覆盖成了<code>'c'</code>，而出了这个作用域，绑定<code>x</code>又恢复为<code>1</code>。这和变量绑定的行为是一致的。</p>
<a class="header" href="print.html#a更强大的解构" id="a更强大的解构"><h2>更强大的解构</h2></a>
<p>在上一节里，我们初步了解了模式匹配在解构<code>enum</code>时候的便利性，事实上，在Rust中模式可以被用来对任何复合类型进行解构——struct/tuple/enum。现在我们要讲述一个复杂点的例子，对<code>struct</code>进行解构。</p>
<p>首先，我们可以对一个结构体进行标准的解构：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i64,
    y: i64,
}
let point = Point { x: 0, y: 0 };
match point {
    Point { x, y } =&gt; println!(&quot;({},{})&quot;, x, y),
}
#}</code></pre></pre>
<p>最终，我们拿到了<code>Point</code>内部的值。有人说了，那我想改个名字怎么办？
很简单，你可以使用 <code>:</code>来对一个struct的字段进行重命名，如下:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i64,
    y: i64,
}
let point = Point { x: 0, y: 0 };
match point {
    Point { x: x1, y: y1} =&gt; println!(&quot;({},{})&quot;, x1, y1),
}
#}</code></pre></pre>
<p>另外，有的时候我们其实只对某些字段感兴趣，就可以用<code>..</code>来省略其他字段。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i64,
    y: i64,
}

let point = Point { x: 0, y: 0 };

match point {
    Point { y, .. } =&gt; println!(&quot;y is {}&quot;, y),
}
#}</code></pre></pre>
<a class="header" href="print.html#a忽略和内存管理" id="a忽略和内存管理"><h2>忽略和内存管理</h2></a>
<p>总结一下，我们遇到了两种不同的模式忽略的情况——<code>_</code>和<code>..</code>。这里要注意，模式匹配中被忽略的字段是不会被<code>move</code>的，而且实现<code>Copy</code>的也会优先被Copy而不是被<code>move</code>。</p>
<p>说的有点拗口，上代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tuple: (u32, String) = (5, String::from(&quot;five&quot;));

let (x, s) = tuple;

// 以下行将导致编译错误，因为String类型并未实现Copy, 所以tuple被整体move掉了。
// println!(&quot;Tuple is: {:?}&quot;, tuple);

let tuple = (5, String::from(&quot;five&quot;));

// 忽略String类型，而u32实现了Copy，则tuple不会被move
let (x, _) = tuple;

println!(&quot;Tuple is: {:?}&quot;, tuple);
#}</code></pre></pre>
<a class="header" href="print.html#a范围和多重匹配" id="a范围和多重匹配"><h2>范围和多重匹配</h2></a>
<p>模式匹配可以被用来匹配单种可能，当然也就能被用来匹配多种情况：</p>
<a class="header" href="print.html#a范围" id="a范围"><h3>范围</h3></a>
<p>在模式匹配中，当我想要匹配一个数字(字符)范围的时候，我们可以用<code>...</code>来表示：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 ... 10 =&gt; println!(&quot;一到十&quot;),
    _ =&gt; println!(&quot;其它&quot;),
}

let c = 'w';

match c {
    'a' ... 'z' =&gt; println!(&quot;小写字母&quot;),
    'A' ... 'Z' =&gt; println!(&quot;大写字母&quot;),
    _ =&gt; println!(&quot;其他字符&quot;),
}
#}</code></pre></pre>
<a class="header" href="print.html#a多重匹配" id="a多重匹配"><h3>多重匹配</h3></a>
<p>当我们只是单纯的想要匹配多种情况的时候，可以使用 <code>|</code> 来分隔多个匹配条件</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;一或二&quot;),
    _ =&gt; println!(&quot;其他&quot;),
}
#}</code></pre></pre>
<a class="header" href="print.html#ref-和-ref-mut-1" id="ref-和-ref-mut-1"><h2>ref 和 ref mut</h2></a>
<p>前面我们了解到，当被模式匹配命中的时候，未实现<code>Copy</code>的类型会被默认的move掉，因此，原owner就不再持有其所有权。但是有些时候，我们只想要从中拿到一个变量的（可变）引用，而不想将其move出作用域，怎么做呢？答：用<code>ref</code>或者<code>ref mut</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;

match x {
    ref mut mr =&gt; println!(&quot;mut ref :{}&quot;, mr),
}
// 当然了……在let表达式里也能用
let ref mut mrx = x;
#}</code></pre></pre>
<a class="header" href="print.html#a变量绑定-2" id="a变量绑定-2"><h2>变量绑定</h2></a>
<p>在模式匹配的过程内部，我们可以用<code>@</code>来绑定一个变量名，这在复杂的模式匹配中是再方便不过的，比如一个具名的范围匹配如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1u32;
match x {
    e @ 1 ... 5 | e @ 10 ... 15 =&gt; println!(&quot;get:{}&quot;, e),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>如代码所示，e绑定了x的值。</p>
<p>当然，变量绑定是一个极其有用的语法，下面是一个来自官方doc里的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = &quot;Steve&quot;.to_string();
let x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!(&quot;{:?}&quot;, a),
    _ =&gt; {}
}
#}</code></pre></pre>
<p>输出：</p>
<pre><code>Some(&quot;Steve&quot;)
</code></pre>
<a class="header" href="print.html#a后置条件" id="a后置条件"><h2>后置条件</h2></a>
<p>一个后置的if表达式可以被放在match的模式之后，被称为<code>match guards</code>。例如如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
#}</code></pre></pre>
<p>猜一下上面代码的输出？</p>
<p>答案是<code>no</code>。因为guard是后置条件，是整个匹配的后置条件：所以上面的式子表达的逻辑实际上是：</p>
<pre><code>// 伪代码表示
IF y AND (x IN List[4, 5])
</code></pre>
<a class="header" href="print.html#a迭代器-1" id="a迭代器-1"><h1>迭代器</h1></a>
<p>在Rust中，迭代器共分为三个部分：迭代器、适配器、消费者。</p>
<p>其中，迭代器本身提供了一个惰性的序列，适配器对这个序列进行诸如筛选、拼接、转换查找等操作，消费者则在前两者的基础上生成最后的数值集合。</p>
<p>但是，孤立的看这三者其实是没有意义的，因此，本章将在一个大节里联系写出三者。</p>
<p><a href="iterator.md">迭代器</a></p>
<a class="header" href="print.html#a迭代器-2" id="a迭代器-2"><h1>迭代器</h1></a>
<a class="header" href="print.html#a从for循环讲起" id="a从for循环讲起"><h2>从for循环讲起</h2></a>
<p>我们在控制语句里学习了Rust的<code>for</code>循环表达式，我们知道，Rust的for循环实际上和C语言的循环语句是不同的。这是为什么呢？因为，<code>for</code>循环不过是Rust编译器提供的语法糖！</p>
<p>首先，我们知道Rust有一个<code>for</code>循环能够依次对迭代器的任意元素进行访问，即：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for i in 1..10 {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<p>这里我们知道， (1..10) 其本身是一个迭代器，我们能对这个迭代器调用 <code>.next()</code> 方法，因此，<code>for</code>循环就能完整的遍历一个循环。
而对于<code>Vec</code>来说：</p>
<pre><code>let values = vec![1,2,3];
for x in values {
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>在上面的代码中，我们并没有显式地将一个<code>Vec</code>转换成一个迭代器，那么它是如何工作的呢？现在就打开标准库翻api的同学可能发现了,<code>Vec</code>本身并没有实现 <code>Iterator</code> ，也就是说，你无法对<code>Vec</code>本身调用 <code>.next()</code> 方法。但是，我们在搜索的时候，发现了<code>Vec</code>实现了 <code>IntoIterator</code> 的 trait。</p>
<p>其实，<code>for</code>循环真正循环的，并不是一个迭代器(Iterator)，真正在这个语法糖里起作用的，是 <code>IntoIterator</code> 这个 trait。</p>
<p>因此，上面的代码可以被展开成如下的等效代码(只是示意，不保证编译成功):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let values = vec![1, 2, 3];

{
    let result = match IntoIterator::into_iter(values) {
        mut iter =&gt; loop {
            match iter.next() {
                Some(x) =&gt; { println!(&quot;{}&quot;, x); },
                None =&gt; break,
            }
        },
    };
    result
}
#}</code></pre></pre>
<p>在这个代码里，我们首先对<code>Vec</code>调用 <code>into_iter</code> 来判断其是否能被转换成一个迭代器，如果能，则进行迭代。</p>
<p>那么，迭代器自己怎么办？</p>
<p>为此，Rust在标准库里提供了一个实现：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;I: Iterator&gt; IntoIterator for I {
    // ...
}
#}</code></pre></pre>
<p>也就是说，Rust为所有的迭代器默认的实现了 <code>IntoIterator</code>，这个实现很简单，就是每次返回自己就好了。</p>
<p>也就是说：</p>
<p>任意一个 <code>Iterator</code> 都可以被用在 <code>for</code> 循环上！</p>
<a class="header" href="print.html#a无限迭代器" id="a无限迭代器"><h3>无限迭代器</h3></a>
<p>Rust支持通过省略高位的形式生成一个无限长度的自增序列，即：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let inf_seq = (1..).into_iter();
#}</code></pre></pre>
<p>不过不用担心这个无限增长的序列撑爆你的内存，占用你的CPU，因为适配器的惰性的特性，它本身是安全的，除非你对这个序列进行<code>collect</code>或者<code>fold</code>！
不过，我想聪明如你，不会犯这种错误吧！
因此，想要应用这个，你需要用<code>take</code>或者<code>take_while</code>来截断他，必须？ 除非你将它当作一个生成器。当然了，那就是另外一个故事了。</p>
<a class="header" href="print.html#a消费者与适配器" id="a消费者与适配器"><h2>消费者与适配器</h2></a>
<p>说完了<code>for</code>循环，我们大致弄清楚了 <code>Iterator</code> 和 <code>IntoIterator</code> 之间的关系。下面我们来说一说消费者和适配器。</p>
<p>消费者是迭代器上一种特殊的操作，其主要作用就是将迭代器转换成其他类型的值，而非另一个迭代器。</p>
<p>而适配器，则是对迭代器进行遍历，并且其生成的结果是另一个迭代器，可以被链式调用直接调用下去。</p>
<p>由上面的推论我们可以得出: <em>迭代器其实也是一种适配器！</em></p>
<a class="header" href="print.html#a消费者" id="a消费者"><h3>消费者</h3></a>
<p>就像所有人都熟知的生产者消费者模型，迭代器负责生产，而消费者则负责将生产出来的东西最终做一个转化。一个典型的消费者就是<code>collect</code>。前面我们写过<code>collect</code>的相关操作，它负责将迭代器里面的所有数据取出，例如下面的操作：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = (1..20).collect(); //编译通不过的！
#}</code></pre></pre>
<p>尝试运行上面的代码，却发现编译器并不让你通过。因为你没指定类型！指定什么类型呢？原来collect只知道将迭代器收集到一个实现了 <code>FromIterator</code> 的类型中去，但是，事实上实现这个 trait 的类型有很多（Vec, HashMap等），因此，collect没有一个上下文来判断应该将v按照什么样的方式收集！！</p>
<p>要解决这个问题，我们有两种解决办法：</p>
<ol>
<li>
<p>显式地标明<code>v</code>的类型:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;_&gt; = (1..20).collect();
#}</code></pre></pre>
</li>
<li>
<p>显式地指定<code>collect</code>调用时的类型：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = (1..20).collect::&lt;Vec&lt;_&gt;&gt;();
#}</code></pre></pre>
</li>
</ol>
<p>当然，一个迭代器中还存在其他的消费者，比如取第几个值所用的 <code>.nth()</code>函数，还有用来查找值的 <code>.find()</code> 函数，调用下一个值的<code>next()</code>函数等等，这里限于篇幅我们不能一一介绍。所以，下面我们只介绍另一个比较常用的消费者—— <code>fold</code> 。</p>
<p>当然了，提起Rust里的名字你可能没啥感觉，其实，<code>fold</code>函数，正是大名鼎鼎的 MapReduce 中的 Reduce 函数(稍微有点区别就是这个Reduce是带初始值的)。</p>
<p><code>fold</code>函数的形式如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fold(base, |accumulator, element| .. )
#}</code></pre></pre>
<p>我们可以写成如下例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let m = (1..20).fold(1u64, |mul, x| mul*x);
#}</code></pre></pre>
<p>需要注意的是，<code>fold</code>的输出结果的类型，最终是和<code>base</code>的类型是一致的（如果<code>base</code>的类型没指定，那么可以根据前面<code>m</code>的类型进行反推，除非<code>m</code>的类型也未指定），也就是说，一旦我们将上面代码中的<code>base</code>从 <code>1u64</code> 改成 <code>1</code>，那么这行代码最终将会因为数据溢出而崩溃！</p>
<a class="header" href="print.html#a适配器" id="a适配器"><h3>适配器</h3></a>
<p>我们所熟知的生产消费的模型里，生产者所生产的东西不一定都会被消费者买账，因此，需要对原有的产品进行再组装。这个再组装的过程，就是适配器。因为适配器返回的是一个新的迭代器，所以可以直接用链式请求一直写下去。</p>
<p>前面提到了 Reduce 函数，那么自然不得不提一下另一个配套函数 —— <code>map</code> :</p>
<p>熟悉Python语言的同学肯定知道，Python里内置了一个<code>map</code>函数，可以将一个迭代器的值进行变换，成为另一种。Rust中的<code>map</code>函数实际上也是起的同样的作用，甚至连调用方法也惊人的相似！</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(1..20).map(|x| x+1);
#}</code></pre></pre>
<p>上面的代码展示了一个“迭代器所有元素的自加一”操作，但是，如果你尝试编译这段代码，编译器会给你提示：</p>
<pre><code>warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..20).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>呀，这是啥？</p>
<p>因为，所有的适配器，都是惰性求值的！</p>
<p><strong>也就是说，除非你调用一个消费者，不然，你的操作，永远也不会被调用到！</strong></p>
<p>现在，我们知道了<code>map</code>，那么熟悉Python的人又说了，是不是还有<code>filter</code>！？答，有……用法类似，<code>filter</code>接受一个闭包函数，返回一个布尔值，返回<code>true</code>的时候表示保留，<code>false</code>丢弃。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;_&gt; = (1..20).filter(|x| x%2 == 0).collect();
#}</code></pre></pre>
<p>以上代码表示筛选出所有的偶数。</p>
<a class="header" href="print.html#a其他" id="a其他"><h2>其他</h2></a>
<p>上文中我们了解了迭代器、适配器、消费者的基本概念。下面将以例子来介绍Rust中的其他的适配器和消费者。</p>
<a class="header" href="print.html#skip和take" id="skip和take"><h3>skip和take</h3></a>
<p><code>take(n)</code>的作用是取前<code>n</code>个元素，而<code>skip(n)</code>正好相反，跳过前<code>n</code>个元素。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5, 6];
let v_take = v.iter()
    .cloned()
    .take(2)
    .collect::&lt;Vec&lt;_&gt;&gt;();
assert_eq!(v_take, vec![1, 2]);

let v_skip: Vec&lt;_&gt; = v.iter()
    .cloned()
    .skip(2)
    .collect();
assert_eq!(v_skip, vec![3, 4, 5, 6]);
#}</code></pre></pre>
<a class="header" href="print.html#zip-和-enumerate的恩怨情仇" id="zip-和-enumerate的恩怨情仇"><h3>zip 和 enumerate的恩怨情仇</h3></a>
<p><code>zip</code>是一个适配器，他的作用就是将两个迭代器的内容压缩到一起，形成 <code>Iterator&lt;Item=(ValueFromA, ValueFromB)&gt;</code> 这样的新的迭代器；</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let names = vec![&quot;WaySLOG&quot;, &quot;Mike&quot;, &quot;Elton&quot;];
let scores = vec![60, 80, 100];
let score_map: HashMap&lt;_, _&gt; = names.iter()
    .zip(scores.iter())
    .collect();
println!(&quot;{:?}&quot;, score_map);
#}</code></pre></pre>
<p>而<code>enumerate</code>, 熟悉的Python的同学又叫了：Python里也有！对的，作用也是一样的，就是把迭代器的下标显示出来，即：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1u64, 2, 3, 4, 5, 6];
let val = v.iter()
    .enumerate()
    // 迭代生成标，并且每两个元素剔除一个
    .filter(|&amp;(idx, _)| idx % 2 == 0)
    // 将下标去除,如果调用unzip获得最后结果的话，可以调用下面这句，终止链式调用
    // .unzip::&lt;_,_, vec&lt;_&gt;, vec&lt;_&gt;&gt;().1
    .map(|(idx, val)| val)
    // 累加 1+3+5 = 9
    .fold(0u64, |sum, acm| sum + acm);

println!(&quot;{}&quot;, val);
#}</code></pre></pre>
<a class="header" href="print.html#a一系列查找函数" id="a一系列查找函数"><h3>一系列查找函数</h3></a>
<p>Rust的迭代器有一系列的查找函数，比如：</p>
<ul>
<li><code>find()</code>: 传入一个闭包函数，从开头到结尾依次查找能令这个闭包返回<code>true</code>的第一个元素，返回<code>Option&lt;Item&gt;</code></li>
<li><code>position()</code>: 类似<code>find</code>函数，不过这次输出的是<code>Option&lt;usize&gt;</code>，第几个元素。</li>
<li><code>all()</code>: 传入一个函数，如果对于任意一个元素，调用这个函数返回<code>false</code>,则整个表达式返回<code>false</code>，否则返回<code>true</code></li>
<li><code>any()</code>: 类似<code>all()</code>，不过这次是任何一个返回<code>true</code>，则整个表达式返回<code>true</code>，否则<code>false</code></li>
<li><code>max()</code>和<code>min()</code>: 查找整个迭代器里所有元素，返回最大或最小值的元素。注意：因为第七章讲过的<code>PartialOrder</code>的原因，<code>max</code>和<code>min</code>作用在浮点数上会有不符合预期的结果。</li>
</ul>
<p>以上，为常用的一些迭代器和适配器及其用法，仅作科普，对于这一章。我希望大家能够多练习去理解，而不是死记硬背。</p>
<p>好吧，留个习题：</p>
<a class="header" href="print.html#a习题" id="a习题"><h2>习题</h2></a>
<p>利用迭代器生成一个升序的长度为10的水仙花数序列，然后对这个序列进行逆序,并输出</p>
<a class="header" href="print.html#macro" id="macro"><h1>Macro</h1></a>
<a class="header" href="print.html#a简介-4" id="a简介-4"><h2>简介</h2></a>
<p>学过 C 语言的人都知道 <code>#define</code> 用来定义宏(macro)，而且大学很多老师都告诉你尽量少用宏，因为 C 里面的宏是一个很危险的东西-宏仅仅是简单的文本替换，完全不管语法，类型，非常容易出错。听说过或用过 Lisp 的人觉得宏极其强大，就连美国最大的创业孵化器公司创始人 Paul Gram 也极力鼓吹 Lisp 的宏是有多么强大。那么宏究竟是什么样的东西呢？这一章通过 Rust 的宏系统带你揭开宏(Macro)的神秘面纱。</p>
<p>Rust 中的宏几乎无处不在，其实你写的第一个 Rust 程序里面就已经用到了宏，对，就是那个有名的 hello-world。<code>println!(&quot;Hello, world!&quot;)</code> 这句看起来很像函数调用，但是在&quot;函数名&quot;后面加上了感叹号，这个是专门用来区分普通函数调用和宏调用的。另外从形式上看，与函数调用的另一个区别是参数可以用圆括号(<code>()</code>)、花括号(<code>{}</code>)、方括号(<code>[]</code>)中的任意一种括起来，比如这行也可以写成 <code>println![&quot;Hello, world!&quot;]</code> 或 <code>println!{&quot;Hello, world!&quot;}</code>，不过对于 Rust 内置的宏都有约定俗成的括号，比如 <code>vec!</code> 用方括号，<code>assert_eq!</code> 用圆括号。</p>
<p>我们已经在本书中像 <em>println!</em> 这样使用过宏了，但还没完全探索什么是宏以及它是如何工作的。</p>
<p>既然宏看起来与普通函数非常像，那么使用宏有什么好处呢？是否可以用函数取代宏呢？答案显然是否定的，首先 Rust 的函数不能接受任意多个参数，其次函数是不能操作语法单元的，即把语法元素作为参数进行操作，从而生成代码，例如 <code>mod</code>, <code>crate</code> 这些是 Rust 内置的关键词，是不可能直接用函数去操作这些的，而宏就有这个能力。</p>
<ul>
<li>什么是宏以及与函数有何区别</li>
<li>如何定义一个声明式宏（ declarative macro ）来进行元编程（metaprogramming）</li>
<li>如何定义一个过程式宏（ procedural macro ）来自定义 <code>derive</code> traits</li>
</ul>
<a class="header" href="print.html#a宏和函数的区别" id="a宏和函数的区别"><h3>宏和函数的区别</h3></a>
<p>从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的<em>元编程</em>。例如，<em>元编程</em>中使用的 <code>derive</code> 属性，其用来方便生成各种 trait 的实现。我们也在本书中使用过 <code>println!</code> 宏和 <code>vec!</code> 宏。所有的这些宏 <em>扩展开</em> 来以生成比你手写更多的代码。</p>
<blockquote>
<p>要记住：相比函数，宏是用来生成代码的，在调用宏的地方，编译器会先将宏进行展开，生成代码，然后再编译展开后的代码。</p>
</blockquote>
<p>元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数的角色。但宏有一些函数所没有的附加能力。</p>
<p>一个函数标签必须声明函数参数个数和类型。而宏只接受一个可变参数：用一个参数调用 <code>println!(&quot;hello&quot;)</code> 或用两个参数调用 <code>println!(&quot;hello {}&quot;, name)</code> 。而且，宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现 trait 。因为函数是在运行时被调用，同时 trait 需要在运行时实现，所以函数无法像宏这样。</p>
<p>实现一个宏而不是函数的消极面是宏定义要比函数定义更复杂，因为你正在为写 Rust 代码而写代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。</p>
<p>宏和函数的另一个区别是：宏定义无法像函数定义那样出现在模块命名空间中。当使用外部包（ external crate ）时，为了防止无法预料的名字冲突，在导入外部包的同时也必须明确地用 <code>#[macro_use]</code> 注解将宏导入到项目中。下面的例子将所有定义在 <code>serde</code> 包中的宏导入到当前包中：</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate serde;
</code></pre>
<p>如果 <code>extern crate</code> 能够将宏默认导入而无需使用明确的注解，则会阻止你使用同时定义相同宏名的两个包。在练习中，这样的冲突并不经常遇到，但使用的包越多，越有可能遇到。</p>
<p>宏和函数最重要的区别是：在一个文件中，必须在调用宏<code>之前</code>定义或导入宏，然而却可以在任意地方定义或调用函数。</p>
<p>宏定义格式是： <code>macro_rules! macro_name { macro_body }</code>，其中 <code>macro_body</code> 与模式匹配很像， <code>pattern =&gt; do_something</code> ，所以 Rust 的宏又称为 Macro by example (基于例子的宏)。其中 <code>pattern</code> 和 <code>do_something</code> 都是用配对的括号括起来的，括号可以是圆括号、方括号、花括号中的任意一种。匹配可以有多个分支，每个分支以分号结束。</p>
<p>还是先来个简单的例子说明</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! create_function {
    ($func_name:ident) =&gt; (
        fn $func_name() {
            println!(&quot;function {:?} is called&quot;, stringify!($func_name))
        }
    )
}

fn main() {
    create_function!(foo);
    foo();
}

</code></pre></pre>
<p>上面这个简单的例子是用来创建函数，生成的函数可以像普通函数一样调用，这个函数可以打印自己的名字。编译器在看到 <code>create_function!(foo)</code> 时会从前面去找一个叫 <code>create_function</code> 的宏定义，找到之后，就会尝试将参数 <code>foo</code> 代入 <code>macro_body</code>，对每一条模式按顺序进行匹配，只要有一个匹配上，就会将 <code>=&gt;</code> 左边定义的参数代入右边进行替换，如果替换不成功，编译器就会报错而不会往下继续匹配，替换成功就会将右边替换后的代码放在宏调用的地方。这个例子中只有一个模式，即 <code>$func_name:ident</code>，表示匹配一个标识符，如果匹配上就把这个标识符赋值给 <code>$func_name</code>，宏定义里面的变量都是以 <code>$</code> 开头的，相应的类型也是以冒号分隔说明，这里 <code>ident</code> 是变量 <code>$func_name</code> 的类型，表示这个变量是一个 <code>identifier</code>，这是语法层面的类型(designator)，而普通的类型如 <code>char, &amp;str, i32, f64</code> 这些是语义层面的类型。在 <code>main</code> 函数中传给宏调用 <code>create_function</code> 的参数 <code>foo</code> 正好是一个标识符(<code>ident</code>)，所以能匹配上，<code>$func_name</code> 就等于 <code>foo</code>，然后把 <code>$func_name</code> 的值代入 <code>=&gt;</code> 右边，成了下面这样的</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    println!(&quot;function {:?} is called&quot;, stringify!(foo))
}
#}</code></pre></pre>
<p>所以最后编译器编译的实际代码是</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    fn foo() {
        println!(&quot;function {:?} is called&quot;, stringify!(foo))
    }
    foo();
}
</code></pre></pre>
<p>上面定义了 <code>create_function</code> 这个宏之后，就可以随便用来生成函数了，比如调用 <code>create_function!(bar)</code> 就得到了一个名为 <code>bar</code> 的函数</p>
<p>通过上面这个例子，大家对宏应该有一个大致的了解了。下面就具体谈谈宏的各个组成部分。</p>
<a class="header" href="print.html#a宏的结构" id="a宏的结构"><h2>宏的结构</h2></a>
<a class="header" href="print.html#a宏名" id="a宏名"><h3>宏名</h3></a>
<p>宏名字的解析与函数略微有些不同，宏的定义必须出现在宏调用之前，即与 C 里面的函数类似--函数定义或声明必须在函数调用之前，只不过 Rust 宏没有单纯的声明，所以宏在调用之前需要先定义，而 Rust 函数则可以定义在函数调用后面。宏调用与宏定义顺序相关性包括从其它模块中引入的宏，所以引入其它模块中的宏时要特别小心，这个稍后会详细讨论。</p>
<p>下面这个例子宏定义在宏调用后面，编译器会报错说找不到宏定义，而函数则没问题</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 42;
    foo(a);
    bar!(a);
}

fn foo(x: i32) {
    println!(&quot;The argument you passed to function is {}&quot;, x);
}

macro_rules! bar {
    ($x:ident) =&gt; { println!(&quot;The argument you passed to macro is {}&quot;, $x); }
}
</code></pre></pre>
<p>上面例子中把宏定义挪到 <code>main</code> 函数之前或者 <code>main</code> 函数里面 <code>bar!(a)</code> 调用上面，就可以正常编译运行。</p>
<p>宏调用虽然与函数调用很像，但是宏的名字与函数名字是处于不同命名空间的，之所以提出来是因为在有些编程语言里面宏和函数是在同一个命名空间之下的。看过下面的例子就会明白</p>
<pre><pre class="playpen"><code class="language-rust">fn foo(x: i32) -&gt; i32 {
    x * x
}

macro_rules! foo {
    ($x:ident) =&gt; { println!(&quot;{:?}&quot;, $x); }
}
fn main() {
    let a = 5;
    foo!(a);
    println!(&quot;{}&quot;, foo(a));
}
</code></pre></pre>
<a class="header" href="print.html#a指示符designator" id="a指示符designator"><h3>指示符(designator)</h3></a>
<p>宏里面的变量都是以 <code>$</code> 开头的，其余的都是按字面去匹配，以 <code>$</code> 开头的变量都是用来表示语法(syntactic)元素，为了限定匹配什么类型的语法元素，需要用指示符(designator)加以限定，就跟普通的变量绑定一样用冒号将变量和类型分开，当前宏支持以下几种指示符：</p>
<ul>
<li>ident: 标识符，用来表示函数或变量名</li>
<li>expr: 表达式</li>
<li>block: 代码块，用花括号包起来的多个语句</li>
<li>pat: 模式，普通模式匹配（非宏本身的模式）中的模式，例如 <code>Some(t)</code>, <code>(3, 'a', _)</code></li>
<li>path: 路径，注意这里不是操作系统中的文件路径，而是用双冒号分隔的限定名(qualified name)，如 <code>std::cmp::PartialOrd</code></li>
<li>tt: 单个语法树</li>
<li>ty: 类型，语义层面的类型，如 <code>i32</code>, <code>char</code></li>
<li>item: 条目，</li>
<li>meta: 元条目</li>
<li>stmt: 单条语句，如 <code>let a = 42;</code></li>
</ul>
<p>加上这些类型限定后，宏在进行匹配时才不会漫无目的的乱匹配，例如在要求标识符的地方是不允许出现表达式的，否则编译器就会报错。而 C/C++ 语言中的宏则仅仅是简单的文本替换，没有语法层面的考虑，所以非常容易出错。</p>
<a class="header" href="print.html#a重复repetition" id="a重复repetition"><h3>重复(repetition)</h3></a>
<p>宏相比函数一个很大的不同是宏可以接受任意多个参数，例如 <code>println!</code> 和 <code>vec!</code>。这是怎么做到的呢？</p>
<p>没错，就是重复(repetition)。模式的重复不是通过程序里面的循环(for/while)去控制的，而是指定了两个特殊符号 <code>+</code> 和 <code>*</code>，类似于正则表达式，因为正则表达式也是不关心具体匹配对象是一个人名还是一个国家名。与正则表达式一样， <code>+</code> 表示一次或多次（至少一次），而 <code>*</code> 表示零次或多次。重复的模式需要用括号括起来，外面再加上 <code>$</code>，例如 <code>$(...)*</code>, <code>$(...)+</code>。需要说明的是这里的括号和宏里面其它地方一样都可以是三种括号中的任意一种，因为括号在这里仅仅是用来标记一个模式的开始和结束，大部分情况重复的模式是用逗号或分号分隔的，所以你会经常看到 <code>$(...),*</code>, <code>$(...);*</code>, <code>$(...),+</code>, <code>$(...);+</code> 这样的用来表示重复。</p>
<p>还是来看一个例子</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! vector {
    ($($x:expr),*) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(temp_vec.push($x);)*
            temp_vec
        }
    };
}

fn main() {
    let a = vector![1, 2, 4, 8];
    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<p>这个例子初看起来比较复杂，我们来分析一下。</p>
<p>首先看 <code>=&gt;</code> 左边，最外层是圆括号，前面说过这个括号可以是圆括号、方括号、花括号中的任意一种，只要是配对的就行。然后再看括号里面 <code>$(...),*</code> 正是刚才提到的重复模式，重复的模式是用逗号分隔的，重复的内容是 <code>$x:expr</code>，即可以匹配零次或多次用逗号分隔的表达式，例如 <code>vector![]</code> 和 <code>vector![3, x*x, s-t]</code> 都可以匹配成功。</p>
<p>接着看 <code>=&gt;</code> 右边，最外层也是一个括号，末尾是分号表示这个分支结束。里面是花括号包起来的代码块，最后一行没有分号，说明这个 macro 的值是一个表达式，<code>temp_vec</code> 作为表达式的值返回。第一条语句就是普通的用 <code>Vec::new()</code> 生成一个空 vector，然后绑定到可变的变量 <code>temp_vec</code> 上面，第二句比较特殊，跟 <code>=&gt;</code> 左边差不多，也是用来表示重复的模式，而且是跟左边是一一对应的，即左边匹配到一个表达式(<code>expr</code>)，这里就会将匹配到的表达式用在 <code>temp_vec.push($x);</code> 里面，所以 <code>vector![3, x*x, s-t]</code> 调用就会展开成</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let mut temp_vec = Vec::new();
    temp_vec.push(3);
    temp_vec.push(x*x);
    temp_vec.push(s-t);
    temp_vec
}
#}</code></pre></pre>
<p>看着很复杂的宏，细细分析下来是不是很简单，不要被这些符号干扰了</p>
<a class="header" href="print.html#a递归recursion" id="a递归recursion"><h3>递归(recursion)</h3></a>
<p>除了重复之外，宏还支持递归，即在宏定义时调用其自身，类似于递归函数。因为rust的宏本身是一种模式匹配，而模式匹配里面包含递归则是函数式语言里面最常见的写法了，有函数式编程经验的对这个应该很熟悉。下面看一个简单的例子：</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! find_min {
    ($x:expr) =&gt; ($x);
    ($x:expr, $($y:expr),+) =&gt; (
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<p>因为模式匹配是按分支顺序匹配的，一旦匹配成功就不会再往下进行匹配（即使后面也能匹配上），所以模式匹配中的递归都是在第一个分支里写最简单情况，越往下包含的情况越多。这里也是一样，第一个分支 <code>($x:expr)</code> 只匹配一个表达式，第二个分支匹配两个或两个以上表达式，注意加号表示匹配一个或多个，然后里面是用标准库中的 <code>min</code> 比较两个数的大小，第一个表达式和剩余表达式中最小的一个，其中剩余表达式中最小的一个是递归调用 <code>find_min!</code> 宏，与递归函数一样，每次递归都是从上往下匹配，只到匹配到基本情况。我们来写写 <code>find_min!(5u32, 2u32 * 3, 4u32)</code> 宏展开过程</p>
<ol>
<li><code>std::cmp::min(5u32, find_min!(2u32 * 3, 4u32))</code></li>
<li><code>std::cmp::min(5u32, std::cmp::min(2u32 * 3, find_min!(4u32)))</code></li>
<li><code>std::cmp::min(5u32, std::cmp::min(2u32 * 3, 4u32))</code></li>
</ol>
<p>分析起来与递归函数一样，也比较简单。</p>
<a class="header" href="print.html#a卫生hygienic-macro" id="a卫生hygienic-macro"><h3>卫生(hygienic Macro)</h3></a>
<p>有了重复和递归，组合起来就是一个很强大的武器，可以解决很多普通函数无法抽象的东西。但是这里面会有一个安全问题，也是 C/C++ 里面宏最容易出错的地方，不过 Rust 像 Scheme 一样引入了卫生(Hygiene)宏，有效地避免了这类问题的发生。</p>
<p>C/C++ 里面的宏仅仅是简单的文本替换，下面的 C 经过宏预处理后，宏外面定义的变量 <code>a</code> 就会与里面定义的混在一起，从而按作用域 shadow 外层的定义，这会导致一些非常诡异的问题，不去看宏具体定义仔细分析的话，很难发现这类 bug。这样的宏是不卫生的，不过也有些奇葩的 Hacker 觉得这是一个非常棒的特性，例如 CommanLisp 语言里面的宏本身很强大，但不是卫生的，而某些 Hacker 还以这个为傲，搞一些奇技淫巧故意制造出这样的 shadow 行为实现一些很 fancy 的效果。这里不做过多评论，对 C 比较熟悉的同学可以分析一下下面这段代码运行结果与第一印象是否一样。</p>
<pre><code class="language-c">#define INCI(i) {int a=0; ++i;}
int main(void)
{
    int a = 0, b = 0;
    INCI(a);
    INCI(b);
    printf(&quot;a is now %d, b is now %d\n&quot;, a, b);
    return 0;
}
</code></pre>
<p>卫生宏最开始是由 Scheme 语言引入的，后来好多语言基本都采用卫生宏，即编译器或运行时会保证宏里面定义的变量或函数不会与外面的冲突，在宏里面以普通方式定义的变量作用域不会跑到宏外面。</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! foo {
    () =&gt; (let x = 3);
}

macro_rules! bar {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
    bar!(a);
    println!(&quot;{}&quot;, a);
}
</code></pre></pre>
<p>上面代码中宏 <code>foo!</code> 里面的变量 <code>x</code> 是按普通方式定义的，所以其作用域限定在宏里面，宏调用结束后再引用 <code>x</code> 编译器就会报错。要想让宏里面定义的变量在宏调用结束后仍然有效，需要按 <code>bar!</code> 里面那样定义。不过对于 <code>item</code> 规则就有些不同，例如函数在宏里面以普通方式定义后，宏调用之后，这个函数依然可用，下面代码就可以正常编译。</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</code></pre></pre>
<a class="header" href="print.html#a导入导出importexport" id="a导入导出importexport"><h2>导入导出(import/export)</h2></a>
<p>前面提到宏名是按顺序解析的，所以从其它模块中导入宏时与导入函数、trait 的方式不太一样，宏导入导出用 <code>#[macro_use]</code> 和 <code>#[macro_export]</code>。父模块中定义的宏对其下的子模块是可见的，要想子模块中定义的宏在其后面的父模块中可用，需要使用 <code>#[macro_use]</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! m1 { () =&gt; (()) }

// 宏 m1 在这里可用

mod foo {
    // 宏 m1 在这里可用

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // 宏 m1 和 m2 在这里可用
}

// 宏 m1 在这里可用
#[macro_export]
macro_rules! m3 { () =&gt; (()) }

// 宏 m1 和 m3 在这里可用

#[macro_use]
mod bar {
    // 宏 m1 和 m3 在这里可用

    macro_rules! m4 { () =&gt; (()) }

    // 宏 m1, m3, m4 在这里均可用
}

// 宏 m1, m3, m4 均可用
#}</code></pre></pre>
<p>crate 之间只有被标为 <code>#[macro_export]</code> 的宏可以被其它 crate 导入。假设上面例子是 <code>foo</code> crate 中的部分代码，则只有 <code>m2</code> 和 <code>m3</code> 可以被其它 crate 导入。导入方式是在 <code>extern crate foo;</code> 前面加上 <code>#[macro_use]</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate foo;
// foo 中 m2, m3 都被导入
#}</code></pre></pre>
<p>如果只想导入 <code>foo</code> crate 中某个宏，比如 <code>m3</code>，就给 <code>#[macro_use]</code> 加上参数</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use(m3)]
extern crate foo;
// foo 中只有 m3 被导入
#}</code></pre></pre>
<a class="header" href="print.html#a调试" id="a调试"><h2>调试</h2></a>
<p>虽然宏功能很强大，但是调试起来要比普通代码困难，因为编译器默认情况下给出的提示都是对宏展开之后的，而不是你写的原程序，要想在编译器错误与原程序之间建立联系比较困难，因为这要求你大脑能够人肉编译展开宏代码。不过还好编译器为我们提供了 <code>--pretty=expanded</code> 选项，能让我们看到展开后的代码，通过这个展开后的代码，往上靠就与你自己写的原程序有个直接对应关系，往下靠与编译器给出的错误也是直接对应关系。</p>
<p>目前将宏展开需要使用 unstable option，通过 <code>rustc -Z unstable-options --pretty=expanded hello.rs</code> 可以查看宏展开后的代码，如果是使用的 cargo 则通过 <code>cargo rustc -- -Z unstable-options --pretty=expanded</code> 将项目里面的宏都展开。不过目前是没法只展开部分宏的，而且由于 hygiene 的原因，会对宏里面的名字做些特殊的处理(mangle)，所以程序里面的宏全部展开后代码的可读性比较差，不过依然比依靠大脑展开靠谱。</p>
<p>下面可以看看最简单的 hello-word 程序里面的 <code>println!(&quot;Hello, world!&quot;)</code> 展开结果，为了 hygiene 这里内部临时变量用了 <code>__STATIC_FMTSTR</code> 这样的名字以避免名字冲突，即使这简单的一句展开后看起来也还是不那么直观的，具体这里就不详细分析了。</p>
<pre><code>$ rustc -Z unstable-options --pretty expanded hello.rs
#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std as std;
fn main() {
    ::std::io::_print(::std::fmt::Arguments::new_v1({
                                                        static __STATIC_FMTSTR:
                                                               &amp;'static [&amp;'static str]
                                                               =
                                                            &amp;[&quot;Hello, world!\n&quot;];
                                                        __STATIC_FMTSTR
                                                    },
                                                    &amp;match () { () =&gt; [], }));
}
</code></pre>
<hr />
<a class="header" href="print.html#a以下内容做为补充内容" id="a以下内容做为补充内容"><h2>以下内容做为补充内容</h2></a>
<a class="header" href="print.html#a通用元编程的声明式宏-macro_rules" id="a通用元编程的声明式宏-macro_rules"><h3>通用元编程的声明式宏 <code>macro_rules!</code></h3></a>
<p>在 Rust 中，最广泛使用的宏形式是 <em>declarative macros</em> 。通常也指 <em>macros by example</em> 、<em><code>macro_rules!</code> macros</em> 或简单的 <em>macros</em> 。在其核心中，声明式宏使你可以写一些和 Rust 的 <code>match</code> 表达式类似的代码。正如在第六章讨论的那样，<code>match</code> 表达式是控制结构，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码。宏也将一个值和包含相关代码的模式进行比较；此种情况下，该值是 Rust 源代码传递给宏的常量，而模式则与源代码结构进行比较，同时每个模式的相关代码成为传递给宏的代码<!-- 这部分翻译自己不太满意-->。所有的这些都在编译时发生。</p>
<p>可以使用 <code>macro_rules!</code> 来定义宏。让我们通过查看 <code>vec!</code> 宏定义来探索如何使用 <code>macro_rules!</code> 结构。第八章讲述了如何使用 <code>vec!</code> 宏来生成一个给定值的 vector。例如，下面的宏用三个整数创建一个 vector `：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;u32&gt; = vec![1, 2, 3];
#}</code></pre></pre>
<p>也可以使用 <code>vec!</code> 宏来构造两个整数的 vector 或五个字符串切片的 vector 。但却无法使用函数做相同的事情，因为我们无法预先知道参数值的数量和类型。</p>
<p>在示例 D-1 中来看一个 <code>vec!</code> 稍微简化的定义。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
#}</code></pre></pre>
<p><span class="caption">示例 D-1: <code>vec!</code> 宏定义的一个简化版本</span></p>
<blockquote>
<p>注意：标准库中实际定义的 <code>vec!</code> 包括预分配适当量的内存。这部分为代码优化，为了让示例简化，此处并没有包含在内。</p>
</blockquote>
<p>无论何时导入定义了宏的包，<code>#[macro_export]</code> 注解说明宏应该是可用的。 如果没有 <code>#[macro_export]</code> 注解，即使凭借包使用 <code>#[macro_use]</code> 注解，该宏也不会导入进来，</p>
<p>接着使用 <code>macro_rules!</code> 进行了宏定义，且所定义的宏并<em>不带</em>感叹号。名字后跟大括号表示宏定义体，在该例中是 <code>vec</code> 。</p>
<p><code>vec!</code> 宏的结构和 <code>match</code> 表达式的结构类似。此处有一个单边模式 <code>( $( $x:expr ),* )</code> ，后跟 <code>=&gt;</code> 以及和模式相关的代码块。如果模式匹配，该相关代码块将被执行。假设这只是这个宏中的模式，且只有一个有效匹配，其他任何匹配都是错误的。更复杂的宏会有多个单边模式。<!-- 此处 arm, one arm 并未找到合适的翻译--></p>
<p>宏定义中有效模式语法和在第十八章提及的模式语法是不同的，因为宏模式所匹配的是 Rust 代码结构而不是值。回过头来检查下示例 D-1 中模式片段什么意思。对于全部的宏模式语法，请查阅<a href="https://github.com/rust-lang/book/blob/master/reference/macros.html">参考</a>。</p>
<p>首先，一对括号包含了全部模式。接下来是后跟一对括号的美元符号（ <code>$</code> ），其通过替代代码捕获了符合括号内模式的值。<code>$()</code> 内则是 <code>$x:expr</code> ，其匹配 Rust 的任意表达式或给定 <code>$x</code> 名字的表达式。</p>
<p><code>$()</code> 之后的逗号说明一个逗号分隔符可以有选择的出现代码之后，这段代码与在 <code>$()</code> 中所捕获的代码相匹配。紧随逗号之后的 <code>*</code> 说明该模式匹配零个或多个 <code>*</code> 之前的任何模式。</p>
<p>当以 <code>vec![1, 2, 3];</code> 调用宏时，<code>$x</code> 模式与三个表达式 <code>1</code>、<code>2</code> 和 <code>3</code> 进行了三次匹配。</p>
<p>现在让我们来看看这个出现在与此单边模式相关的代码块中的模式：在 <code>$()*</code> 部分中所生成的 <code>temp_vec.push()</code> 为在匹配到模式中的 <code>$()</code> 每一部分而生成。<code>$x</code> 由每个与之相匹配的表达式所替换。当以 <code>vec![1, 2, 3];</code> 调用该宏时，替换该宏调用所生成的代码会是下面这样：</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<p>我们已经定义了一个宏，其可以接收任意数量和类型的参数，同时可以生成能够创建包含指定元素的 vector 的代码。</p>
<p>鉴于大多数 Rust 程序员<em>使用</em>宏而不是<em>写</em>宏，此处不再深入探讨 <code>macro_rules!</code> 。请查阅在线文档或其他资源，如 <a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros”</a> 来更多地了解如何写宏。</p>
<a class="header" href="print.html#a自定义-derive-的过程式宏" id="a自定义-derive-的过程式宏"><h3>自定义 <code>derive</code> 的过程式宏</h3></a>
<p>第二种形式的宏叫做<em>过程式宏</em>（ <em>procedural macros</em> ），因为它们更像函数（一种过程类型）。过程式宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码。在书写部分附录时，只能定义过程式宏来使你在一个通过 <code>derive</code> 注解来指定 trait 名的类型上实现 trait 。</p>
<p>我们会创建一个 <code>hello_macro</code> 包，该包定义了一个关联到 <code>hello_macro</code> 函数并以 <code>HelloMacro</code> 为名的trait。并非让包的用户为其每一个类型实现<code>HelloMacro</code> trait，我们将会提供一个过程式宏以便用户可以使用 <code>#[derive(HelloMacro)]</code> 注解他们的类型来得到 <code>hello_macro</code> 函数的默认实现。该函数的默认实现会打印 <code>Hello, Macro! My name is TypeName!</code>，其中 <code>TypeName</code> 为定义了 trait 的类型名。换言之，我们会创建一个包，让使用该包的程序员能够写类似示例 D-2 中的代码。</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello_macro;
#[macro_use]
extern crate hello_macro_derive;

use hello_macro::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">示例 D-2: 包用户所写的能够使用过程式宏的代码</span></p>
<p>运行该代码将会打印 <code>Hello, Macro! My name is Pancakes!</code> 第一步是像下面这样新建一个库：</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<p>接下来，会定义 <code>HelloMacro</code> trait 以及其关联函数：</p>
<p><span class="filename">文件名: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait HelloMacro {
    fn hello_macro();
}
#}</code></pre></pre>
<p>现在有了一个包含函数的 trait 。此时，包用户可以实现该 trait 以达到其期望的功能，像这样：</p>
<pre><code class="language-rust ignore">extern crate hello_macro;

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>然而，他们需要为每一个他们想使用 <code>hello_macro</code> 的类型编写实现的代码块。我们希望为其节约这些工作。</p>
<p>另外，我们也无法为 <code>hello_macro</code> 函数提供一个能够打印实现了该 trait 的类型的名字的默认实现：Rust 没有反射的能力，因此其无法在运行时获取类型名。我们需要一个在运行时生成代码的宏。</p>
<p>下一步是定义过程式宏。在编写该附录时，过程式宏必须在包内。该限制后面可能被取消。构造包和包中宏的惯例如下：对于一个 <code>foo</code> 的包来说，一个自定义的派生过程式宏的包被称为 <code>foo_derive</code> 。在 <code>hello_macro</code> 项目中新建名为 <code>hello_macro_derive</code> 的包。</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<p>由于两个包紧密相关，因此在 <code>hello_macro</code> 包的目录下创建过程式宏的包。如果改变在 <code>hello_macro</code> 中定义的 trait ，同时也必须改变在 <code>hello_macro_derive</code> 中实现的过程式宏。这两个包需要分别发布，编程人员如果使用这些包，则需要同时添加这两个依赖并导入到代码中。我们也可以只用 <code>hello_macro</code> 包而将 <code>hello_macro_derive</code> 作为一个依赖，并重新导出过程式宏的代码。但我们组织项目的方式使编程人员使用 <code>hello_macro</code> 成为可能，即使他们无需 <code>derive</code> 的功能。</p>
<p>需要将 <code>hello_macro_derive</code> 声明为一个过程式宏的包。同时也需要 <code>syn</code> 和 <code>quote</code> 包中的功能，正如注释中所说，需要将其加到依赖中。为 <code>hello_macro_derive</code> 将下面的代码加入到 <em>Cargo.toml</em> 文件中。</p>
<p><span class="filename">文件名: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</code></pre>
<p>为定义一个过程式宏，请将示例 D-3 中的代码放在 <code>hello_macro_derive</code> 包的 <em>src/lib.rs</em> 文件里面。注意这段代码在我们添加 <code>impl_hello_macro</code> 函数的定义之前是无法编译的。</p>
<p><span class="filename">文件名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">extern crate proc_macro;
extern crate syn;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a string representation of the type definition
    let s = input.to_string();

    // Parse the string representation
    let ast = syn::parse_derive_input(&amp;s).unwrap();

    // Build the impl
    let gen = impl_hello_macro(&amp;ast);

    // Return the generated impl
    gen.parse().unwrap()
}
</code></pre>
<p><span class="caption">示例 D-3: 大多数过程式宏处理 Rust 代码的代码</span></p>
<p>注意在 D-3 中分离函数的方式，这将和你几乎所见到或创建的每一个过程式宏都一样，因为这让编写一个过程式宏更加方便。在 <code>impl_hello_macro</code> 被调用的地方所选择做的什么依赖于该过程式宏的目的而有所不同。</p>
<p>现在，我们已经介绍了三个包：<code>proc_macro</code> 、 <a href="https://crates.io/crates/syn"><code>syn</code></a> 和 <a href="https://crates.io/crates/quote"><code>quote</code></a> 。Rust 自带 <code>proc_macro</code>  ，因此无需将其加到 <em>Cargo.toml</em> 文件的依赖中。<code>proc_macro</code> 可以将 Rust 代码转换为相应的字符串。<code>syn</code> 则将字符串中的 Rust 代码解析成为一个可以操作的数据结构。<code>quote</code> 则将 <code>syn</code> 解析的数据结构反过来传入到 Rust 代码中。这些包让解析我们所要处理的有序 Rust 代码变得更简单：为 Rust 编写整个的解析器并不是一件简单的工作。</p>
<p>当用户在一个类型上指定 <code>#[derive(HelloMacro)]</code> 时，<code>hello_macro_derive</code>  函数将会被调用。
原因在于我们已经使用 <code>proc_macro_derive</code> 及其指定名称对 <code>hello_macro_derive</code> 函数进行了注解：<code>HelloMacro</code> ，其匹配到 trait 名，这是大多数过程式宏的方便之处。</p>
<p>该函数首先将来自 <code>TokenStream</code> 的 <code>输入</code> 转换为一个名为 <code>to_string</code> 的 <code>String</code> 类型。该 <code>String</code> 代表 派生 <code>HelloMacro</code> Rust 代码的字符串。在示例 D-2 的例子中，<code>s</code> 是 <code>String</code> 类型的 <code>struct Pancakes;</code> 值，这是因为我们加上了 <code>#[derive(HelloMacro)]</code> 注解。</p>
<blockquote>
<p>注意：编写本附录时，只可以将 <code>TokenStream</code> 转换为字符串，将来会提供更丰富的API。</p>
</blockquote>
<p>现在需要将 <code>String</code> 类型的 Rust 代码 解析为一个数据结构中，随后便可以与之交互并操作该数据结构。这正是 <code>syn</code> 所做的。<code>syn</code> 中的 <code>parse_derive_input</code> 函数以一个 <code>String</code> 作为参数并返回一个 表示解析出 Rust 代码的 <code>DeriveInput</code> 结构体。 下面的代码 展示了从字符串 <code>struct Pancakes;</code> 中解析出来的 <code>DeriveInput</code> 结构体的相关部分。</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident(
        &quot;Pancakes&quot;
    ),
    body: Struct(
        Unit
    )
}
</code></pre>
<p>该结构体的字段展示了我们解析的 Rust 代码是一个元组结构体，其 <code>ident</code> （ identifier，表示名字）为 <code>Pancakes</code> 。该结构体里面有更多字段描述了所有有序 Rust 代码，查阅 <a href="https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html"><code>syn</code>
documentation for <code>DeriveInput</code></a> 以获取更多信息。</p>
<p>此时，尚未定义 <code>impl_hello_macro</code> 函数，其用于构建所要包含在内的 Rust 新代码。但在定义之前，要注意 <code>hello_macro_derive</code> 函数的最后一部分使用了 <code>quote</code> 包中的 <code>parse</code> 函数，该函数将 <code>impl_hello_macro</code> 的输出返回给 <code>TokenStream</code> 。所返回的 <code>TokenStream</code> 会被加到我们的包用户所写的代码中，因此，当用户编译他们的包时，他们会获取到我们所提供的额外功能。</p>
<p>你也注意到，当调用 <code>parse_derive_input</code> 或 <code>parse</code> 失败时，我们调用 <code>unwrap</code> 来抛出异常。在过程式宏中，有必要错误上抛异常，因为 <code>proc_macro_derive</code> 函数必须返回 <code>TokenStream</code> 而不是 <code>Result</code> ，以此来符合过程式宏的 API 。我们已经选择用 <code>unwrap</code> 来简化了这个例子；在生产中的代码里，你应该通过 <code>panic!</code> 或 <code>expect</code> 来提供关于发生何种错误的更加明确的错误信息。</p>
<p>现在我们有了将注解的 Rust 代码从 <code>TokenStream</code> 转换为 <code>String</code> 和 <code>DeriveInput</code> 实例的代码，让我们来创建在注解类型上实现 <code>HelloMacro</code> trait 的代码。</p>
<p><span class="filename">文件名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {
    let name = &amp;ast.ident;
    quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    }
}
</code></pre>
<p>我们得到一个包含以 <code>ast.ident</code> 作为注解类型名字（标识符）的 <code>Ident</code> 结构体实例。示例 D-2 中的代码说明 <code>name</code> 会是 <code>Ident(&quot;Pancakes&quot;)</code> 。</p>
<p><code>quote!</code> 宏让我们编写我们想要返回的代码，并可以将其传入进 <code>quote::Tokens</code> 。这个宏也提供了一些非常酷的模板机制；我们可以写 <code>#name</code> ，然后 <code>quote!</code> 会以 名为 <code>name</code> 的变量值来替换它。你甚至可以做些与这个正则宏任务类似的重复事情。查阅 <a href="https://docs.rs/quote">the <code>quote</code> crate’s
docs</a> 来获取详尽的介绍。</p>
<p>我们期望我们的过程式宏能够为通过 <code>#name</code> 获取到的用户注解类型生成 <code>HelloMacro</code> trait 的实现。该 trait 的实现有一个函数 <code>hello_macro</code> ，其函数体包括了我们期望提供的功能：打印 <code>Hello, Macro! My name is</code> 和注解的类型名。</p>
<p>此处所使用的 <code>stringify!</code> 为 Rust 内置宏。其接收一个 Rust 表达式，如 <code>1 + 2</code> ， 然后在编译时将表达式转换为一个字符串常量，如 <code>&quot;1 + 2&quot;</code> 。这与 <code>format!</code> 或 <code>println!</code> 是不同的，它计算表达式并将结果转换为 <code>String</code> 。有一种可能的情况是，所输入的 <code>#name</code> 可能是一个需要打印的表达式，因此我们用 <code>stringify!</code> 。 <code>stringify!</code> 编译时也保留了一份将 <code>#name</code> 转换为字符串之后的内存分配。</p>
<p>此时，<code>cargo build</code> 应该都能成功编译 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 。我们将这些 crate 连接到示例 D-2 的代码中来看看过程式宏的行为。在 <em>projects</em> 目录下用 <code>cargo new pancakes</code> 命令新建一个二进制项目。需要将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 作为依赖加到 <code>pancakes</code> 包的 <em>Cargo.toml</em>  文件中去。如果你正将 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本发布到 <a href="https://crates.io/"><em>https://crates.io/</em></a> 上，其应为正规依赖；如果不是，则可以像下面这样将其指定为 <code>path</code> 依赖：</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>把示例 D-2 中的代码放在 <em>src/main.rs</em> ，然后执行 <code>cargo run</code> ： 其应该打印 <code>Hello, Macro! My name is Pancakes!</code> 。从过程式宏中实现的 <code>HelloMacro</code> trait 被包括在内，但并不包含 <code>pancakes</code> 的包，需要实现它。<code>#[derive(HelloMacro)]</code> 添加了该 trait 的实现。<!-- 中间句子翻译不是太好 --></p>
<a class="header" href="print.html#a宏的前景" id="a宏的前景"><h3>宏的前景</h3></a>
<p>在将来，Rust 仍会扩展声明式宏和过程式宏。Rust会通过 <code>macro</code> 使用一个更好的声明式宏系统，以及为较之 <code>derive</code> 的更强大的任务增加更多的过程式宏类型。在本书出版时，这些系统仍然在开发中，请查阅 Rust 在线文档以获取最新信息。</p>
<a class="header" href="print.html#a字符串格式化" id="a字符串格式化"><h1>字符串格式化</h1></a>
<p>说起格式化字符串，Rust采取了一种类似Python里面format的用法，其核心组成是5个宏和2个trait：<code>format!</code>、<code>format_arg!</code>、<code>print!</code>、<code>println!</code>、<code>write!</code>; <code>Debug</code>、<code>Display</code>。</p>
<ul>
<li>宏：
<ol>
<li><code>format!</code></li>
<li><code>format_arg!</code></li>
<li><code>print!</code></li>
<li><code>println!</code></li>
<li><code>write!</code></li>
</ol>
</li>
<li>Trait：
<ol>
<li><code>Debug</code></li>
<li><code>Display</code></li>
</ol>
</li>
</ul>
<p>相信你们在写Rust版本的Hello World的时候用到了<code>print!</code>或者<code>println!</code>这两个宏，但是其实最核心的是<code>format!</code>，前两个宏只不过将<code>format!</code>的结果输出到了console而已。</p>
<p>那么，我们来探究一下<code>format!</code>这个神奇的宏吧。</p>
<p>在这里呢，列举<code>format!</code>的定义是没卵用的，因为太复杂。我只为大家介绍几种典型用法。学会了基本上就能覆盖你平时80%的需求。</p>
<p>首先我们来分析一下format的一个典型调用</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = format!(&quot;{1} 是个有着{0:&gt;0width$}KG重，{height:?}cm高的大胖子! [{0}, {1}, {2}, {3}]&quot;,
                81, &quot;wayslog&quot;, width=4, height=178);
    //# 参数位置说明
    //{0} 表示索引为0的参数，例如：这里是 81
    //{1} 表示索引为1的参数，例如：这里是 &quot;wayslog&quot;
    //{2} 表示索引为2的参数，例如：这里是 4
    //{3} 表示索引为2的参数，例如：这里是 178
    //# key-value参数表达方式
    // width=4
    // height=178
    println!(&quot;{}&quot;, s);
    //# output
    // wayslog 是个有着0081KG重，178cm高的大胖子! [81, wayslog, 4, 178]
}
</code></pre></pre>
<p>我们可以看到，<code>format!</code>宏调用的时候参数可以是任意类型，而且是可以position(位置索引)参数和key-value参数混合使用的。但是要注意的一点是，key-value的值只能出现在position值之后并且不占position。
例如，例子里你用<code>$</code>引用到的绝对不是<code>width</code>，而是会报错。
这里面关于参数稍微有一个规则就是，参数类型必须要实现 <code>std::fmt</code> mod 下的某些trait。比如我们看到原生类型大部分都实现了<code>Display</code>和<code>Debug</code>这两个宏，其中整数类型还会额外实现一个<code>Binary</code>，等等。</p>
<p>当然了，我们可以通过 <code>{:type}</code>的方式去调用这些参数。</p>
<p>比如这样：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
format!(&quot;{:b}&quot;, 2);
// 调用 `Binary` trait
// Get : 10
format!(&quot;{:?}&quot;, &quot;Hello&quot;);
// 调用 `Debug`
// Get : &quot;Hello&quot;
#}</code></pre></pre>
<p>另外请记住：type这个地方为空的话默认调用的是<code>Display</code>这个trait。</p>
<p>关于<code>:</code>号后面的东西其实还有更多式子，我们从上面的<code>{0:&gt;0width$}</code>来分析它。</p>
<p>首先<code>&gt;</code>是一个语义，它表示的是生成的字符串向右对齐，于是我们得到了 <code>0081</code>这个值。与之相对的还有<code>&lt;</code>(向左对齐)和<code>^</code>(居中)。</p>
<p>再接下来<code>0</code>是一种特殊的填充语法，他表示用0补齐数字的空位，要注意的是，当0作用于负数的时候，比如上面例子中wayslog的体重是-81，那么你最终将得到<code>-0081</code>;当然了，什么都不写表示用空格填充啦;在这一位上，还会出现<code>+</code>、<code>#</code>的语法，使用比较诡异，一般情况下用不上。</p>
<p>最后是一个组合式子<code>width$</code>，这里呢，大家很快就能认出来是表示后面key-value值对中的<code>width=4</code>。你们没猜错，这个值表示格式化完成后字符串的长度。它可以是一个精确的长度数值，也可以是一个以<code>$</code>为结尾的字符串，<code>$</code>前面的部分可以写一个key或者一个postion。</p>
<p>最后，你需要额外记住的是，在width和type之间会有一个叫精度的区域（可以省略不写如例子），他们的表示通常是以<code>.</code>开始的，比如<code>.4</code>表示小数点后四位精度。最让人遭心的是，你仍然可以在这个位置引用参数，只需要和上面width一样，用<code>.N$</code>来表示一个position的参数，但是就是不能引用key-value类型的。这一位有一个特殊用法，那就是<code>.*</code>，它不表示一个值，而是表示两个值！第一个值表示精确的位数，第二个值表示这个值本身。这是一种很尴尬的用法，而且极度容易匹配到其他参数。因此，我建议在各位能力或者时间不欠缺的时候尽量把格式化表达式用标准的形式写的清楚明白。尤其在面对一个复杂的格式化字符串的时候。</p>
<p>好了好了，说了这么多，估计你也头昏脑涨的了吧，下面来跟我写一下format宏的完整用法。仔细体会并提炼每一个词的意思和位置。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
format_string := &lt;text&gt; [ format &lt;text&gt; ] *
format := '{' [ argument ] [ ':' format_spec ] '}'
argument := integer | identifier

format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]
fill := character
align := '&lt;' | '^' | '&gt;'
sign := '+' | '-'
width := count
precision := count | '*'
type := identifier | ''
count := parameter | integer
parameter := integer '$'
#}</code></pre></pre>
<a class="header" href="print.html#a面向对象编程" id="a面向对象编程"><h1>面向对象编程</h1></a>
<a class="header" href="print.html#rust-面向对象语言特征" id="rust-面向对象语言特征"><h1>Rust 面向对象语言特征</h1></a>
<a class="header" href="print.html#trait-和-trait对象" id="trait-和-trait对象"><h1>trait 和 trait对象</h1></a>
<p><strong>trait</strong>（特征）类似于其他语言中的<strong>interface</strong>或者<strong>protocol</strong>，指定一个实际类型必须满足的功能集合。
与interface不同的地方在于，interface会隐藏具体实现类型，而trait不会。
在Rust中，隐藏实现类型可以由<code>generic</code>(泛型)配合<code>trait</code>作出。</p>
<p><strong>Rust</strong>中的trait：</p>
<ul>
<li><a href="trait.md">trait关键字</a></li>
<li><a href="trait-object.md">trait对象</a></li>
</ul>
<a class="header" href="print.html#trait-关键字" id="trait-关键字"><h1>trait 关键字</h1></a>
<a class="header" href="print.html#trait-与具体类型" id="trait-与具体类型"><h2>trait 与具体类型</h2></a>
<p>使用<code>trait</code>定义一个特征：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}
#}</code></pre></pre>
<p><code>trait</code> 中的函数可以有两种方式：（1）没有函数体；（2）有函数体，被称为默认实现。</p>
<p>一般情况， <code>trait</code> 中的函数可以没有函数体，实现代码交给具体实现它的类型去补充，如：</p>
<pre><pre class="playpen"><code class="language-rust">
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };
    println!(&quot;circle c has an area of {}&quot;, c.area());
}
</code></pre></pre>
<p><strong>注</strong>: <code>&amp;self</code>表示的是<code>area</code>这个函数会将调用者的借代引用作为参数。</p>
<p>这个程序会输出：</p>
<pre><code class="language-shell">circle c has an area of 3.141592653589793
</code></pre>
<a class="header" href="print.html#trait与泛型" id="trait与泛型"><h2>trait与泛型</h2></a>
<blockquote>
<p>我们了解了Rust中trait的定义和使用，接下来我们介绍一下它的使用场景，从中我们可以窥探出接口这特性带来的惊喜</p>
</blockquote>
<p>我们知道泛型可以指任意类型，但有时这不是我们想要的，需要给它一些约束。</p>
<a class="header" href="print.html#a泛型的trait约束" id="a泛型的trait约束"><h3>泛型的trait约束</h3></a>
<pre><code class="language-rust ignore">use std::fmt::Debug;
fn foo&lt;T: Debug&gt;(s: T) {
    println!(&quot;{:?}&quot;, s);
}
</code></pre>
<p><code>Debug</code> 是<strong>Rust</strong>内置的一个 <code>trait</code> ，为&quot;{:?}&quot;实现打印内容，函数 <code>foo</code> 接受一个泛型作为参数，并且约定其需要实现<code>Debug</code></p>
<a class="header" href="print.html#a多trait约束" id="a多trait约束"><h3>多trait约束</h3></a>
<p>可以使用多个trait对泛型进行约束：</p>
<pre><code class="language-rust ignore">use std::fmt::Debug;
fn foo&lt;T: Debug + Clone&gt;(s: T) {
    s.clone();
    println!(&quot;{:?}&quot;, s);
}
</code></pre>
<blockquote>
<p>说明：<code>&lt;T: Debug + Clone&gt;</code>中<code>Debug</code>和<code>Clone</code>使用<code>+</code>连接，表示泛型<code>T</code>需要同时实现这两个trait。</p>
</blockquote>
<a class="header" href="print.html#where关键字" id="where关键字"><h3>where关键字</h3></a>
<p>约束的trait增加后，<strong>代码看起来就变得诡异了</strong>，这时候，需要使用 <code>where</code> 从句：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

// where 从句的写法
fn foo&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

// 或者使用下面这种写法
fn foo&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
#}</code></pre></pre>
<a class="header" href="print.html#trait与内置类型" id="trait与内置类型"><h2>trait与内置类型</h2></a>
<p>内置类型如：<code>i32</code>, <code>i64</code> 等也可以添加trait实现，为其定制一些功能：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for i32 {
    fn area(&amp;self) -&gt; f64 {
        *self as f64
    }
}

5.area();
#}</code></pre></pre>
<p>这样的做法是有限制的。Rust 有一个<code>“孤儿规则”</code>：当你为某类型实现某 trait 的时候，必须要求类型或者 trait 至少有一个是在当前 <code>crate</code> 中定义的。你不能为第三方的类型实现第三方的 <code>trait</code>。</p>
<p>在调用 <code>trait</code> 中定义的方法的时候，一定要记得让这个 trait 可被访问。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut f = std::fs::File::open(&quot;foo.txt&quot;).ok().expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;; //  buf: &amp;[u8; 8]
let result = f.write(buf);
result.unwrap();
#}</code></pre></pre>
<p>这里是错误：</p>
<pre><code class="language-shell">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>
<p>我们需要先use这个Write trait：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::Write; // 引用后，你才能使用write方法

let mut f = std::fs::File::open(&quot;foo.txt&quot;).expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;;
let result = f.write(buf);
# result.unwrap(); // ignore the error
#}</code></pre></pre>
<p>这样就能无错误地编译了。</p>
<a class="header" href="print.html#trait-支持泛型定义" id="trait-支持泛型定义"><h2>trait 支持泛型定义</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

trait Seq&lt;T&gt; {
    fn dummy(&amp;self, _: T) where T: Debug;
}

impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
    /* */
    fn dummy(&amp;self, v: T) where T: Debug{
        println!(&quot;call dummy ... {:?}&quot;, v);
    }
}

let m = Vec::&lt;bool&gt;::new() ;
println!(&quot;{:?}&quot;, m);
m.dummy(true);

#}</code></pre></pre>
<p><code>trait Seq&lt;T&gt;</code> 是支持泛型的<code>trait</code>定义</p>
<a class="header" href="print.html#trait的默认方法" id="trait的默认方法"><h2>trait的默认方法</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}
#}</code></pre></pre>
<p><code>is_invalid</code>是默认方法，<code>Foo</code>的实现者并不要求实现它，如果选择实现它，会覆盖掉它的默认行为。</p>
<a class="header" href="print.html#trait的继承" id="trait的继承"><h2>trait的继承</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait IControler {
    fn build(&amp;self) -&gt; bool;
    fn scale(&amp;self, zoom: f32);
}

trait IDisplay {
    fn draw(&amp;self);
}

trait IToolBar : IControler {
    fn switch(&amp;self);
}
#}</code></pre></pre>
<p><code>trait</code> 支持继承，例如：上面的代码说明，<code>IToolBar</code>的实现者也要同时实现<code>IControler</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct WinToolBar;

impl IControler for WinToolBar {
    fn build(&amp;self) -&gt; bool {
        println!(&quot;call IControler build ... &quot;);
        false
    }

    fn scale(&amp;self, zoom: f32) {
        println!(&quot;call IControler scale ... &quot;);
    }
}

impl IToolBar for WinToolBar {
    fn switch(&amp;self) {
        println!(&quot;call IToolBar switch ... &quot;);
    }
}

let bar = WinToolBar{};
bar.build();
bar.scale(0.5f32);
bar.switch();

#}</code></pre></pre>
<p><strong>输出结果:</strong></p>
<pre><code class="language-shell">call IControler build ...
call IControler scale ...
call IToolBar switch ...
</code></pre>
<p><code>trait</code> 也可以实现多重继承，如下面的方式：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait IToolBar : IControler +  IDisplay{
    fn switch(&amp;self);
}
#}</code></pre></pre>
<p>上面的代码说明，<code>IToolBar</code>的实现者也要同时实现<code>IControler</code> 和 <code>IDisplay</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct WinToolBar;

impl IControler for WinToolBar {
    fn build(&amp;self) -&gt; bool {
        println!(&quot;call IControler build ... &quot;);
        false
    }

    fn scale(&amp;self, zoom: f32) {
        println!(&quot;call IControler scale ... &quot;);
    }
}

impl IToolBar for WinToolBar {
    fn switch(&amp;self) {
        println!(&quot;call IToolBar switch ... &quot;);
    }
}

impl IDisplay for WinToolBar {
    fn draw(&amp;self) {
        println!(&quot;call IDisplay draw ... &quot;);
    }
}

let bar = WinToolBar{};
bar.build();
bar.scale(0.5f32);
bar.switch();
bar.draw();

#}</code></pre></pre>
<p><strong>输出结果:</strong></p>
<pre><code class="language-shell">call IControler build ...
call IControler scale ...
call IToolBar switch ...
call IDisplay draw ...
</code></pre>
<p><code>trait</code>中，比较容易出现问题的是实现的多个trait存在相同名称的方法，这使得实现者调用该名称方法，出现歧义，编译是不允许通过的。那么，如何解决这样的问题呢？ 这就要用到<code>通用函数调用方法</code>， 参照下面的代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait IToolBar : IControler +  IDisplay{
    fn build(&amp;self) -&gt; bool {
        println!(&quot;call IToolBar build ... &quot;);
        false
    }
    fn switch(&amp;self);
}

struct WinToolBar;

impl IControler for WinToolBar {
    fn build(&amp;self) -&gt; bool {
        println!(&quot;call IControler build ... &quot;);
        false
    }

    fn scale(&amp;self, zoom: f32) {
        println!(&quot;call IControler scale ... &quot;);
    }
}

impl IToolBar for WinToolBar {
    fn switch(&amp;self) {
        println!(&quot;call IToolBar switch ... &quot;);
    }
}

impl IDisplay for WinToolBar {
    fn draw(&amp;self) {
        println!(&quot;call IDisplay draw ... &quot;);
    }
}

let bar = WinToolBar{};
/// 由于IControler中定义了build函数，IToolBar 也定义了build函数，
/// 那么执行 bar.build() 就会得到以下错误
///       |             bar.build();
///       |                 ^^^^^ multiple `build` found
/// 因此，需要完全限定语法，消除歧义, 例如：
/// IToolBar::build(&amp;bar);

IToolBar::build(&amp;bar);
IControler::build(&amp;bar);

bar.scale(0.5f32);
bar.switch();
bar.draw();
#}</code></pre></pre>
<p><strong>注意</strong>：
<code>IToolBar::build(&amp;bar)</code> 和 <code>IControler::build(&amp;bar)</code> 的调用方法，
这部分属于 <code>method syntax ()</code> 中的内容，原型如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
f(&amp;b)
#}</code></pre></pre>
<p>当我们用 <code>method syntax ()</code> 调用一个方法比如 b.f()，如果 f() 含有 &amp;self，Rust 会自动 borrow b。在本例这种情况下，我们需要传递一个具体的 &amp;b。</p>
<a class="header" href="print.html#derive属性" id="derive属性"><h2>derive属性</h2></a>
<p><strong>Rust</strong>提供了一个属性<code>derive</code>来自动实现一些trait，这样可以避免重复繁琐地实现他们，能被<code>derive</code>使用的trait包括：<code>Clone</code>, <code>Copy</code>, <code>Debug</code>, <code>Default</code>, <code>Eq</code>, <code>Hash</code>, <code>Ord</code>, <code>PartialEq</code>, <code>PartialOrd</code></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Foo;

fn main() {
    println!(&quot;{:?}&quot;, Foo);
}
</code></pre></pre>
<a class="header" href="print.html#impl-trait" id="impl-trait"><h2>impl Trait</h2></a>
<p>在版本1.26 开始，Rust提供了<code>impl Trait</code>的写法，作为和Scala 对等的<code>既存型别(Existential Type)</code>的写法。</p>
<p>在下面这个写法中，<code>fn foo()</code>将返回一个实现了<code>Trait</code>的trait。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//before
fn foo() -&gt; Box&lt;Trait&gt; {
    // ...
}

//after
fn foo() -&gt; impl Trait {
    // ...
}
#}</code></pre></pre>
<p>相较于1.25 版本以前的写法，新的写法会在很多场合中更有利于开发和执行效率。</p>
<a class="header" href="print.html#impl-trait-的普遍用例" id="impl-trait-的普遍用例"><h3>impl Trait 的普遍用例</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {
    fn method(&amp;self);
}

impl Trait for i32 {
    // implementation goes here
}

impl Trait for f32 {
    // implementation goes here
}
#}</code></pre></pre>
<p>利用Box 会意味：即便回传的内容是固定的，但也会使用到动态内存分配。利用<code>impl Trait</code> 的写法可以避免便用Box。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//before
fn foo() -&gt; Box&lt;Trait&gt; {
    Box::new(5) as Box&lt;Trait&gt;
}

//after
fn foo() -&gt; impl Trait {
    5
}
#}</code></pre></pre>
<a class="header" href="print.html#a其他受益的用例" id="a其他受益的用例"><h3>其他受益的用例</h3></a>
<p>闭包:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// before
fn foo() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}

// after
fn foo() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
#}</code></pre></pre>
<p>传参：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// before
fn foo&lt;T: Trait&gt;(x: T) {

// after
fn foo(x: impl Trait) {
#}</code></pre></pre>
<a class="header" href="print.html#trait对象-trait-object" id="trait对象-trait-object"><h1>trait对象 （trait object）</h1></a>
<p>trait对象在<strong>Rust</strong>中是指，使用 <strong>指针</strong> 封装的 trait，比如 <code>&amp;SomeTrait</code> 和 <code>Box&lt;SomeTrait&gt;</code>。</p>
<p>如果，你是C或者C++编程爱好者，对于指针，特别是C++概念中的指针，基类指针应该更好理解。</p>
<pre><pre class="playpen"><code class="language-rust">trait Foo { fn method(&amp;self) -&gt; String; }

impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = &quot;Hello&quot;.to_string();
    do_something(&amp;x);
    let y = 8u8;
    do_something(&amp;y);
}
</code></pre></pre>
<p><code>x: &amp;Foo</code>其中<code>x</code>是一个trait对象，这里用指针是因为<code>x</code>可以是任意实现<code>Foo</code>的类型实例，内存大小并不确定，但指针的大小是固定的。</p>
<a class="header" href="print.html#trait对象的实现" id="trait对象的实现"><h2>trait对象的实现</h2></a>
<p><code>&amp;SomeTrait</code> 类型，和普通的指针类型<code>&amp;i32</code>不同。它不仅包括指向真实对象的指针，还包括一个指向虚函数表的指针。</p>
<p>它的内部实现定义，在<code>std::raw</code>模块中：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(C)]
#[derive(Copy, Clone)]
#[allow(missing_debug_implementations)]
pub struct TraitObject {
    pub data: *mut (),     // 指向实际类型实例的指针
    pub vtable: *mut (),   // 指向实际类型对于该trait的实现的虚函数表
}
#}</code></pre></pre>
<p>其中：</p>
<ul>
<li><code>data</code> 是一个指向实际类型实例的指针；</li>
<li><code>vtable</code> 是一个指向实际类型对于该trait的实现的虚函数表：</li>
</ul>
<p>技术解释：</p>
<ul>
<li>
<p><code>*mut()</code> 中，我们关注到 <code>*</code>, 这部分，涉及<strong>Rust</strong>语言中的 <code>原始指针</code> 。*const T 和 *mut T 在 Rust 中被称为“原始指针”。
这里两种指针，<code>*const T</code> 只读指针，<code>*mut T</code> 可变指针。只读指针，就是指向的数据不可修改；可变指针，就是指向的数据可以修改；</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
  let x = 5;
  let raw = &amp;x as *const i32;

  println!(&quot;{:?}&quot;, raw); // 0x50ebf6f780

  let mut y = 10;
  let raw_mut = &amp;mut y as *mut i32;

  println!(&quot;{:?}&quot;, raw_mut); // 0x50ebf6f784
  unsafe {
      // *raw_mut 称为 解引用
      println!(&quot;raw points at {:?} is {}&quot;, raw_mut, *raw_mut); //raw points at 0x50ebf6f784 is 10
      *raw_mut = 50 + *raw_mut;
      println!(&quot;raw points at {:?} is {}&quot;, raw_mut, *raw_mut); //raw points at 0x50ebf6f784 is 60
  }
#}</code></pre></pre>
</li>
</ul>
<hr />
<p><code>Foo</code>的虚函数表类型：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -&gt; String,
}
#}</code></pre></pre>
<p>之前的代码可以解读为：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// u8:
// 这个函数只会被指向u8的指针调用
fn call_method_on_u8(x: *const ()) -&gt; String {
    let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    size: 1,
    align: 1,

    method: call_method_on_u8 as fn(*const ()) -&gt; String,
};


// String:
// 这个函数只会被指向String的指针调用
fn call_method_on_String(x: *const ()) -&gt; String {
    let string: &amp;String = unsafe { &amp;*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -&gt; String,
};


let a: String = &quot;foo&quot;.to_string();
let x: u8 = 1;

// let b: &amp;Foo = &amp;a;
let b = TraitObject {
    // data存储实际值的引用
    data: &amp;a,
    // vtable存储实际类型实现Foo的方法
    vtable: &amp;Foo_for_String_vtable
};

// let y: &amp;Foo = x;
let y = TraitObject {
    data: &amp;x,
    vtable: &amp;Foo_for_u8_vtable
};

// b.method();
(b.vtable.method)(b.data);

// y.method();
(y.vtable.method)(y.data);
#}</code></pre></pre>
<a class="header" href="print.html#a对象安全" id="a对象安全"><h2>对象安全</h2></a>
<p>并不是所有的trait都能作为trait对象使用的，比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
let o = &amp;v as &amp;Clone;
#}</code></pre></pre>
<p>会有一个错误：</p>
<pre><code class="language-text">error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &amp;v as &amp;Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &amp;v as &amp;Clone;
        ^~
</code></pre>
<p>让我来分析一下错误的原因：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Clone: Sized {
    fn clone(&amp;self) -&gt; Self;

    fn clone_from(&amp;mut self, source: &amp;Self) { ... }
}
#}</code></pre></pre>
<p>虽然<code>Clone</code>本身继承了<code>Sized</code>这个trait，但是它的方法<code>fn clone(&amp;self) -&gt; Self</code>和<code>fn clone_from(&amp;mut self, source: &amp;Self) { ... }</code>含有<code>Self</code>类型，而在使用trait对象方法的时候<strong>Rust</strong>是动态派发的，我们根本不知道这个trait对象的实际类型，它可以是任何一个实现了该trait的类型的值，所以<code>Self</code>在这里的大小不是<code>Self: Sized</code>的，这样的情况在<strong>Rust</strong>中被称为<code>object-unsafe</code>或者<code>not object-safe</code>，这样的trait是不能成为trait对象的。</p>
<p>总结：</p>
<p>如果一个<code>trait</code>方法是<code>object safe</code>的，它需要满足：</p>
<ul>
<li>方法有<code>Self: Sized</code>约束， 或者</li>
<li>同时满足以下所有条件：
<ul>
<li>没有泛型参数</li>
<li>不是静态函数</li>
<li>除了<code>self</code>之外的其它参数和返回值不能使用<code>Self</code>类型</li>
</ul>
</li>
</ul>
<p>如果一个<code>trait</code>是<code>object-safe</code>的，它需要满足：</p>
<ul>
<li>所有的方法都是<code>object-safe</code>的，并且</li>
<li>trait 不要求 <code>Self: Sized</code> 约束</li>
</ul>
<p>参考<a href="http://stackoverflow.com/questions/29985153/trait-object-is-not-object-safe-error">stackoverflow</a>
<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">object safe rfc</a></p>
<a class="header" href="print.html#a设计模式" id="a设计模式"><h1>设计模式</h1></a>
<a class="header" href="print.html#a泛型" id="a泛型"><h1>泛型</h1></a>
<p>我们在编程中，通常有这样的需求，为多种类型的数据编写一个功能相同的函数，如两个数的加法，希望这个函数既支持i8、i16、 i32 ....float64等等，甚至自定义类型，在不支持泛型的编程语言中，我们通常要为每一种类型都编写一个函数，而且通常情况下函数名还必须不同，例如：</p>
<pre><pre class="playpen"><code class="language-rust">fn add_i8(a:i8, b:i8) -&gt; i8 {
    a + b
}
fn add_i16(a:i16, b:i16) -&gt; i16 {
    a + b
}
fn add_f64(a:f64, b:f64) -&gt; f64 {
    a + b
}

// 各种其他add函数
// ...

fn main() {
    println!(&quot;add i8: {}&quot;, add_i8(2i8, 3i8));
    println!(&quot;add i16: {}&quot;, add_i16(20i16, 30i16));
    println!(&quot;add f64: {}&quot;, add_f64(1.23, 1.23));
}
</code></pre></pre>
<p>如果有很多地方都需要支持多种类型，那么代码量就会非常大，而且代码也会非常臃肿，编程就真的变成了苦逼搬砖的工作，枯燥而乏味:D。</p>
<p>学过C++的人也许很容易理解泛型，但本教程面向的是Rust初学者，所以不会拿C++的泛型、多态和Rust进行对比，以免增加学习的复杂度和不必要的困扰，从而让Rust初学者更容易理解和接受Rust泛型。</p>
<a class="header" href="print.html#a概念" id="a概念"><h2>概念</h2></a>
<p>泛型程序设计是程序设计语言的一种风格或范式。允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时（instantiate）作为参数指明这些类型（在Rust中，有的时候类型还可以被编译器推导出来）。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。Ada, Delphi, Eiffel, Java, C#, F#, Swift, and Visual Basic .NET称之为泛型（generics）；ML, Scala and Haskell称之为参数多态（parametric polymorphism）；C++与D语言常称之为模板。具有广泛影响的1994年版的《Design Patterns》一书称之为参数化类型（parameterized type）。</p>
<blockquote>
<p>提示：
以上概念摘自<a href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B">《维基百科-泛型》</a></p>
</blockquote>
<p>在编程的时候，我们经常利用多态。通俗的讲，多态就是好比坦克的炮管，既可以发射普通弹药，也可以发射制导炮弹（导弹），也可以发射贫铀穿甲弹，甚至发射子母弹，大家都不想为每一种炮弹都在坦克上分别安装一个专用炮管，即使生产商愿意，炮手也不愿意，累死人啊。所以在编程开发中，我们也需要这样“通用的炮管”，这个“通用的炮管”就是多态。</p>
<p>需要知道的是，<code>泛型就是一种多态</code>。</p>
<p>泛型主要目的是为程序员提供了编程的便利，减少代码的臃肿,同时极大丰富了语言本身的表达能力, 为程序员提供了一个合适的炮管。想想，一个函数，代替了几十个，甚至数百个函数，是一件多么让人兴奋的事情。
泛型，可以理解为具有某些功能共性的集合类型，如i8、i16、u8、f32等都可以支持add，甚至两个struct Point类型也可以add形成一个新的Point。</p>
<p>先让我们来看看标准库中常见的泛型<code>Option&lt;T&gt;</code>，它的原型定义：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>T就是泛型参数，这里的T可以换成A-Z任何你自己喜欢的字母。不过习惯上，我们用T表示Type，用E表示Error。T在具体使用的时候才会被实例化：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = Some(100.111f32);
#}</code></pre></pre>
<p>编译器会自行推导出<code>a</code>为<code>Option&lt;f32&gt;</code>类型，也就是说<code>Option</code>中的<code>T</code>在这里是<code>f32</code>类型。</p>
<p>当然，你也可以显式声明a的类型，但必须保证和右值的类型一样，不然编译器会报&quot;mismatched types&quot;类型不匹配错误。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a:Option&lt;f32&gt; = Some(100.111);  //编译自动推导右值中的100.111为f32类型。
let b:Option&lt;f32&gt; = Some(100.111f32);
let c:Option&lt;f64&gt; = Some(100.111);
let d:Option&lt;f64&gt; = Some(100.111f64);
#}</code></pre></pre>
<a class="header" href="print.html#a泛型函数" id="a泛型函数"><h3>泛型函数</h3></a>
<p>至此，我们已经了解到泛型的定义和简单的使用了。
现在让我们用函数重写add操作：</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

fn add&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) -&gt; T {
   a + b
}

fn main() {
    println!(&quot;{}&quot;, add(100i32, 1i32));
    println!(&quot;{}&quot;, add(100.11f32, 100.22f32));
}
</code></pre></pre>
<p><strong>输出:</strong></p>
<pre><code class="language-shell">101
200.33
</code></pre>
<p><code>add&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) -&gt; T</code>就是我们泛型函数，返回值也是泛型T，Add&lt;&gt;中的含义可以暂时忽略，大体意思就是只要参数类型实现了<code>Add trait</code>，就可以被传入到我们的add函数，因为我们的add函数中有相加+操作，所以要求传进来的参数类型必须是可相加的，也就是必须实现了<code>Add trait</code>（具体参考<code>std::ops::Add</code>）。</p>
<a class="header" href="print.html#a自定义类型" id="a自定义类型"><h3>自定义类型</h3></a>
<p>上面的例子，add的都是语言内置的基础数据类型，当然我们也可以为自己自定义的数据结构类型实现add操作。</p>
<pre><pre class="playpen"><code class="language-rust">
use std::ops::Add;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// 为Point实现Add trait
impl Add for Point {
    type Output = Point; //执行返回值类型为Point
    fn add(self, p: Point) -&gt; Point {
        Point{
            x: self.x + p.x,
            y: self.y + p.y,
        }
    }
}

fn add&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) -&gt; T {
   a + b
}

fn main() {
    println!(&quot;{}&quot;, add(100i32, 1i32));
    println!(&quot;{}&quot;, add(100.11f32, 100.22f32));

    let p1 = Point{x: 1, y: 1};
    let p2 = Point{x: 2, y: 2};
    println!(&quot;{:?}&quot;, add(p1, p2));
}

</code></pre></pre>
<p><strong>输出:</strong></p>
<pre><code class="language-shell">
101
200.33
Point { x: 3, y: 3 }

</code></pre>
<p>上面的例子稍微更复杂些了，只是我们增加了自定义的类型，然后让add函数依然可以在上面工作。如果对<code>trait</code>不熟悉，请查阅<code>trait</code>相关章节。</p>
<p>大家可能会疑问，那我们是否可以让Point也变成泛型的，这样Point的x和y也能够支持float类型或者其他类型，答案当然是可以的。</p>
<pre><pre class="playpen"><code class="language-rust">
use std::ops::Add;

#[derive(Debug)]
struct Point&lt;T: Add&lt;T, Output = T&gt;&gt; { //限制类型T必须实现了Add trait，否则无法进行+操作。
    x: T,
    y: T,
}

impl&lt;T: Add&lt;T, Output = T&gt;&gt; Add for Point&lt;T&gt; {
    type Output = Point&lt;T&gt;;

    fn add(self, p: Point&lt;T&gt;) -&gt; Point&lt;T&gt; {
        Point{
            x: self.x + p.x,
            y: self.y + p.y,
        }
    }
}

fn add&lt;T: Add&lt;T, Output=T&gt;&gt;(a:T, b:T) -&gt; T {
    a + b
}

fn main() {
    let p1 = Point{x: 1.1f32, y: 1.1f32};
    let p2 = Point{x: 2.1f32, y: 2.1f32};
    println!(&quot;{:?}&quot;, add(p1, p2));

    let p3 = Point{x: 1i32, y: 1i32};
    let p4 = Point{x: 2i32, y: 2i32};
    println!(&quot;{:?}&quot;, add(p3, p4));
}

</code></pre></pre>
<p><strong>输出：</strong></p>
<pre><code class="language-shell">
Point { x: 3.2, y: 3.2 }
Point { x: 3, y: 3 }

</code></pre>
<p>上面的列子更复杂了些，我们不仅让自定义的Point类型支持了add操作，同时我们也为Point做了泛型化。</p>
<p>当<code>let p1 = Point{x: 1.1f32, y: 1.1f32};</code>时，Point的T推导为f32类型，这样Point的x和y属性均成了f32类型。因为p1.x+p2.x，所以T类型必须支持<code>Add trait</code>。</p>
<a class="header" href="print.html#a总结-3" id="a总结-3"><h3>总结</h3></a>
<p>上面区区几十行的代码，却实现了非泛型语言百行甚至千行代码才能达到的效果，足见<code>泛型</code>的强大。</p>
<a class="header" href="print.html#a习题-1" id="a习题-1"><h3>习题</h3></a>
<a class="header" href="print.html#a1-generic-lines-iterator" id="a1-generic-lines-iterator"><h4>1. Generic lines iterator</h4></a>
<a class="header" href="print.html#a问题描述" id="a问题描述"><h5>问题描述</h5></a>
<p>有时候我们可能做些文本分析工作, 数据可能来源于外部或者程序内置的文本.</p>
<p>请实现一个 <code>parse</code> 函数, 只接收一个 lines iterator 为参数, 并输出每行.</p>
<p>要求既能输出内置的文本, 也能输出文件内容.</p>
<a class="header" href="print.html#a调用方式及输出参考" id="a调用方式及输出参考"><h5>调用方式及输出参考</h5></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
let lines = &quot;some\nlong\ntext&quot;.lines()
parse(do_something_or_nothing(lines))

#}</code></pre></pre>
<p>结果输出：</p>
<pre><code class="language-shell">
some
long
text

</code></pre>
<p>解释部分源码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
use std::fs:File;
use std::io::prelude::*;
use std::io::BufReader;
let lines = BufReader::new(File::open(&quot;/etc/hosts&quot;).unwrap()).lines()
parse(do_some_other_thing_or_nothing(lines))

#}</code></pre></pre>
<p>结果输出：</p>
<pre><code class="language-shell">
127.0.0.1       localhost.localdomain   localhost
::1             localhost.localdomain   localhost
...

</code></pre>
<a class="header" href="print.html#a提示" id="a提示"><h5>提示</h5></a>
<p>本书<code>类型系统中的几个常见 trait</code>章节中介绍的 AsRef, Borrow 等 trait 应该能派上用场.</p>
<a class="header" href="print.html#a什么是泛型" id="a什么是泛型"><h1>什么是泛型?</h1></a>
<a class="header" href="print.html#a泛型函数-1" id="a泛型函数-1"><h1>泛型函数</h1></a>
<a class="header" href="print.html#a泛型数据结构" id="a泛型数据结构"><h1>泛型数据结构</h1></a>
<a class="header" href="print.html#a模块和包系统prelude" id="a模块和包系统prelude"><h1>模块和包系统、Prelude</h1></a>
<a class="header" href="print.html#a前言" id="a前言"><h2>前言</h2></a>
<p>随着工程的增大，把所有代码写在一个文件里面，是一件极其初等及愚蠢的作法。大体来讲，它有如下几个缺点：</p>
<ol>
<li>文件大了，编辑器打开慢；</li>
<li>所有代码放在同一个文件中，无法很好地利用现代多窗口编辑器，同时查看编辑相关联的两个代码片断；</li>
<li>代码数量过多，查找某一个关键词过慢，定位到某一行代码的效率会大大降低；</li>
<li>会大大增加上翻下翻的频率，导致你的鼠标中间滚轮易坏；</li>
<li>不断地上翻下翻，会导致你头晕；</li>
<li>头晕了，就容易写出错误的代码，甚至改错文件中的某一行（相似的地方，改错地方了）；</li>
<li>出现bug，根据错误反馈，知道是哪一片逻辑的问题，但不容易快速定位；</li>
</ol>
<p>因此，模块是几乎所有语言的基础设施，尽管叫法各有不同。</p>
<a class="header" href="print.html#a包和模块" id="a包和模块"><h1>包和模块</h1></a>
<a class="header" href="print.html#a包crate" id="a包crate"><h2>包（crate）</h2></a>
<p>Rust 中，<code>crate</code> 是一个独立的可编译单元。具体说来，就是一个或一批文件（如果是一批文件，那么有一个文件是这个 crate 的入口）。它编译后，会对应着生成一个可执行文件或一个库。</p>
<p>执行 <code>cargo new foo</code>，会得到如下目录层级：</p>
<pre><code class="language-text">foo
├── Cargo.toml
└── src
    └── lib.rs
</code></pre>
<p>这里，<code>lib.rs</code> 就是一个 crate（入口），它编译后是一个库。一个工程下可以包含不止一个 crate，本工程只有一个。</p>
<p>执行 <code>cargo new --bin bar</code>，会得到如下目录层级：</p>
<pre><code class="language-text">bar
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>这里，<code>main.rs</code> 就是一个 crate（入口），它编译后是一个可执行文件。</p>
<a class="header" href="print.html#a模块module" id="a模块module"><h2>模块（module）</h2></a>
<p>Rust 提供了一个关键字 <code>mod</code>，它可以在一个文件中定义一个模块，或者引用另外一个文件中的模块。</p>
<p>关于模块的一些要点：</p>
<ol>
<li>每个 crate 中，默认实现了一个隐式的 <code>根模块（root module）</code>；</li>
<li>模块的命名风格也是 <code>lower_snake_case</code>，跟其它的 Rust 的标识符一样；</li>
<li>模块可以嵌套；</li>
<li>模块中可以写任何合法的 Rust 代码；</li>
</ol>
<a class="header" href="print.html#a在文件中定义一个模块" id="a在文件中定义一个模块"><h3>在文件中定义一个模块</h3></a>
<p>比如，在上述 <code>lib.rs</code> 中，我们写上如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod aaa {
    const X: i32 = 10;

    fn print_aaa() {
        println!(&quot;{}&quot;, 42);
    }
}
#}</code></pre></pre>
<p>我们可以继续写如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod aaa {
    const X: i32 = 10;

    fn print_aaa() {
        println!(&quot;{}&quot;, 42);
    }

    mod BBB {
        fn print_bbb() {
            println!(&quot;{}&quot;, 37);
        }
    }
}
#}</code></pre></pre>
<p>还可以继续写：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod aaa {
    const X: i32 = 10;

    fn print_aaa() {
        println!(&quot;{}&quot;, 42);
    }

    mod bbb {
        fn print_bbb() {
            println!(&quot;{}&quot;, 37);
        }
    }
}

mod ccc {
    fn print_ccc() {
        println!(&quot;{}&quot;, 25);
    }

}

#}</code></pre></pre>
<a class="header" href="print.html#a模块的可见性" id="a模块的可见性"><h3>模块的可见性</h3></a>
<p>我们前面写了一些模块，但实际上，我们写那些模块，目前是没有什么作用的。写模块的目的一是为了分隔逻辑块，二是为了提供适当的函数，或对象，供外部访问。而模块中的内容，默认是私有的，只有模块内部能访问。</p>
<p>为了让外部能使用模块中 item，需要使用 <code>pub</code> 关键字。外部引用的时候，使用 <code>use</code> 关键字。例如：</p>
<pre><pre class="playpen"><code class="language-rust">mod ccc {
    pub fn print_ccc() {
        println!(&quot;{}&quot;, 25);
    }
}

fn main() {
    use ccc::print_ccc;

    print_ccc();
    // 或者
    ccc::print_ccc();
}
</code></pre></pre>
<p>规则很简单，一个 item（函数，绑定，Trait 等），前面加了 <code>pub</code>，那么就它变成对外可见（访问，调用）的了。</p>
<a class="header" href="print.html#a引用外部文件模块" id="a引用外部文件模块"><h3>引用外部文件模块</h3></a>
<p>通常，我们会在单独的文件中写模块内容，然后使用 <code>mod</code> 关键字来加载那个文件作为我们的模块。</p>
<p>比如，我们在 <code>src</code> 下新建了文件 <code>aaa.rs</code>。现在目录结构是下面这样子：</p>
<pre><code class="language-text">foo
├── Cargo.toml
└── src
    └── aaa.rs
    └── main.rs
</code></pre>
<p>我们在 <code>aaa.rs</code> 中，写上：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn print_aaa() {
    println!(&quot;{}&quot;, 25);
}
#}</code></pre></pre>
<p>在 <code>main.rs</code> 中，写上：</p>
<pre><pre class="playpen"><code class="language-rust">mod aaa;

use aaa::print_aaa;

fn main () {
    print_aaa();
}
</code></pre></pre>
<p>编译后，生成一个可执行文件。</p>
<p>细心的朋友会发现，<code>aaa.rs</code> 中，没有使用 <code>mod xxx {}</code> 这样包裹起来，是因为 <code>mod xxx;</code> 相当于把 <code>xxx.rs</code> 文件用 <code>mod xxx {}</code> 包裹起来了。初学者往往会多加一层，请注意。</p>
<a class="header" href="print.html#a多文件模块的层级关系" id="a多文件模块的层级关系"><h3>多文件模块的层级关系</h3></a>
<p>Rust 的模块支持层级结构，但这种层级结构本身与文件系统目录的层级结构是解耦的。</p>
<p><code>mod xxx;</code> 这个 <code>xxx</code> 不能包含 <code>::</code> 号。也即在这个表达形式中，是没法引用多层结构下的模块的。也即，你不可能直接使用 <code>mod a::b::c::d;</code> 的形式来引用 <code>a/b/c/d.rs</code> 这个模块。</p>
<p>那么，Rust 的多层模块遵循如下两条规则：</p>
<ol>
<li>优先查找<code>xxx.rs</code> 文件
<ol>
<li><code>main.rs</code>、<code>lib.rs</code>、<code>mod.rs</code>中的<code>mod xxx;</code> 默认优先查找同级目录下的 <code>xxx.rs</code> 文件；</li>
<li>其他文件<code>yyy.rs</code>中的<code>mod xxx;</code>默认优先查找同级目录的<code>yyy</code>目录下的 <code>xxx.rs</code> 文件；</li>
</ol>
</li>
<li>如果 <code>xxx.rs</code> 不存在，则查找 <code>xxx/mod.rs</code> 文件，即 <code>xxx</code> 目录下的 <code>mod.rs</code> 文件。</li>
</ol>
<p>上述两种情况，加载成模块后，效果是相同的。Rust 就凭这两条规则，通过迭代使用，结合 <code>pub</code> 关键字，实现了对深层目录下模块的加载；</p>
<p>下面举个例子，现在我们建了一个测试工程，目录结构如下：</p>
<pre><code>src
├── a
│   ├── b
│   │   ├── c
│   │   │   ├── d.rs
│   │   │   └── mod.rs
│   │   └── mod.rs
│   └── mod.rs
└── main.rs

</code></pre>
<p><code>a/b/c/d.rs</code> 文件内容：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn print_ddd() {
    println!(&quot;i am ddd.&quot;);
}
#}</code></pre></pre>
<p><code>a/b/c/mod.rs</code> 文件内容：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod d;
#}</code></pre></pre>
<p><code>a/b/mod.rs</code> 文件内容：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod c;
#}</code></pre></pre>
<p><code>a/mod.rs</code> 文件内容：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod b;
#}</code></pre></pre>
<p><code>main.rs</code> 文件内容：</p>
<pre><pre class="playpen"><code class="language-rust">mod a;

use a::b::c::d;

fn main() {
    d::print_ddd();
}

</code></pre></pre>
<p>输出结果为：<code>i am ddd.</code></p>
<p>仔细理解本例子，就明白 Rust 的层级结构模块的用法了。</p>
<p>至于为何 Rust 要这样设计，有几下几个原因：</p>
<ol>
<li>Rust 本身模块的设计是与操作系统文件系统目录解耦的，因为 Rust 本身可用于操作系统的开发；</li>
<li>Rust 中的一个文件内，可包含多个模块，直接将 <code>a::b::c::d</code> 映射到 <code>a/b/c/d.rs</code> 会引起一些歧义；</li>
<li>Rust 一切从安全性、显式化立场出发，要求引用路径中的每一个节点，都是一个有效的模块，比如上例，<code>d</code> 是一个有效的模块的话，那么，要求 <code>c, b, a</code> 分别都是有效的模块，可单独引用。</li>
</ol>
<a class="header" href="print.html#a路径" id="a路径"><h3>路径</h3></a>
<p>前面我们提到，一个 crate 是一个独立的可编译单元。它有一个入口文件，这个入口文件是这个 crate（里面可能包含若干个 module）的模块根路径。整个模块的引用，形成一个链，每个模块，都可以用一个精确的路径（比如：<code>a::b::c::d</code>）来表示；</p>
<p>与文件系统概念类似，模块路径也有相对路径和绝对路径的概念。为此，Rust 提供了 <code>self</code> 和 <code>super</code> 两个关键字。</p>
<p><code>self</code> 在路径中，有两种意思：</p>
<ol>
<li><code>use self::xxx</code> 表示，加载当前模块中的 <code>xxx</code>。此时 self 可省略；</li>
<li><code>use xxx::{self, yyy}</code>，表示，加载当前路径下模块 <code>xxx</code> 本身，以及模块 <code>xxx</code> 下的 <code>yyy</code>；</li>
</ol>
<p><code>super</code> 表示，当前模块路径的上一级路径，可以理解成父模块。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use super::xxx;
#}</code></pre></pre>
<p>表示引用父模块中的 <code>xxx</code>。</p>
<p>另外，还有一种特殊的路径形式：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
::xxx::yyy
#}</code></pre></pre>
<p>它表示，引用根路径下的 <code>xxx::yyy</code>，这个根路径，指的是当前 crate 的根路径。</p>
<p>路径中的 <code>*</code> 符号：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use xxx::*;
#}</code></pre></pre>
<p>表示导入 <code>xxx</code> 模块下的所有可见 item（加了 pub 标识的 item）。</p>
<a class="header" href="print.html#re-exporting" id="re-exporting"><h3>Re-exporting</h3></a>
<p>我们可以结合使用 <code>pub use</code> 来实现 <code>Re-exporting</code>。<code>Re-exporting</code> 的字面意思就是 <code>重新导出</code>。它的意思是这样的，把深层的 item 导出到上层目录中，使调用的时候，更方便。接口设计中会大量用到这个技术。</p>
<p>还是举上面那个 <code>a::b::c::d</code> 的例子。我们在 <code>main.rs</code> 中，要调用 <code>d</code>，得使用 <code>use a::b::c::d;</code> 来调用。而如果我们修改 <code>a/mod.rs</code> 文件为：
<code>a/mod.rs</code> 文件内容：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod b;
pub use b::c::d;
#}</code></pre></pre>
<p>那么，我们在 <code>main.rs</code> 中，就可以使用 <code>use a::d;</code> 来调用了。从这个例子来看没觉得方便多少。但是如果开发的一个库中有大量的内容，而且是在不同层次的模块中。那么，通过统一导出到一个地方，就能大大方便接口使用者。</p>
<a class="header" href="print.html#a加载外部-crate" id="a加载外部-crate"><h3>加载外部 crate</h3></a>
<p>前面我们讲的，都是在当前 crate 中的技术。真正我们在开发时，会大量用到外部库。外部库是通过</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate xxx;
#}</code></pre></pre>
<p>这样来引入的。</p>
<p>注：要使上述引用生效，还必须在 <code>Cargo.toml</code> 的 <code>dependecies</code> 段，加上 <code>xxx=&quot;version num&quot;</code> 这种依赖说明，详情见 <code>Cargo 项目管理</code> 这一章。</p>
<p>引入后，就相当于引入了一个符号 <code>xxx</code>，后面可以直接以这个 <code>xxx</code> 为根引用这个 crate 中的 item：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate xxx;

use xxx::yyy::zzz;
#}</code></pre></pre>
<p>引入的时候，可以通过 <code>as</code> 关键字重命名。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate xxx as foo;

use foo::yyy::zzz;
#}</code></pre></pre>
<a class="header" href="print.html#prelude" id="prelude"><h1>Prelude</h1></a>
<p>Rust 的标准库，有一个 <code>prelude</code> 子模块，这里面包含了默认导入（std 库是默认导入的，然后 std 库中的 prelude 下面的东西也是默认导入的）的所有符号。</p>
<p>大体上有下面一些内容：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
std::marker::{Copy, Send, Sized, Sync}
std::ops::{Drop, Fn, FnMut, FnOnce}
std::mem::drop
std::boxed::Box
std::borrow::ToOwned
std::clone::Clone
std::cmp::{PartialEq, PartialOrd, Eq, Ord}
std::convert::{AsRef, AsMut, Into, From}
std::default::Default
std::iter::{Iterator, Extend, IntoIterator, DoubleEndedIterator, ExactSizeIterator}
std::option::Option::{self, Some, None}
std::result::Result::{self, Ok, Err}
std::slice::SliceConcatExt
std::string::{String, ToString}
std::vec::Vec
#}</code></pre></pre>
<a class="header" href="print.html#pub-restricted" id="pub-restricted"><h1>pub restricted</h1></a>
<a class="header" href="print.html#a概览" id="a概览"><h2>概览</h2></a>
<p>这是 rust1.18 新增的一个语法。在此之前的版本，<code>item</code> 只有 <code>pub</code>/non-<code>pub</code> 两种分类，pub restricted 这个语法用来扩展 <code>pub</code> 的使用，使其能够指定想要的作用域(可见范围)，详情参见RFC <a href="https://github.com/rust-lang/rfcs/blob/master/text/1422-pub-restricted.md">1422-pub-restricted.md</a>。</p>
<p>在 Rust 中 <code>crate</code> 是一个模块树，可以通过表达式 <code>pub(crate) item;</code> 来限制 <code>item</code> 只在当前 <code>crate</code> 中可用，在当前 <code>crate</code> 的其他子树中，可以通过 <code>use + path</code> 的语法来引用 <code>item</code>。</p>
<a class="header" href="print.html#a设计动因" id="a设计动因"><h2>设计动因</h2></a>
<p>Rust1.18 之前，如果我们想要设计一个 item <code>x</code> 可以在多处使用，那么有两种方法：</p>
<ul>
<li>在根目录中定义一个非 <code>pub</code> item；</li>
<li>在子模块中定义一个 <code>pub</code> item，同时通过 <code>use</code> 将这个项目引用到根目录。</li>
</ul>
<p>但是，有时候这两种方法都并不是我们想要的。在一些情况下，我们希望对于某些特定的模块，该item可见，而其他模块不可见。</p>
<p>下面我们来看一个例子：</p>
<pre><code class="language-Rust">// Intent: `a` exports `I`, `bar`, and `foo`, but nothing else.
pub mod a {
    pub const I: i32 = 3;

    // `semisecret` will be used &quot;many&quot; places within `a`, but
    // is not meant to be exposed outside of `a`.
    fn semisecret(x: i32) -&gt; i32  { use self::b::c::J; x + J }

    pub fn bar(z: i32) -&gt; i32 { semisecret(I) * z }
    pub fn foo(y: i32) -&gt; i32 { semisecret(I) + y }

    mod b {
        mod c {
            const J: i32 = 4; // J is meant to be hidden from the outside world.
        }
    }
}
</code></pre>
<p>这段代码编译无法通过，因为 <code>J</code> 无法在 <code>mod c</code> 的外部访问，而 <code>fn semisecret</code> 尝试在 <code>mod a</code> 中访问 <code>J</code>.</p>
<p>在 rust1.18 之前，保持<code>J</code>私有，并能够让 <code>a</code> 使用 <code>fn semisecret</code> 的正确写法是，将 <code>fn semisecret</code> 移动到 <code>mod c</code> 中，并将其 <code>pub</code>，之后根据需要可以重新导出 <code>semisecret</code>。(如果不需要保持 <code>J</code> 的私有化，那么可以对其进行 <code>pub</code>，之后可以在 <code>b</code> 中 <code>pub use self::c::J</code> 或者直接 <code>pub c</code>)</p>
<pre><code class="language-Rust">// Intent: `a` exports `I`, `bar`, and `foo`, but nothing else.
pub mod a {
    pub const I: i32 = 3;

    // `semisecret` will be used &quot;many&quot; places within `a`, but
    // is not meant to be exposed outside of `a`.
    // (If we put `pub use` here, then *anyone* could access it.)
    use self::b::semisecret;

    pub fn bar(z: i32) -&gt; i32 { semisecret(I) * z }
    pub fn foo(y: i32) -&gt; i32 { semisecret(I) + y }

    mod b {
        pub use self::c::semisecret;
        mod c {
            const J: i32 = 4; // J is meant to be hidden from the outside world.
            pub fn semisecret(x: i32) -&gt; i32  { x + J }
        }
    }
}
</code></pre>
<p>这种情况可以正常工作，但是，这里有个严重的问题：没有人能够十分清晰的说明 <code>pub fn semisecret</code> 使用到了哪些地方，需要通过上下文进行判断：</p>
<ol>
<li>所有可以访问 <code>semisecret</code> 的模块；</li>
<li>在所有可以访问 <code>semisecret</code> 的模块中，是否存在 <code>semisecret</code> 的 re-export;</li>
</ol>
<p>同时，如果在 <code>a</code> 中使用 <code>pub use self::b::semisecret</code> ，那么所有人都可以通过 <code>use</code> 访问 <code>fn semisecret</code>，但是实际上，这个函数只需要让 <code>mod a</code> 访问就可以了。</p>
<a class="header" href="print.html#pub-restricted-的使用" id="pub-restricted-的使用"><h2>pub restricted 的使用</h2></a>
<a class="header" href="print.html#syntax" id="syntax"><h3>Syntax</h3></a>
<p>old:</p>
<pre><code>VISIBILITY ::= &lt;empty&gt; | `pub`
</code></pre>
<p>new:</p>
<pre><code>VISIBILITY ::= &lt;empty&gt; | `pub` | `pub` `(` USE_PATH `)` | `pub` `(` `crate` `)`
</code></pre>
<p>pub(restriction) 意味着对 item，method，field等的定义加以可见范围（作用域）的限制。</p>
<p>可见范围（作用域）分为所有 crate (无限制)，当前 crate，当前 crate 中的子模块的绝对路径。被限制的东西不能在其限制范围之外直接使用。</p>
<ul>
<li><code>pub</code> 无明确指定意味着无限制；</li>
<li><code>pub(crate)</code> 当前 crate 有效；</li>
<li><code>pub(in &lt;path&gt;)</code> 在 <code>&lt;path&gt;</code> 表示的模块中有效。</li>
</ul>
<a class="header" href="print.html#a修改示例" id="a修改示例"><h3>修改示例</h3></a>
<pre><code class="language-Rust">// Intent: `a` exports `I`, `bar`, and `foo`, but nothing else.
pub mod a {
    pub const I: i32 = 3;

    // `semisecret` will be used &quot;many&quot; places within `a`, but
    // is not meant to be exposed outside of `a`.
    // (`pub use` would be *rejected*; see Note 1 below)
    use self::b::semisecret;

    pub fn bar(z: i32) -&gt; i32 { semisecret(I) * z }
    pub fn foo(y: i32) -&gt; i32 { semisecret(I) + y }

    mod b {
        pub(in a) use self::c::semisecret;
        mod c {
            const J: i32 = 4; // J is meant to be hidden from the outside world.

            // `pub(in a)` means &quot;usable within hierarchy of `mod a`, but not
            // elsewhere.&quot;
            pub(in a) fn semisecret(x: i32) -&gt; i32  { x + J }
        }
    }
}
</code></pre>
<p>Note 1: 如果改成下面这种方式，编译器会报错:</p>
<pre><code class="language-Rust">pub mod a { [...] pub use self::b::semisecret; [...] }
</code></pre>
<p>因为 <code>pub(in a) fn semisecret</code> 说明这个函数只能在 <code>a</code> 中使用，不允许 <code>pub</code> 出 <code>a</code> 的范围。</p>
<a class="header" href="print.html#a限制字段示例" id="a限制字段示例"><h3>限制字段示例</h3></a>
<pre><code class="language-Rust">mod a {
    #[derive(Default)]
    struct Priv(i32);

    pub mod b {
        use a::Priv as Priv_a;

        #[derive(Default)]
        pub struct F {
            pub    x: i32,
                   y: Priv_a,
            pub(in a) z: Priv_a,
        }

        #[derive(Default)]
        pub struct G(pub i32, Priv_a, pub(in a) Priv_a);

        // ... accesses to F.{x,y,z} ...
        // ... accesses to G.{0,1,2} ...
    }
    // ... accesses to F.{x,z} ...
    // ... accesses to G.{0,2} ...
}

mod k {
    use a::b::{F, G};
    // ... accesses to F and F.x ...
    // ... accesses to G and G.0 ...
}
</code></pre>
<a class="header" href="print.html#crate-限制示例" id="crate-限制示例"><h3>Crate 限制示例</h3></a>
<p>Crate <code>c1</code>:</p>
<pre><code class="language-Rust">pub mod a {
    struct Priv(i32);

    pub(crate) struct R { pub y: i32, z: Priv } // ok: field allowed to be more public
    pub        struct S { pub y: i32, z: Priv }

    pub fn to_r_bad(s: S) -&gt; R { ... } //~ ERROR: `R` restricted solely to this crate

    pub(crate) fn to_r(s: S) -&gt; R { R { y: s.y, z: s.z } } // ok: restricted to crate
}

use a::{R, S}; // ok: `a::R` and `a::S` are both visible

pub use a::R as ReexportAttempt; //~ ERROR: `a::R` restricted solely to this crate
</code></pre>
<p>Crate <code>c2</code>:</p>
<pre><code class="language-Rust">extern crate c1;

use c1::a::S; // ok: `S` is unrestricted

use c1::a::R; //~ ERROR: `c1::a::R` not visible outside of its crate
</code></pre>
<a class="header" href="print.html#a17错误处理" id="a17错误处理"><h1>17.错误处理</h1></a>
<p>错误处理是保证程序健壮性的前提，在编程语言中错误处理的方式大致分为两种：抛出异常（exceptions）和作为值返回。</p>
<p><strong>Rust</strong> 将错误作为值返回并且提供了原生的优雅的错误处理方案。</p>
<p>熟练掌握错误处理是软件工程中非常重要的环节，让我一起来看看<strong>Rust</strong>展现给我们的错误处理艺术。</p>
<a class="header" href="print.html#a171-option和result" id="a171-option和result"><h2>17.1 Option和Result</h2></a>
<p>谨慎使用<code>panic</code>：</p>
<pre><pre class="playpen"><code class="language-rust">fn guess(n: i32) -&gt; bool {
    if n &lt; 1 || n &gt; 10 {
        panic!(&quot;Invalid number: {}&quot;, n);
    }
    n == 5
}

fn main() {
    guess(11);
}
</code></pre></pre>
<p><code>panic</code>会导致当前线程结束，甚至是整个程序的结束，这往往是不被期望看到的结果。（编写示例或者简短代码的时候<code>panic</code>不失为一个好的建议）</p>
<a class="header" href="print.html#option" id="option"><h3>Option</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    None,
    Some(T),
}
#}</code></pre></pre>
<p><strong>Option</strong> 是Rust的系统类型，用来表示值不存在的可能，这在编程中是一个好的实践，它强制<strong>Rust</strong>检测和处理值不存在的情况。例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
#}</code></pre></pre>
<p><code>find</code>在字符串<code>haystack</code>中查找<code>needle</code>字符，事实上结果会出现两种可能，有（<code>Some(usize)</code>)或无（<code>None</code>）。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let file_name = &quot;foobar.rs&quot;;
    match find(file_name, '.') {
        None =&gt; println!(&quot;No file extension found.&quot;),
        Some(i) =&gt; println!(&quot;File extension: {}&quot;, &amp;file_name[i+1..]),
    }
}
</code></pre></pre>
<p><strong>Rust</strong> 使用模式匹配来处理返回值，调用者必须处理结果为<code>None</code>的情况。这往往是一个好的编程习惯，可以减少潜在的bug。<strong>Option</strong> 包含一些方法来简化模式匹配，毕竟过多的<code>match</code>会使代码变得臃肿，这也是滋生bug的原因之一。</p>
<a class="header" href="print.html#unwrap" id="unwrap"><h4>unwrap</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Option::Some(val) =&gt; val,
            Option::None =&gt;
              panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
#}</code></pre></pre>
<p><code>unwrap</code>当遇到<code>None</code>值时会panic，如前面所说这不是一个好的工程实践。不过有些时候却非常有用：</p>
<ul>
<li><strong>在例子和简单快速的编码中</strong> 有的时候你只是需要一个小例子或者一个简单的小程序，输入输出已经确定，你根本没必要花太多时间考虑错误处理，使用<code>unwrap</code>变得非常合适。</li>
<li><strong>当程序遇到了致命的bug，panic是最优选择</strong></li>
</ul>
<a class="header" href="print.html#map" id="map"><h4>map</h4></a>
<p>假如我们要在一个字符串中找到文件的扩展名，比如<code>foo.rs</code>中的<code>rs</code>， 我们可以这样：</p>
<pre><pre class="playpen"><code class="language-rust">fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match find(file_name, '.') {
        None =&gt; None,
        Some(i) =&gt; Some(&amp;file_name[i+1..]),
    }
}

fn main() {
    match extension_explicit(&quot;foo.rs&quot;) {
        None =&gt; println!(&quot;no extension&quot;),
        Some(ext) =&gt;  assert_eq!(ext, &quot;rs&quot;),
    }
}
</code></pre></pre>
<p>我们可以使用<code>map</code>简化：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// map是标准库中的方法
fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {
    match option {
        None =&gt; None,
        Some(value) =&gt; Some(f(value)),
    }
}
// 使用map去掉match
fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, '.').map(|i| &amp;file_name[i+1..])
}
#}</code></pre></pre>
<p><code>map</code>如果有值<code>Some(T)</code>会执行<code>f</code>，反之直接返回<code>None</code>。</p>
<a class="header" href="print.html#unwrap_or" id="unwrap_or"><h4>unwrap_or</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
    match option {
        None =&gt; default,
        Some(value) =&gt; value,
    }
}
#}</code></pre></pre>
<p><code>unwrap_or</code>提供了一个默认值<code>default</code>，当值为<code>None</code>时返回<code>default</code>：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    assert_eq!(extension(&quot;foo.rs&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);
    assert_eq!(extension(&quot;foo&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);
}
</code></pre></pre>
<a class="header" href="print.html#and_then" id="and_then"><h4>and_then</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
        where F: FnOnce(T) -&gt; Option&lt;A&gt; {
    match option {
        None =&gt; None,
        Some(value) =&gt; f(value),
    }
}
#}</code></pre></pre>
<p>看起来<code>and_then</code>和<code>map</code>差不多，不过<code>map</code>只是把值为<code>Some(t)</code>重新映射了一遍，<code>and_then</code>则会返回另一个<code>Option</code>。如果我们在一个文件路径中找到它的扩展名，这时候就会变得尤为重要：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::path::Path;
fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    let path = Path::new(file_path);
    path.file_name().to_str()
}
fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).and_then(extension)
}
#}</code></pre></pre>
<a class="header" href="print.html#result" id="result"><h3>Result</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p><code>Result</code>是<code>Option</code>的更通用的版本，比起<code>Option</code>结果为<code>None</code>它解释了结果错误的原因，所以：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Option&lt;T&gt; = Result&lt;T, ()&gt;;
#}</code></pre></pre>
<p>这样的别名是一样的（<code>()</code>标示空元组，它既是<code>()</code>类型也可以是<code>()</code>值）</p>
<a class="header" href="print.html#unwrap-1" id="unwrap-1"><h4>unwrap</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Result::Ok(val) =&gt; val,
            Result::Err(err) =&gt;
              panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),
        }
    }
}
#}</code></pre></pre>
<p>没错和<code>Option</code>一样，事实上它们拥有很多类似的方法，不同的是，<code>Result</code>包括了错误的详细描述，这对于调试人员来说，这是友好的。</p>
<a class="header" href="print.html#result我们从例子开始" id="result我们从例子开始"><h4>Result我们从例子开始</h4></a>
<pre><pre class="playpen"><code class="language-rust">fn double_number(number_str: &amp;str) -&gt; i32 {
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let n: i32 = double_number(&quot;10&quot;);
    assert_eq!(n, 20);
}
</code></pre></pre>
<p><code>double_number</code>从一个字符串中解析出一个<code>i32</code>的数字并<code>*2</code>，<code>main</code>中调用看起来没什么问题，但是如果把<code>&quot;10&quot;</code>换成其他解析不了的字符串程序便会panic</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl str {
    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;
}

#}</code></pre></pre>
<p><code>parse</code>返回一个<code>Result</code>，但让我们也可以返回一个<code>Option</code>，毕竟一个字符串要么能解析成一个数字要么不能，但是<code>Result</code>给我们提供了更多的信息（要么是一个空字符串，一个无效的数位，太大或太小），这对于使用者是友好的。当你面对一个Option和Result之间的选择时。如果你可以提供详细的错误信息，那么大概你也应该提供。</p>
<p>这里需要理解一下<code>FromStr</code>这个<strong>trait</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait FromStr {
    type Err;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;;
}

impl FromStr for i32 {
    type Err = ParseIntError;
    fn from_str(src: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {

    }
}
#}</code></pre></pre>
<p><code>number_str.parse::&lt;i32&gt;()</code>事实上调用的是<code>i32</code>的<code>FromStr</code>实现。</p>
<p>我们需要改写这个例子：</p>
<pre><pre class="playpen"><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre></pre>
<p>不仅仅是<code>map</code>，<code>Result</code>同样包含了<code>unwrap_or</code>和<code>and_then</code>。也有一些特有的针对错误类型的方法<code>map_err</code>和<code>or_else</code>。</p>
<a class="header" href="print.html#result别名" id="result别名"><h4>Result别名</h4></a>
<p>在<strong>Rust</strong>的标准库中会经常出现Result的别名，用来默认确认其中<code>Ok(T)</code>或者<code>Err(E)</code>的类型，这能减少重复编码。比如<code>io::Result</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::num::ParseIntError;
use std::result;

type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {
    unimplemented!();
}
#}</code></pre></pre>
<a class="header" href="print.html#a组合option和result" id="a组合option和result"><h3>组合Option和Result</h3></a>
<p><code>Option</code>的方法<code>ok_or</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
    match option {
        Some(val) =&gt; Ok(val),
        None =&gt; Err(err),
    }
}
#}</code></pre></pre>
<p>可以在值为<code>None</code>的时候返回一个<code>Result::Err(E)</code>，值为<code>Some(T)</code>的时候返回<code>Ok(T)</code>，利用它我们可以组合<code>Option</code>和<code>Result</code>：</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {
    argv.nth(1)
        .ok_or(&quot;Please give at least one argument&quot;.to_owned())
        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre></pre>
<p><code>double_arg</code>将传入的命令行参数转化为数字并翻倍，<code>ok_or</code>将<code>Option</code>类型转换成<code>Result</code>，<code>map_err</code>当值为<code>Err(E)</code>时调用作为参数的函数处理错误</p>
<a class="header" href="print.html#a复杂的例子" id="a复杂的例子"><h4>复杂的例子</h4></a>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&lt;i32&gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre></pre>
<p><code>file_double</code>从文件中读取内容并将其转化成<code>i32</code>类型再翻倍。
这个例子看起来已经很复杂了，它使用了多个组合方法，我们可以使用传统的<code>match</code>和<code>if let</code>来改写它：</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&gt; n,
        Err(err) =&gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre></pre>
<p>这两种方法个人认为都是可以的，依具体情况来取舍。</p>
<a class="header" href="print.html#try" id="try"><h3>try!</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(::std::convert::From::from(err)),
    });
}

#}</code></pre></pre>
<p><code>try!</code>事实上就是<code>match Result</code>的封装，当遇到<code>Err(E)</code>时会提早返回，
<code>::std::convert::From::from(err)</code>可以将不同的错误类型返回成最终需要的错误类型，因为所有的错误都能通过<code>From</code>转化成<code>Box&lt;Error&gt;</code>，所以下面的代码是正确的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n = try!(contents.trim().parse::&lt;i32&gt;());
    Ok(2 * n)
}

#}</code></pre></pre>
<a class="header" href="print.html#a组合自定义错误类型" id="a组合自定义错误类型"><h4>组合自定义错误类型</h4></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::io;
use std::path::Path;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(err: num::ParseIntError) -&gt; CliError {
        CliError::Parse(err)
    }
}

fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}
#}</code></pre></pre>
<p><code>CliError</code>分别为<code>io::Error</code>和<code>num::ParseIntError</code>实现了<code>From</code>这个trait，所有调用<code>try!</code>的时候这两种错误类型都能转化成<code>CliError</code>。</p>
<a class="header" href="print.html#a总结-4" id="a总结-4"><h3>总结</h3></a>
<p>熟练使用<code>Option</code>和<code>Result</code>是编写 <strong>Rust</strong> 代码的关键，<strong>Rust</strong> 优雅的错误处理离不开值返回的错误形式，编写代码时提供给使用者详细的错误信息是值得推崇的。</p>
<a class="header" href="print.html#option-类型" id="option-类型"><h1>Option 类型</h1></a>
<a class="header" href="print.html#result-类型" id="result-类型"><h1>Result 类型</h1></a>
<a class="header" href="print.html#a输入与输出" id="a输入与输出"><h1>输入与输出</h1></a>
<p>输入与输出可以说是一个实用程序的最基本要求，没有输入输出的程序是没有什么卵用的。虽然输入输出被函数式编程语言鄙称为副作用，但正是这个副作用才赋予了程序实用性，君不见某著名函数式语言之父称他主导设计的函数式语言&quot;<a href="https://www.youtube.com/watch?v=iSmkqocn0oQ">is useless</a>&quot;。这章我们就来谈谈输入输出副作用。</p>
<a class="header" href="print.html#a读写-trait" id="a读写-trait"><h2>读写 Trait</h2></a>
<p>输入最基本的功能是读(Read)，输出最基本的功能是写(Write)。标准库里面把怎么读和怎么写抽象出来归到了 <code>Read</code> 和 <code>Write</code> 两个接口里面，实现了 <code>Read</code> 接口的叫 reader，而实现了 <code>Write</code> 的叫 writer。Rust里面的 Trait 比其它语言里面的接口更好的一个地方是 Trait 可以带默认实现，比如用户定义的 reader 只需要实现 <code>read</code> 一个方法就可以调用 <code>Read</code> trait 里面的任意其它方法，而 writer 也只需要实现 <code>write</code> 和 <code>flush</code> 两个方法。</p>
<p>Read 和 Write 这两个 Trait 都有定义了好多方法，具体可以参考标准库 API 文档中的<a href="http://doc.rust-lang.org/stable/std/io/trait.Read.html">Read</a> 和 <a href="http://doc.rust-lang.org/stable/std/io/trait.Write.html">Write</a></p>
<p>Read 由于每调用一次 <code>read</code> 方法都会调用一次系统API与内核交互，效率比较低，如果给 reader 增加一个 buffer，在调用时 <code>read</code> 方法时多读一些数据放在 buffer 里面，下次调用 <code>read</code> 方法时就有可能只需要从 buffer 里面取数据而不用调用系统API了，从而减少了系统调用次数提高了读取效率，这就是所谓的 <code>BufRead</code> Trait。一个普通的 reader 通过 <code>io::BufReader::new(reader)</code> 或者 <code>io::BufReader::with_capacity(bufSize, reader)</code> 就可以得到一个 BufReader 了，显然这两个创建 BufReader 的函数一个是使用默认大小的 buffer 一个可以指定 buffer 大小。BufReader 比较常用的两个方法是按行读： <code>read_line(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt;</code> 和 <code>lines(&amp;mut self) -&gt; Lines&lt;Self&gt;</code>，从函数签名上就可以大概猜出函数的用法所以就不啰嗦了，需要注意的是后者返回的是一个迭代器。详细说明直接看 API 文档中的<a href="http://doc.rust-lang.org/stable/std/io/trait.BufRead.html">BufRead</a></p>
<p>同样有 <code>BufWriter</code> 只不过由于其除了底层加了 buffer 之外并没有增加新的写方法，所以并没有专门的 <code>BufWrite</code> Trait，可以通过 <code>io::BufWriter::new(writer)</code> 或 <code>io::BufWriter::with_capacity(bufSize, writer)</code> 创建 <code>BufWriter</code>。</p>
<p>输入与输出接口有了，我们接下来看看实际应用中最常用的两类 reader 和 writer：标准输入/输出，文件输入/输出</p>
<a class="header" href="print.html#a标准输入与输出" id="a标准输入与输出"><h1>标准输入与输出</h1></a>
<p>回顾一下我们写的第一个 Rust 程序就是带副作用的，其副作用就是向标准输出(stdout)，通常是终端或屏幕，输出了 Hello, World! 让屏幕上这几个字符的地方点亮起来。<code>println!</code> 宏是最常见的输出，用宏来做输出的还有 <code>print!</code>，两者都是向标准输出(stdout)输出，两者的区别也一眼就能看出。至于格式化输出，<a href="../type/operator-and-formatting.md">基础运算符和字符串格式化小节</a>有详细说明，这里就不再啰嗦了。</p>
<p>更通用的标准输入与输出定义在 <code>std::io</code> 模块里，调用 <code>std::io::stdin()</code> 和 <code>std::io::stdout()</code> 两个函数分别会得到输入句柄和输出句柄(哎，<a href="https://zh.wikipedia.org/wiki/%E5%8F%A5%E6%9F%84">句柄</a>这个词是计算机史上最莫名其妙的翻译了)，这两个句柄默认会通过互斥锁同步，也就是说不让多个进程同时读或写标准输入输出，不然的话如果一个进程要往标准输出画马，一个进程要画驴，两个进程同时写标准输出的话，最后可能就给画出一头骡子了，如果更多进程画不同的动物最后可能就成四不像了。除了隐式地用互斥锁，我们还可以显式地在句柄上调用 <code>.lock()</code>。输入输出句柄实现了前面讲的读写 Trait，所以是 reader/writer，就可以调接口来读写标准输入与输出了。举几个栗子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;

fn read_from_stdin(buf: &amp;mut String) -&gt; io::Result&lt;()&gt; {
    try!(io::stdin().read_line(buf));
    Ok(())
}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;

fn write_to_stdout(buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
    try!(io::stdout().write(&amp;buf));
    Ok(())
}
#}</code></pre></pre>
<p>可以看到上面的例子都是返回了 <code>io::Result&lt;()&gt;</code> 类型，这不是偶然，而是 IO 操作通用的写法，因为 IO 操作是程序与外界打交道，所以都是有可能失败的，用 <code>io::Result&lt;T&gt;</code> 把结果包起来，<code>io::Result&lt;T&gt;</code> 只是标准 <code>Result&lt;T,E&gt;</code> 中 <code>E</code> 固定为 <code>io::Error</code> 后类型的别名，而作为有副作用的操作我们一般是不用关心其返回值的，因为执行这类函数其真正的意义都体现在副作用上面了，所以返回值只是用来表示是否成功执行，而本身 <code>Result</code> 类型本身已经可以表示执行状态了，里面的 <code>T</code> 是什么则无关紧要，既然 <code>T</code> 没什么意义，那我们就选没什么意义的 <code>unit</code> 类型好了，所以 IO 操作基本上都是使用 <code>io::Result&lt;()&gt;</code>。</p>
<p>另外有一个地方需要注意的是由于 IO 操作可能会失败所以一般都是和 <code>try!</code> 宏一起使用的，但是 <code>try!</code> 在遇到错误时会把错误 <code>return</code> 出去的，所以需要保证包含 <code>try!</code> 语句的函数其返回类型是 <code>io::Result&lt;T&gt;</code>，很多新手文档没仔细看就直接查 std api 文档，然后照着 api 文档里面的例子把带 IO 操作的 <code>try!</code> 宏写到了 <code>main</code> 函数里。结果一编译，擦，照着文档写都编译不过，什么烂文档。其实点一下 api 文档上面的运行按钮就会发现文档里面的例子都是把 <code>try!</code> 放在另一个函数里面的，因为 <code>main</code> 函数是没有返回值的，而 <code>try!</code> 会返回 <code>io::Result&lt;T&gt;</code>，所以直接把 <code>try!</code> 放 <code>main</code> 函数里面肯定要跪。比如下面的从标准输入读取一行输入，由于把 <code>try!</code> 放在了 main 函数里，所以是编译不过的。</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    let mut input = String::new();
    try!(io::stdin().read_line(&amp;mut input));
    println!(&quot;You typed: {}&quot;, input.trim());
}
</code></pre></pre>
<p>这里有一件事需要主要的是 Rust 里面没有办法从键盘获取一个数字类型的值。实际上像 C 这样的语言也不是直接获取了数字类型，它只不过是做了一种转换。那么我们如果想要从键盘获取一个数字类型应该怎么做呢？</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut input = String::new();
        std::io::stdin()
            .read_line(&amp;mut input)
            .expect(&quot;Failed to read line&quot;);
    // 这里等效的写法是：
    // let num: i32 = input.trim().parse().unwrap(); 
    let num = input.trim().parse::&lt;i32&gt;().unwrap();
    println!(&quot;您输入的数字是：{}&quot;, num);
}
</code></pre></pre>
<p>如果有很多地方都需要输入数字可以自行编写一个 <code>numin</code> 宏:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! numin {
      () =&gt;{
          {
            let mut input = String::new();
              std::io::stdin()
                  .read_line(&amp;mut input)
                .expect(&quot;Failed to read line&quot;);
              input.trim().parse().unwrap()
        }
    };
}
#}</code></pre></pre>
<p>于是上面的程序可以被改写成：</p>
<pre><code>
fn main() {
    let num: i32 = numin!();
    println!(&quot;您输入的数字是：{}&quot;, num);
}
</code></pre>
<p>不过如果用户输入的不是数字，那么就会导致错误。这一点和 C 里面是非常相似的。当然您可以把程序写得再复杂一点儿来保证用户输入的一定是数字。不过这些就不是我们这一节要讨论的内容了。</p>
<p>还有一点一些从其它语言转过来的程序员可能会疑惑的是，如何从命令行接受输入参数，因为 C 里面的 main 函数可以带参数所以可以直接从 main 函数的参数里获取输入参数。但其实这类输入与我们这里讲的有很大的差别的，它在 Rust 里面被归为环境变量，可以通过 <code>std::env::args()</code> 获取，这个函数返回一个 <code>Args</code> 迭代器，其中第一个就是程序名，后面的都是输入给程序的命令行参数。</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args = env::args();
    for arg in args {
        println!(&quot;{}&quot;, arg);
    }
}
</code></pre></pre>
<p>将上面的程序存为 <em>args.rs</em> 然后编译执行，结果如下</p>
<pre><code>$ rustc args.rs
$ ./args a b c
./args
a
b
c
</code></pre>
<a class="header" href="print.html#print-宏" id="print-宏"><h1>print! 宏</h1></a>
<p>我们在快速入门中就提到过标准输出的行缓冲。它一个表现就是 <code>print!</code> 宏。如果你在 <code>print!</code> 宏后面接上一个输入就会发现这种按行缓冲的机制。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print!(&quot;hello!\ninput:&quot;);
    let mut input = String::new();
        std::io::stdin()
            .read_line(&amp;mut input)
            .expect(&quot;Failed to read line&quot;);
    println!(&quot;line:{}&quot;,input);
}
</code></pre></pre>
<p>您可以编译并运行这段程序试一试，您会发现我们并没有得到预期的（下划线代表光标的位置）：</p>
<pre><code>hello!
input:_
</code></pre>
<p>而是得到了：</p>
<pre><code>hello!
_
</code></pre>
<p>这就是由于标准输出中的这种行缓冲机制，在遇到换行符之前，输出的内容并不会隐式的刷新，这就导致 <code>print!</code> 宏和 <code>println!</code> 宏实际上并不完全相同。在标准库中 <code>print!</code> 宏是这样的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! print {
    ($($arg:tt)*) =&gt; { ... };
}
#}</code></pre></pre>
<p>由此，我们可以对它进行改进，使它和 <code>println!</code> 宏被自动刷新，不过这种刷新是一种显式的刷新。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::{self, Write};

macro_rules! printf {
    ($($arg:tt)*) =&gt;{
        print!($($arg)*);
        io::stdout().flush().unwrap();
    }
}
#}</code></pre></pre>
<p>此外，当您需要刷新还没有遇到换行符的一行内容的时候您都可以使用 <code>io::stdout().flush().unwrap();</code> 进行刷新，不过需要注意的是要先 <code>use std::io::{self, Write};</code> 如果您不这样做，将会得到一个错误。</p>
<a class="header" href="print.html#a文件输入与输出" id="a文件输入与输出"><h1>文件输入与输出</h1></a>
<p>文件 <code>std::fs::File</code> 本身实现了 <code>Read</code> 和 <code>Write</code> trait，所以文件的输入输出非常简单，只要得到一个 <code>File</code> 类型实例就可以调用读写接口进行文件输入与输出操作了。而要得到 <code>File</code> 就得让操作系统打开(open)或新建(create)一个文件。还是拿例子来说明</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;
use std::io::prelude::*;
use std::fs::File;

// create file and write something
fn create_file(filename: &amp;str, buf: &amp;[u8]) -&gt; io::Result&lt;()&gt; {
    let mut f = try!(File::create(filename));
    try!(f.write(&amp;buf));
    Ok(())
}

// read from file to String
fn read_file(filename: &amp;str, buf: &amp;mut String) -&gt; io::Result&lt;()&gt; {
    let mut f = try!(File::open(filename));
    try!(f.read_to_string(&amp;buf));
    Ok(())
}

fn main() {
    let f = &quot;foo.txt&quot;;
    let mut buf = String::new();
    match create_file(f, b&quot;Hello, World!&quot;) {
        Ok(()) =&gt; {
            match read_file(f, &amp;mut buf) {
                Ok(()) =&gt; {println!(&quot;{}&quot;, buf);},
                Err(e) =&gt; {println!(&quot;{}&quot;, e);},
            };
        },
        Err(e) =&gt; {println!(&quot;{}&quot;, e);},
    }
}
</code></pre></pre>
<p>文件操作上面 Rust 与其它语言处理方式有些不一样，其它语言一般把读写选项作为函数参数传给 open 函数，而 Rust 则是在 option 上面调用 open 函数。 <a href="http://doc.rust-lang.org/stable/std/fs/struct.OpenOptions.html"><code>std::fs::OpenOptions</code></a> 是一个 builder，通过 new 函数创建后，可以链式调用设置打开文件的选项，是 read, write, append, truncate 还是 create 等，OpenOptions 构建完成后就可以再接着调用 open 方法了，看下下面的例子就明白了</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::OpenOptions;

let file = OpenOptions::new().write(true).truncate(true).open(&quot;foo.txt&quot;);
#}</code></pre></pre>
<p>Rust 这种用 builder pattern 来设置打开文件选项，相比于将选项以字符作为参数传给 open 函数的一个优点是可以让编译器保证检查选项合法性，不用等到运行时才发现手抖把 read-mode 的 <code>r</code> 写成了 <code>t</code>。</p>
<a class="header" href="print.html#heap--stack" id="heap--stack"><h1>Heap &amp; Stack</h1></a>
<a class="header" href="print.html#rust-中的堆和栈" id="rust-中的堆和栈"><h2>Rust 中的堆和栈</h2></a>
<p>由于函数栈在函数执行完后会销毁，所以栈上存储的变量不能在函数之间传递，这也意味着函数没法返回栈上变量的引用，而这通常是 C/C++ 新手常犯的错误。而 Rust 中编译器则会检查出这种错误，错误提示一般为 <code>xxx does not live long enough</code>，看下面一个例子</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = foo(&quot;world&quot;);
    println!(&quot;{}&quot;, b);
}

fn foo(x: &amp;str) -&gt; &amp;str {
    let a = &quot;Hello, &quot;.to_string() + x;
    &amp;a
}
</code></pre></pre>
<p>之所以这样写，很多人觉得可以直接拷贝字符串 <code>a</code> 的引用从而避免拷贝整个字符串，然而得到的结果却是 <code>a does not live long enough</code> 的编译错误。因为引用了一个函数栈中临时创建的变量，函数栈在函数调用结束后会销毁，这样返回的引用就变得毫无意义了，指向了一个并不存在的变量。相对于 C/C++ 而言，使用 Rust 就会幸运很多，因为 C/C++ 中写出上面那样的程序，编译器会默默地让你通过直到运行时才会给你报错。</p>
<p>其实由于 <code>a</code> 本身是 String 类型，是使用堆来存储的，所以可以直接返回，在函数返回时函数栈销毁后依然存在。同时 Rust 中下面的代码实际上也只是浅拷贝。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = foo(&quot;world&quot;);
    println!(&quot;{}&quot;, b);
}

fn foo(x: &amp;str) -&gt; String {
    let a = &quot;Hello, &quot;.to_string() + x;
    a
}
</code></pre></pre>
<p>Rust 默认使用栈来存储变量，而栈上内存分配是连续的，所以必须在编译之前了解变量占用的内存空间大小，编译器才能合理安排内存布局。</p>
<a class="header" href="print.html#box" id="box"><h2>Box</h2></a>
<p>C 里面是通过 malloc/free 手动管理堆上内存空间的，而 Rust 则有多种方式，其中最常用的一种就是 Box,通过 <code>Box::new()</code> 可以在堆上申请一块内存空间，不像 C 里面一样堆上空间需要手动调用 <code>free</code> 释放，Rust 中是在编译期编译器借助 lifetime 对堆内存生命期进行分析，在生命期结束时自动插入 <code>free</code>。当前  Rust 底层即 Box 背后是调用 jemalloc 来做内存管理的，所以堆上空间是不需要程序员手动去管理释放的。很多时候你被编译器虐得死去活来时，那些 <code>borrow</code>, <code>move</code>, <code>lifetime</code> 错误其实就是编译器在教你认识内存布局，教你用 lifetime 规则去控制内存。这套规则说难不难，说简单也不简单，以前用别的语言写程序时对内存不关心的，刚写起来可能真的会被虐得死去活来，但是一旦熟悉这套规则，对内存布局掌握清楚后，借助编译器的提示写起程序来就会如鱼得水，这套规则是理论界研究的成果在Rust编译器上的实践。</p>
<p>大多数带 GC 的面向对象语言里面的对象都是借助 box 来实现的，比如常见的动态语言 Python/Ruby/JavaScript 等，其宣称的&quot;一切皆对象(Everything is an object)&quot;，里面所谓的对象基本上都是 boxed value。</p>
<p>boxed 值相对于 unboxed，内存占用空间会大些，同时访问值的时候也需要先进行 unbox，即对指针进行解引用再获取真正存储的值，所以内存访问开销也会大些。既然 boxed 值既费空间又费时间，为什么还要这么做呢？因为通过 box，所有对象看起来就像是以相同大小存储的，因为只需要存储一个指针就够了，应用程序可以同等看待各种值，而不用去管实际存储是多大的值，如何申请和释放相应资源。</p>
<p>Box 是堆上分配的内存，通过 <code>Box::new()</code> 会创建一个堆空间并返回一个指向堆空间的指针</p>
<p>nightly 版本中引入 <code>box</code> 关键词，可以用来取代 <code>Box::new()</code> 申请一个堆空间，也可以用在模式匹配上面</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(box_syntax, box_patterns)]
fn main() {
   let boxed = Some(box 5);
   match boxed {
       Some(box unboxed) =&gt; println!(&quot;Some {}&quot;, unboxed),
       None =&gt; println!(&quot;None&quot;),
   }
}
</code></pre></pre>
<p>下面看一个例子，对比一下 <code>Vec&lt;i32&gt;</code> 和 <code>Vec&lt;Box&lt;i32&gt;&gt;</code> 内存布局，这两个图来自 <a href="http://stackoverflow.com/questions/21066133/what-is-the-difference-between-veci32-and-vecboxi32/21067103#21067103">Stack Overflow</a>，从这两张内存分布图可以清楚直观地看出 Box 是如何存储的</p>
<pre><code>Vec&lt;i32&gt;

(stack)    (heap)
┌──────┐   ┌───┐
│ vec1 │──→│ 1 │
└──────┘   ├───┤
           │ 2 │
           ├───┤
           │ 3 │
           ├───┤
           │ 4 │
           └───┘
</code></pre>
<pre><code>Vec&lt;Box&lt;i32&gt;&gt;

(stack)    (heap)   ┌───┐
┌──────┐   ┌───┐ ┌─→│ 1 │
│ vec2 │──→│   │─┘  └───┘
└──────┘   ├───┤    ┌───┐
           │   │───→│ 2 │
           ├───┤    └───┘
           │   │─┐  ┌───┐
           ├───┤ └─→│ 3 │
           │   │─┐  └───┘
           └───┘ │  ┌───┐
                 └─→│ 4 │
                    └───┘
</code></pre>
<p>一些语言里会有看起来既像数组又像列表的数据结构，例如 python 中的 List，其实就是与 <code>Vec&lt;Box&lt;i32&gt;&gt;</code> 类似，只是把 i32 换成任意类型，就操作效率而言比单纯的 List 高效，同时又比数组使用更灵活。</p>
<p>一般而言，在编译期间不能确定大小的数据类型都需要使用堆上内存，因为编译器无法在栈上分配 编译期未知大小 的内存，所以诸如 String, Vec 这些类型的内存其实是被分配在堆上的。换句话说，我们可以很轻松的将一个 Vec move 出作用域而不必担心消耗，因为数据实际上不会被复制。</p>
<p>另外,需要从函数中返回一个浅拷贝的变量时也需要使用堆内存而不能直接返回一个指向函数内部定义变量的引用。</p>
<a class="header" href="print.html#a几种智能指针" id="a几种智能指针"><h1>几种智能指针</h1></a>
<p>本章讲解 <code>Rc</code>, <code>Arc</code>, <code>Mutex</code>, <code>RwLock</code>, <code>Cell</code>, <code>RefCell</code> 的知识和使用方法。</p>
<a class="header" href="print.html#rc-和-arc" id="rc-和-arc"><h1>Rc 和 Arc</h1></a>
<p>Rust 建立在所有权之上的这一套机制，它要求一个资源同一时刻有且只能有一个拥有所有权的绑定或 <code>&amp;mut</code> 引用，这在大部分的情况下保证了内存的安全。但是这样的设计是相当严格的，在另外一些情况下，它限制了程序的书写，无法实现某些功能。因此，Rust 在 std 库中提供了额外的措施来补充所有权机制，以应对更广泛的场景。</p>
<p>默认 Rust 中，对一个资源，同一时刻，有且只有一个所有权拥有者。<code>Rc</code> 和 <code>Arc</code> 使用引用计数的方法，让程序在同一时刻，实现同一资源的多个所有权拥有者，多个拥有者共享资源。</p>
<a class="header" href="print.html#rc" id="rc"><h2>Rc</h2></a>
<p><code>Rc</code> 用于同一线程内部，通过 <code>use std::rc::Rc</code> 来引入。它有以下几个特点：</p>
<ol>
<li>用 <code>Rc</code> 包装起来的类型对象，是 <code>immutable</code> 的，即 不可变的。即你无法修改 <code>Rc&lt;T&gt;</code> 中的 <code>T</code> 对象，只能读；</li>
<li>一旦最后一个拥有者消失，则资源会被自动回收，这个生命周期是在编译期就确定下来的；</li>
<li><code>Rc</code> 只能用于同一线程内部，不能用于线程之间的对象共享（不能跨线程传递）；</li>
<li><code>Rc</code> 实际上是一个指针，它不影响包裹对象的方法调用形式（即不存在先解开包裹再调用值这一说）。</li>
</ol>
<p>例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;

let five = Rc::new(5);
let five2 = five.clone();
let five3 = five.clone();

#}</code></pre></pre>
<a class="header" href="print.html#rc-weak" id="rc-weak"><h2>Rc Weak</h2></a>
<p><code>Weak</code> 通过 <code>use std::rc::Weak</code> 来引入。</p>
<p><code>Rc</code> 是一个引用计数指针，而 <code>Weak</code> 是一个指针，但不增加引用计数，是 <code>Rc</code> 的 weak 版。它有以下几个特点：</p>
<ol>
<li>可访问，但不拥有。不增加引用计数，因此，不会对资源回收管理造成影响；</li>
<li>可由 <code>Rc&lt;T&gt;</code> 调用 <code>downgrade</code> 方法而转换成 <code>Weak&lt;T&gt;</code>；</li>
<li><code>Weak&lt;T&gt;</code> 可以使用 <code>upgrade</code> 方法转换成 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，如果资源已经被释放，则 Option 值为 <code>None</code>；</li>
<li>常用于解决循环引用的问题。</li>
</ol>
<p>例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;

let five = Rc::new(5);

let weak_five = Rc::downgrade(&amp;five);

let strong_five: Option&lt;Rc&lt;_&gt;&gt; = weak_five.upgrade();
#}</code></pre></pre>
<a class="header" href="print.html#arc" id="arc"><h2>Arc</h2></a>
<p><code>Arc</code> 是原子引用计数，是 <code>Rc</code> 的多线程版本。<code>Arc</code> 通过 <code>std::sync::Arc</code> 引入。</p>
<p>它的特点：</p>
<ol>
<li><code>Arc</code> 可跨线程传递，用于跨线程共享一个对象；</li>
<li>用 <code>Arc</code> 包裹起来的类型对象，对可变性没有要求；</li>
<li>一旦最后一个拥有者消失，则资源会被自动回收，这个生命周期是在编译期就确定下来的；</li>
<li><code>Arc</code> 实际上是一个指针，它不影响包裹对象的方法调用形式（即不存在先解开包裹再调用值这一说）；</li>
<li><code>Arc</code> 对于多线程的共享状态<strong>几乎是必须的</strong>（减少复制，提高性能）。</li>
</ol>
<p>示例：</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Arc;
use std::thread;

fn main() {
    let numbers: Vec&lt;_&gt; = (0..100u32).collect();
    let shared_numbers = Arc::new(numbers);

    for _ in 0..10 {
        let child_numbers = shared_numbers.clone();

        thread::spawn(move || {
            let local_numbers = &amp;child_numbers[..];

            // Work with the local numbers
        });
    }
}
</code></pre></pre>
<a class="header" href="print.html#arc-weak" id="arc-weak"><h3>Arc Weak</h3></a>
<p>与 <code>Rc</code> 类似，<code>Arc</code> 也有一个对应的 <code>Weak</code> 类型，从 <code>std::sync::Weak</code> 引入。</p>
<p>意义与用法与 <code>Rc Weak</code> 基本一致，不同的点是这是多线程的版本。故不再赘述。</p>
<a class="header" href="print.html#a一个例子" id="a一个例子"><h2>一个例子</h2></a>
<p>下面这个例子，表述的是如何实现多个对象同时引用另外一个对象。</p>
<pre><pre class="playpen"><code class="language-rust">use std::rc::Rc;

struct Owner {
    name: String
}

struct Gadget {
    id: i32,
    owner: Rc&lt;Owner&gt;
}

fn main() {
    // Create a reference counted Owner.
    let gadget_owner : Rc&lt;Owner&gt; = Rc::new(
        Owner { name: String::from(&quot;Gadget Man&quot;) }
    );

    // Create Gadgets belonging to gadget_owner. To increment the reference
    // count we clone the `Rc&lt;T&gt;` object.
    let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };
    let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };

    drop(gadget_owner);

    // Despite dropping gadget_owner, we're still able to print out the name
    // of the Owner of the Gadgets. This is because we've only dropped the
    // reference count object, not the Owner it wraps. As long as there are
    // other `Rc&lt;T&gt;` objects pointing at the same Owner, it will remain
    // allocated. Notice that the `Rc&lt;T&gt;` wrapper around Gadget.owner gets
    // automatically dereferenced for us.
    println!(&quot;Gadget {} owned by {}&quot;, gadget1.id, gadget1.owner.name);
    println!(&quot;Gadget {} owned by {}&quot;, gadget2.id, gadget2.owner.name);

    // At the end of the method, gadget1 and gadget2 get destroyed, and with
    // them the last counted references to our Owner. Gadget Man now gets
    // destroyed as well.
}
</code></pre></pre>
<a class="header" href="print.html#mutex-与-rwlock" id="mutex-与-rwlock"><h1>Mutex 与 RwLock</h1></a>
<a class="header" href="print.html#mutex" id="mutex"><h2>Mutex</h2></a>
<p><code>Mutex</code> 意为互斥对象，用来保护共享数据。Mutex 有下面几个特征：</p>
<ol>
<li><code>Mutex</code> 会等待获取锁令牌(token)，在等待过程中，会阻塞线程。直到锁令牌得到。同时只有一个线程的 <code>Mutex</code> 对象获取到锁；</li>
<li><code>Mutex</code> 通过 <code>.lock()</code> 或 <code>.try_lock()</code> 来尝试得到锁令牌，被保护的对象，必须通过这两个方法返回的 <code>RAII</code> 守卫来调用，不能直接操作；</li>
<li>当 <code>RAII</code> 守卫作用域结束后，锁会自动解开；</li>
<li>在多线程中，<code>Mutex</code> 一般和 <code>Arc</code> 配合使用。</li>
</ol>
<p>示例：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc::channel;

const N: usize = 10;

// Spawn a few threads to increment a shared variable (non-atomically), and
// let the main thread know once all increments are done.
//
// Here we're using an Arc to share memory among threads, and the data inside
// the Arc is protected with a mutex.
let data = Arc::new(Mutex::new(0));

let (tx, rx) = channel();
for _ in 0..10 {
    let (data, tx) = (data.clone(), tx.clone());
    thread::spawn(move || {
        // The shared state can only be accessed once the lock is held.
        // Our non-atomic increment is safe because we're the only thread
        // which can access the shared state when the lock is held.
        //
        // We unwrap() the return value to assert that we are not expecting
        // threads to ever fail while holding the lock.
        let mut data = data.lock().unwrap();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
        // the lock is unlocked here when `data` goes out of scope.
    });
}

rx.recv().unwrap();
#}</code></pre></pre>
<a class="header" href="print.html#lock-与-try_lock-的区别" id="lock-与-try_lock-的区别"><h3><code>lock</code> 与 <code>try_lock</code> 的区别</h3></a>
<p><code>.lock()</code> 方法，会等待锁令牌，等待的时候，会阻塞当前线程。而 <code>.try_lock()</code> 方法，只是做一次尝试操作，不会阻塞当前线程。</p>
<p>当 <code>.try_lock()</code> 没有获取到锁令牌时，会返回 <code>Err</code>。因此，如果要使用 <code>.try_lock()</code>，需要对返回值做仔细处理（比如，在一个循环检查中）。</p>
<p><strong>点评</strong>：Rust 的 Mutex 设计成一个对象，不同于 C 语言中的自旋锁用两条分开的语句的实现，更安全，更美观，也更好管理。</p>
<a class="header" href="print.html#rwlock" id="rwlock"><h2>RwLock</h2></a>
<p><code>RwLock</code> 翻译成 <code>读写锁</code>。它的特点是：</p>
<ol>
<li>同时允许多个读，最多只能有一个写；</li>
<li>读和写不能同时存在；</li>
</ol>
<p>比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::sync::RwLock;

let lock = RwLock::new(5);

// many reader locks can be held at once
{
    let r1 = lock.read().unwrap();
    let r2 = lock.read().unwrap();
    assert_eq!(*r1, 5);
    assert_eq!(*r2, 5);
} // read locks are dropped at this point

// only one write lock may be held, however
{
    let mut w = lock.write().unwrap();
    *w += 1;
    assert_eq!(*w, 6);
} // write lock is dropped here
#}</code></pre></pre>
<a class="header" href="print.html#a读写锁的方法" id="a读写锁的方法"><h3>读写锁的方法</h3></a>
<ol>
<li><code>.read()</code></li>
<li><code>.try_read()</code></li>
<li><code>.write()</code></li>
<li><code>.try_write()</code></li>
</ol>
<p>注意需要对 <code>.try_read()</code> 和 <code>.try_write()</code> 的返回值进行判断。</p>
<a class="header" href="print.html#cell-refcell" id="cell-refcell"><h1>Cell, RefCell</h1></a>
<p>前面我们提到，Rust 通过其所有权机制，严格控制拥有和借用关系，来保证程序的安全，并且这种安全是在编译期可计算、可预测的。但是这种严格的控制，有时也会带来灵活性的丧失，有的场景下甚至还满足不了需求。</p>
<p>因此，Rust 标准库中，设计了这样一个系统的组件：<code>Cell</code>, <code>RefCell</code>，它们弥补了 Rust 所有权机制在灵活性上和某些场景下的不足。同时，又没有打破 Rust 的核心设计。它们的出现，使得 Rust 革命性的语言理论设计更加完整，更加实用。</p>
<p>具体是因为，它们提供了 <code>内部可变性</code>（相对于标准的 <code>继承可变性</code> 来讲的）。</p>
<p>通常，我们要修改一个对象，必须</p>
<ol>
<li>成为它的拥有者，并且声明 <code>mut</code>；</li>
<li>或 以 <code>&amp;mut</code> 的形式，借用；</li>
</ol>
<p>而通过 <code>Cell</code>, <code>RefCell</code>，我们可以在需要的时候，就可以修改里面的对象。而不受编译期静态借用规则束缚。</p>
<a class="header" href="print.html#cell" id="cell"><h2><code>Cell</code></h2></a>
<p><code>Cell</code> 有如下特点：</p>
<ol>
<li><code>Cell&lt;T&gt;</code> 只能用于 <code>T</code> 实现了 <code>Copy</code> 的情况；</li>
</ol>
<a class="header" href="print.html#get" id="get"><h3><code>.get()</code></h3></a>
<p><code>.get()</code> 方法，返回内部值的一个拷贝。比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::Cell;

let c = Cell::new(5);

let five = c.get();
#}</code></pre></pre>
<a class="header" href="print.html#set" id="set"><h3><code>.set()</code></h3></a>
<p><code>.set()</code> 方法，更新值。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::Cell;

let c = Cell::new(5);

c.set(10);
#}</code></pre></pre>
<a class="header" href="print.html#refcell" id="refcell"><h2><code>RefCell</code></h2></a>
<p>相对于 <code>Cell</code> 只能包裹实现了 <code>Copy</code> 的类型，<code>RefCell</code> 用于更普遍的情况（其它情况都用 <code>RefCell</code>）。</p>
<p>相对于标准情况的 <code>静态借用</code>，<code>RefCell</code> 实现了 <code>运行时借用</code>，这个借用是临时的。这意味着，编译器对 <code>RefCell</code> 中的内容，不会做静态借用检查，也意味着，出了什么问题，用户自己负责。</p>
<p><code>RefCell</code> 的特点：</p>
<ol>
<li>在不确定一个对象是否实现了 <code>Copy</code> 时，直接选 <code>RefCell</code>；</li>
<li>如果被包裹对象，同时被可变借用了两次，则会导致线程崩溃。所以需要用户自行判断；</li>
<li><code>RefCell</code> 只能用于线程内部，不能跨线程；</li>
<li><code>RefCell</code> 常常与 <code>Rc</code> 配合使用（都是单线程内部使用）；</li>
</ol>
<p>我们来看实例：</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre></pre>
<p>从上例可看出，用了 <code>RefCell</code> 后，外面是 <code>不可变引用</code> 的情况，一样地可以修改被包裹的对象。</p>
<p>常用方法</p>
<a class="header" href="print.html#borrow" id="borrow"><h3><code>.borrow()</code></h3></a>
<p>不可变借用被包裹值。同时可存在多个不可变借用。</p>
<p>比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;

let c = RefCell::new(5);

let borrowed_five = c.borrow();
let borrowed_five2 = c.borrow();
#}</code></pre></pre>
<p>下面的例子会崩溃：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;
use std::thread;

let result = thread::spawn(move || {
   let c = RefCell::new(5);
   let m = c.borrow_mut();

   let b = c.borrow(); // this causes a panic
}).join();

assert!(result.is_err());
#}</code></pre></pre>
<a class="header" href="print.html#borrow_mut" id="borrow_mut"><h3><code>.borrow_mut()</code></h3></a>
<p>可变借用被包裹值。同时只能有一个可变借用。</p>
<p>比如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;

let c = RefCell::new(5);

let borrowed_five = c.borrow_mut();
#}</code></pre></pre>
<p>下面的例子会崩溃：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;
use std::thread;

let result = thread::spawn(move || {
   let c = RefCell::new(5);
   let m = c.borrow();

   let b = c.borrow_mut(); // this causes a panic
}).join();

assert!(result.is_err());
#}</code></pre></pre>
<a class="header" href="print.html#into_inner" id="into_inner"><h3><code>.into_inner()</code></h3></a>
<p>取出包裹值。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;

let c = RefCell::new(5);

let five = c.into_inner();
#}</code></pre></pre>
<a class="header" href="print.html#a一个综合示例" id="a一个综合示例"><h2>一个综合示例</h2></a>
<p>下面这个示例，表述的是如何实现两个对象的循环引用。综合演示了 <code>Rc</code>, <code>Weak</code>, <code>RefCell</code> 的用法</p>
<pre><pre class="playpen"><code class="language-rust">
use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;

struct Owner {
    name: String,
    gadgets: RefCell&lt;Vec&lt;Weak&lt;Gadget&gt;&gt;&gt;,
    // 其他字段
}

struct Gadget {
    id: i32,
    owner: Rc&lt;Owner&gt;,
    // 其他字段
}

fn main() {
    // 创建一个可计数的Owner。
    // 注意我们将gadgets赋给了Owner。
    // 也就是在这个结构体里， gadget_owner包含gadets
    let gadget_owner : Rc&lt;Owner&gt; = Rc::new(
        Owner {
            name: &quot;Gadget Man&quot;.to_string(),
            gadgets: RefCell::new(Vec::new()),
        }
    );

    // 首先，我们创建两个gadget，他们分别持有 gadget_owner 的一个引用。
    let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});
    let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});

    // 我们将从gadget_owner的gadgets字段中持有其可变引用
    // 然后将两个gadget的Weak引用传给owner。
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget1));
    gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&amp;gadget2));

    // 遍历 gadget_owner的gadgets字段
    for gadget_opt in gadget_owner.gadgets.borrow().iter() {

        // gadget_opt 是一个 Weak&lt;Gadget&gt; 。 因为 weak 指针不能保证他所引用的对象
        // 仍然存在。所以我们需要显式的调用 upgrade() 来通过其返回值(Option&lt;_&gt;)来判
        // 断其所指向的对象是否存在。
        // 当然，这个Option为None的时候这个引用原对象就不存在了。
        let gadget = gadget_opt.upgrade().unwrap();
        println!(&quot;Gadget {} owned by {}&quot;, gadget.id, gadget.owner.name);
    }

    // 在main函数的最后， gadget_owner, gadget1和daget2都被销毁。
    // 具体是，因为这几个结构体之间没有了强引用（`Rc&lt;T&gt;`），所以，当他们销毁的时候。
    // 首先 gadget1和gadget2被销毁。
    // 然后因为gadget_owner的引用数量为0，所以这个对象可以被销毁了。
    // 循环引用问题也就避免了
}
</code></pre></pre>
<a class="header" href="print.html#a类型系统中的几个常见-trait" id="a类型系统中的几个常见-trait"><h1>类型系统中的几个常见 trait</h1></a>
<p>本章讲解 Rust 类型系统中的几个常见 trait。有 <code>Into, From, AsRef, AsMut, Borrow, BorrowMut, ToOwned, Deref, Cow</code>。</p>
<a class="header" href="print.html#intofrom-及其在-string-和-str-互转上的应用" id="intofrom-及其在-string-和-str-互转上的应用"><h1>Into/From 及其在 String 和 &amp;str 互转上的应用</h1></a>
<p><code>std::convert</code> 下面，有两个 Trait，<code>Into/From</code>，它们是一对孪生姐妹。它们的作用是配合泛型，进行一些设计上的归一化处理。</p>
<p>它们的基本形式为： <code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code>。</p>
<a class="header" href="print.html#fromt" id="fromt"><h2>From<T></h2></a>
<p>对于类型为 <code>U</code> 的对象 <code>foo</code>，如果它实现了 <code>From&lt;T&gt;</code>，那么，可以通过 <code>let foo = U::from(bar)</code> 来生成自己。这里，<code>bar</code> 是类型为 <code>T</code> 的对象。</p>
<p>下面举一例，因为 <code>String</code> 实现了 <code>From&lt;&amp;str&gt;</code>，所以 <code>String</code> 可以从 <code>&amp;str</code> 生成。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let string = &quot;hello&quot;.to_string();
let other_string = String::from(&quot;hello&quot;);

assert_eq!(string, other_string);
#}</code></pre></pre>
<a class="header" href="print.html#intot" id="intot"><h2>Into<T></h2></a>
<p>对于一个类型为 <code>U: Into&lt;T&gt;</code> 的对象 <code>foo</code>，<code>Into</code> 提供了一个函数：<code>.into(self) -&gt; T</code>，调用 <code>foo.into()</code> 会消耗自己（转移资源所有权），生成类型为 <code>T</code> 的另一个新对象 <code>bar</code>。</p>
<p>这句话，说起来有点抽象。下面拿一个具体的实例来辅助理解。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn is_hello&lt;T: Into&lt;Vec&lt;u8&gt;&gt;&gt;(s: T) {
   let bytes = b&quot;hello&quot;.to_vec();
   assert_eq!(bytes, s.into());
}

let s = &quot;hello&quot;.to_string();
is_hello(s);
#}</code></pre></pre>
<p>因为 <code>String</code> 类型实现了 <code>Into&lt;Vec&lt;u8&gt;&gt;</code>。</p>
<p>下面拿一个实际生产中字符串作为函数参数的例子来说明。</p>
<p>在我们设计库的 <code>API</code> 的时候，经常会遇到一个恼人的问题，函数参数如果定为 <code>String</code>，则外部传入实参的时候，对字符串字面量，必须要做 <code>.to_string()</code> 或 <code>.to_owned()</code> 转换，参数一多，就是一件又乏味又丑的事情。（而反过来设计的话，对初学者来说，又会遇到一些生命周期的问题，比较麻烦，这个后面论述）</p>
<p>那存不存在一种方法，能够使传参又能够接受 <code>String</code> 类型，又能够接受 <code>&amp;str</code> 类型呢？答案就是<strong>泛型</strong>。而仅是泛型的话，太宽泛。因此，标准库中，提供了 <code>Into&lt;T&gt;</code> 来为其做约束，以便方便而高效地达到我们的目的。</p>
<p>比如，我们有如下结构体：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Person {
    name: String,
}

impl Person {
    fn new (name: String) -&gt; Person {
        Person { name: name }
    }
}
#}</code></pre></pre>
<p>我们在调用的时候，是这样的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let name = &quot;Herman&quot;.to_string();
let person = Person::new(name);
#}</code></pre></pre>
<p>如果直接写成：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let person = Person::new(&quot;Herman&quot;);
#}</code></pre></pre>
<p>就会报类型不匹配的错误。</p>
<p>好了，下面 <code>Into</code> 出场。我们可以定义结构体为</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Person {
    name: String,
}

impl Person {
    fn new&lt;S: Into&lt;String&gt;&gt;(name: S) -&gt; Person {
        Person { name: name.into() }
    }
}
#}</code></pre></pre>
<p>然后，调用的时候，下面两种写法都是可以的：</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let person = Person::new(&quot;Herman&quot;);
    let person = Person::new(&quot;Herman&quot;.to_string());
}
</code></pre></pre>
<p>我们来仔细分析一下这一块的写法</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Person {
    fn new&lt;S: Into&lt;String&gt;&gt;(name: S) -&gt; Person {
        Person { name: name.into() }
    }
}
#}</code></pre></pre>
<p>参数类型为 <code>S</code>， 是一个泛型参数，表示可以接受不同的类型。<code>S: Into&lt;String&gt;</code> 表示 <code>S</code> 类型必须实现了 <code>Into&lt;String&gt;</code>（约束）。而 <code>&amp;str</code> 类型，符合这个要求。因此 <code>&amp;str</code> 类型可以直接传进来。</p>
<p>而 <code>String</code> 本身也是实现了 <code>Into&lt;String&gt;</code> 的。当然也可以直接传进来。</p>
<p>然后，下面 <code>name: name.into()</code> 这里也挺神秘的。它的作用是将 <code>name</code> 转换成 <code>String</code> 类型的另一个对象。当 name 是 <code>&amp;str</code> 时，它会转换成 <code>String</code> 对象，会做一次字符串的拷贝（内存的申请、复制）。而当 name 本身是 <code>String</code> 类型时，<code>name.into()</code> 不会做任何转换，代价为零（有没有恍然大悟）。</p>
<p>根据参考资料，上述内容通过下面三式获得：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'a&gt; From&lt;&amp;'a str&gt; for String {}
impl&lt;T&gt; From&lt;T&gt; for T {}
impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {}
#}</code></pre></pre>
<p>更多内容，请参考：</p>
<ul>
<li><a href="http://doc.rust-lang.org/std/convert/trait.Into.html">http://doc.rust-lang.org/std/convert/trait.Into.html</a></li>
<li><a href="http://doc.rust-lang.org/std/convert/trait.From.html">http://doc.rust-lang.org/std/convert/trait.From.html</a></li>
<li><a href="http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html">http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html</a></li>
</ul>
<a class="header" href="print.html#asref-和-asmut" id="asref-和-asmut"><h1>AsRef 和 AsMut</h1></a>
<p><code>std::convert</code> 下面，还有另外两个 Trait，<code>AsRef/AsMut</code>，它们功能是配合泛型，在执行引用操作的时候，进行自动类型转换。这能够使一些场景的代码实现得清晰漂亮，大家方便开发。</p>
<a class="header" href="print.html#asreft" id="asreft"><h2>AsRef<T></h2></a>
<p><code>AsRef</code> 提供了一个方法 <code>.as_ref()</code>。</p>
<p>对于一个类型为 <code>T</code> 的对象 <code>foo</code>，如果 <code>T</code> 实现了 <code>AsRef&lt;U&gt;</code>，那么，<code>foo</code> 可执行 <code>.as_ref()</code> 操作，即 <code>foo.as_ref()</code>。操作的结果，我们得到了一个类型为 <code>&amp;U</code> 的新引用。</p>
<p>注：</p>
<ol>
<li>与 <code>Into&lt;T&gt;</code> 不同的是，<code>AsRef&lt;T&gt;</code> 只是类型转换，<code>foo</code> 对象本身没有被消耗；</li>
<li><code>T: AsRef&lt;U&gt;</code> 中的 <code>T</code>，可以接受 资源拥有者（owned）类型，共享引用（shared referrence）类型 ，可变引用（mutable referrence）类型。</li>
</ol>
<p>下面举个简单的例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn is_hello&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
   assert_eq!(&quot;hello&quot;, s.as_ref());
}

let s = &quot;hello&quot;;
is_hello(s);

let s = &quot;hello&quot;.to_string();
is_hello(s);
#}</code></pre></pre>
<p>因为 <code>String</code> 和 <code>&amp;str</code> 都实现了 <code>AsRef&lt;str&gt;</code>。</p>
<a class="header" href="print.html#asmutt" id="asmutt"><h2>AsMut<T></h2></a>
<p><code>AsMut&lt;T&gt;</code> 提供了一个方法 <code>.as_mut()</code>。它是 <code>AsRef&lt;T&gt;</code> 的可变（mutable）引用版本。</p>
<p>对于一个类型为 <code>T</code> 的对象 <code>foo</code>，如果 <code>T</code> 实现了 <code>AsMut&lt;U&gt;</code>，那么，<code>foo</code> 可执行 <code>.as_mut()</code> 操作，即 <code>foo.as_mut()</code>。操作的结果，我们得到了一个类型为 <code>&amp;mut U</code> 的可变（mutable）引用。</p>
<p>注：在转换的过程中，<code>foo</code> 会被可变（mutable）借用。</p>
<a class="header" href="print.html#borrow-borrowmut-toowned" id="borrow-borrowmut-toowned"><h1>Borrow, BorrowMut, ToOwned</h1></a>
<a class="header" href="print.html#borrowt" id="borrowt"><h2>Borrow<T></h2></a>
<p><code>use std::borrow::Borrow;</code></p>
<p><code>Borrow</code> 提供了一个方法 <code>.borrow()</code>。</p>
<p>对于一个类型为 <code>T</code> 的值 <code>foo</code>，如果 <code>T</code> 实现了 <code>Borrow&lt;U&gt;</code>，那么，<code>foo</code> 可执行 <code>.borrow()</code> 操作，即 <code>foo.borrow()</code>。操作的结果，我们得到了一个类型为 <code>&amp;U</code> 的新引用。</p>
<p><code>Borrow</code> 可以认为是 <code>AsRef</code> 的严格版本，它对普适引用操作的前后类型之间附加了一些其它限制。</p>
<p><code>Borrow</code> 的前后类型之间要求必须有内部等价性。不具有这个等价性的两个类型之间，不能实现 <code>Borrow</code>。</p>
<p><code>AsRef</code> 更通用，更普遍，覆盖类型更多，是 <code>Borrow</code> 的超集。</p>
<p>举例：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::borrow::Borrow;

fn check&lt;T: Borrow&lt;str&gt;&gt;(s: T) {
    assert_eq!(&quot;Hello&quot;, s.borrow());
}

let s = &quot;Hello&quot;.to_string();

check(s);

let s = &quot;Hello&quot;;

check(s);
#}</code></pre></pre>
<a class="header" href="print.html#borrowmutt" id="borrowmutt"><h2>BorrowMut<T></h2></a>
<p><code>use std::borrow::BorrowMut;</code></p>
<p><code>BorrowMut&lt;T&gt;</code> 提供了一个方法 <code>.borrow_mut()</code>。它是 <code>Borrow&lt;T&gt;</code> 的可变（mutable）引用版本。</p>
<p>对于一个类型为 <code>T</code> 的值 <code>foo</code>，如果 <code>T</code> 实现了 <code>BorrowMut&lt;U&gt;</code>，那么，<code>foo</code> 可执行 <code>.borrow_mut()</code> 操作，即 <code>foo.borrow_mut()</code>。操作的结果我们得到类型为 <code>&amp;mut U</code> 的一个可变（mutable）引用。</p>
<p>注：在转换的过程中，<code>foo</code> 会被可变（mutable）借用。</p>
<a class="header" href="print.html#toowned" id="toowned"><h2>ToOwned</h2></a>
<p><code>use std::borrow::ToOwned;</code></p>
<p><code>ToOwned</code> 为 <code>Clone</code> 的普适版本。它提供了 <code>.to_owned()</code> 方法，用于类型转换。</p>
<p>有些实现了 <code>Clone</code> 的类型 <code>T</code> 可以从引用状态实例 <code>&amp;T</code> 通过 <code>.clone()</code> 方法，生成具有所有权的 <code>T</code> 的实例。但是它只能由 <code>&amp;T</code> 生成 <code>T</code>。而对于其它形式的引用，<code>Clone</code> 就无能为力了。</p>
<p>而 <code>ToOwned</code> trait 能够从任意引用类型实例，生成具有所有权的类型实例。</p>
<a class="header" href="print.html#a参考" id="a参考"><h2>参考</h2></a>
<ul>
<li><a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html">http://doc.rust-lang.org/std/borrow/trait.Borrow.html</a></li>
</ul>
<a class="header" href="print.html#deref" id="deref"><h1>Deref</h1></a>
<p><code>Deref</code> 是 <code>deref</code> 操作符 <code>*</code> 的 trait，比如 <code>*v</code>。</p>
<p>一般理解，<code>*v</code> 操作，是 <code>&amp;v</code> 的反向操作，即试图由资源的引用获取到资源的拷贝（如果资源类型实现了 <code>Copy</code>），或所有权（资源类型没有实现 <code>Copy</code>）。</p>
<p>Rust 中，本操作符行为可以重载。这也是 Rust 操作符的基本特点。本身没有什么特别的。</p>
<a class="header" href="print.html#a强制隐式转换coercion" id="a强制隐式转换coercion"><h2>强制隐式转换（coercion）</h2></a>
<p><code>Deref</code> 神奇的地方并不在本身 <code>解引</code> 这个意义上，Rust 的设计者在它之上附加了一个特性：<code>强制隐式转换</code>，这才是它神奇之处。</p>
<p>这种隐式转换的规则为：</p>
<p>一个类型为 <code>T</code> 的对象 <code>foo</code>，如果 <code>T: Deref&lt;Target=U&gt;</code>，那么，相关 <code>foo</code> 的某个智能指针或引用（比如 <code>&amp;foo</code>）在应用的时候会自动转换成 <code>&amp;U</code>。</p>
<p>粗看这条规则，貌似有点类似于 <code>AsRef</code>，而跟 <code>解引</code> 似乎风马牛不相及。实际里面有些玄妙之处。</p>
<p>Rust 编译器会在做 <code>*v</code> 操作的时候，自动先把 <code>v</code> 做引用归一化操作，即转换成内部通用引用的形式 <code>&amp;v</code>，整个表达式就变成 <code>*&amp;v</code>。这里面有两种情况：</p>
<ol>
<li>把其它类型的指针（比如在库中定义的，<code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>Cow</code> 等），转成内部标准形式 <code>&amp;v</code>；</li>
<li>把多重 <code>&amp;</code> （比如：<code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>），简化成 <code>&amp;v</code>（通过插入足够数量的 <code>*</code> 进行解引）。</li>
</ol>
<p>所以，它实际上在解引用之前做了一个引用的归一化操作。</p>
<p>为什么要转呢？ 因为编译器设计的能力是，只能够对 <code>&amp;v</code> 这种引用进行解引用。其它形式的它不认识，所以要做引用归一化操作。</p>
<p>使用引用进行过渡也是为了能够防止不必要的拷贝。</p>
<p>下面举一些例子：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(s: &amp;str) {
    // borrow a string for a second
}

// String implements Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();

// therefore, this works:
foo(&amp;owned);
#}</code></pre></pre>
<p>因为 <code>String</code> 实现了 <code>Deref&lt;Target=str&gt;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;

fn foo(s: &amp;str) {
    // borrow a string for a second
}

// String implements Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();
let counted = Rc::new(owned);

// therefore, this works:
foo(&amp;counted);
#}</code></pre></pre>
<p>因为 <code>Rc&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=T&gt;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(s: &amp;[i32]) {
    // borrow a slice for a second
}

// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;
let owned = vec![1, 2, 3];

foo(&amp;owned);
#}</code></pre></pre>
<p>因为 <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=[T]&gt;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo;

impl Foo {
    fn foo(&amp;self) { println!(&quot;Foo&quot;); }
}

let f = &amp;&amp;Foo;

f.foo();
(&amp;f).foo();
(&amp;&amp;f).foo();
(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
#}</code></pre></pre>
<p>上面那几种函数的调用，效果是一样的。</p>
<p><code>coercion</code> 的设计，是 Rust 中仅有的类型隐式转换，设计它的目的，是为了简化程序的书写，让代码不至于过于繁琐。把人从无尽的类型细节中解脱出来，让书写 Rust 代码变成一件快乐的事情。</p>
<a class="header" href="print.html#cow" id="cow"><h1>Cow</h1></a>
<p>直译为奶牛！开玩笑。
<code>Cow</code> 是一个枚举类型，通过 <code>use std::borrow::Cow;</code> 引入。它的定义是 <code>Clone-on-write</code>，即写时克隆。本质上是一个智能指针。</p>
<p>它有两个可选值：</p>
<ul>
<li><code>Borrowed</code>，用于包裹对象的引用（通用引用）；</li>
<li><code>Owned</code>，用于包裹对象的所有者；</li>
</ul>
<p><code>Cow</code> 提供</p>
<ol>
<li>对此对象的不可变访问（比如可直接调用此对象原有的不可变方法）；</li>
<li>如果遇到需要修改此对象，或者需要获得此对象的所有权的情况，<code>Cow</code> 提供方法做克隆处理，并避免多次重复克隆。</li>
</ol>
<p><code>Cow</code> 的设计目的是提高性能（减少复制）同时增加灵活性，因为大部分情况下，业务场景都是读多写少。利用 <code>Cow</code>，可以用统一，规范的形式实现，需要写的时候才做一次对象复制。这样就可能会大大减少复制的次数。</p>
<p>它有以下几个要点需要掌握：</p>
<ol>
<li><code>Cow&lt;T&gt;</code> 能直接调用 <code>T</code> 的不可变方法，因为 <code>Cow</code> 这个枚举，实现了 <code>Deref</code>；</li>
<li>在需要写 <code>T</code> 的时候，可以使用 <code>.to_mut()</code> 方法得到一个具有所有权的值的可变借用；
<ol>
<li>注意，调用 <code>.to_mut()</code> 不一定会产生克隆；</li>
<li>在已经具有所有权的情况下，调用 <code>.to_mut()</code> 有效，但是不会产生新的克隆；</li>
<li>多次调用 <code>.to_mut()</code> 只会产生一次克隆。</li>
</ol>
</li>
<li>在需要写 <code>T</code> 的时候，可以使用 <code>.into_owned()</code> 创建新的拥有所有权的对象，这个过程往往意味着内存拷贝并创建新对象；
<ol>
<li>如果之前 <code>Cow</code> 中的值是借用状态，调用此操作将执行克隆；</li>
<li>本方法，参数是<code>self</code>类型，它会“吃掉”原先的那个对象，调用之后原先的对象的生命周期就截止了，在 <code>Cow</code> 上不能调用多次；</li>
</ol>
</li>
</ol>
<a class="header" href="print.html#a举例" id="a举例"><h2>举例</h2></a>
<p><code>.to_mut()</code> 举例</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::borrow::Cow;

let mut cow: Cow&lt;[_]&gt; = Cow::Owned(vec![1, 2, 3]);

let hello = cow.to_mut();

assert_eq!(hello, &amp;[1, 2, 3]);
#}</code></pre></pre>
<p><code>.into_owned()</code> 举例</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::borrow::Cow;

let cow: Cow&lt;[_]&gt; = Cow::Owned(vec![1, 2, 3]);

let hello = cow.into_owned();

assert_eq!(vec![1, 2, 3], hello);
#}</code></pre></pre>
<p>综合举例</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::borrow::Cow;

fn abs_all(input: &amp;mut Cow&lt;[i32]&gt;) {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // clones into a vector the first time (if not already owned)
            input.to_mut()[i] = -v;
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#cow-在函数返回值上的应用实例" id="cow-在函数返回值上的应用实例"><h2><code>Cow</code> 在函数返回值上的应用实例</h2></a>
<p>题目：写一个函数，过滤掉输入的字符串中的所有空格字符，并返回过滤后的字符串。</p>
<p>对这个简单的问题，不用思考，我们都可以很快写出代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn remove_spaces(input: &amp;str) -&gt; String {
   let mut buf = String::with_capacity(input.len());

   for c in input.chars() {
      if c != ' ' {
         buf.push(c);
      }
   }

   buf
}
#}</code></pre></pre>
<p>设计函数输入参数的时候，我们会停顿一下，这里，用 <code>&amp;str</code> 好呢，还是 <code>String</code> 好呢？思考一番，从性能上考虑，有如下结论：</p>
<ol>
<li>如果使用 <code>String</code>， 则外部在调用此函数的时候，
<ol>
<li>如果外部的字符串是 <code>&amp;str</code>，那么，它需要做一次克隆，才能调用此函数；</li>
<li>如果外部的字符串是 <code>String</code>，那么，它不需要做克隆，就可以调用此函数。但是，一旦调用后，外部那个字符串的所有权就被 <code>move</code> 到此函数中了，外部的后续代码将无法再使用原字符串。</li>
</ol>
</li>
<li>如果使用 <code>&amp;str</code>，则不存在上述两个问题。但可能会遇到生命周期的问题，需要注意。</li>
</ol>
<p>继续分析上面的例子，我们发现，在函数体内，做了一次新字符串对象的生成和拷贝。</p>
<p>让我们来仔细分析一下业务需求。最坏的情况下，如果字符串中没有空白字符，那最好是直接原样返回。这种情况做这样一次对象的拷贝，完全就是浪费了。</p>
<p>于是我们心想改进这个算法。很快，又遇到了另一个问题，返回值是 <code>String</code> 的嘛，我不论怎样，要把 <code>&amp;str</code> 转换成 <code>String</code> 返回，始终都要经历一次复制。于是我们快要放弃了。</p>
<p>好吧，<code>Cow</code>君这时出马了。奶牛君很快写出了如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::borrow::Cow;

fn remove_spaces&lt;'a&gt;(input: &amp;'a str) -&gt; Cow&lt;'a, str&gt; {
    if input.contains(' ') {
        let mut buf = String::with_capacity(input.len());

        for c in input.chars() {
            if c != ' ' {
                buf.push(c);
            }
        }

        return Cow::Owned(buf);
    }

    return Cow::Borrowed(input);
}

#}</code></pre></pre>
<p>完美解决了业务逻辑与返回值类型冲突的问题。本例可细细品味。</p>
<p>外部程序，拿到这个 <code>Cow</code> 返回值后，按照我们上文描述的 <code>Cow</code> 的特性使用就好了。</p>
<a class="header" href="print.html#send-和-sync" id="send-和-sync"><h1>Send 和 Sync</h1></a>
<p><code>std::marker</code> 模块中，有两个 trait：<code>Send</code> 和 <code>Sync</code>，它们与多线程安全相关。</p>
<p>标记为 <code>marker trait</code> 的 trait，它实际就是一种约定，没有方法的定义，也没有关联元素（associated items）。仅仅是一种约定，实现了它的类型必须满足这种约定。一种类型是否加上这种约定，要么是编译器的行为，要么是人工手动的行为。</p>
<p><code>Send</code> 和 <code>Sync</code> 在大部分情况下（针对 Rust 的基础类型和 std 中的大部分类型），会由编译器自动推导出来。对于不能由编译器自动推导出来的类型，要使它们具有 <code>Send</code> 或 <code>Sync</code> 的约定，可以由人手动实现。实现的时候，必须使用 <code>unsafe</code> 前缀，因为 Rust 默认不信任程序员，由程序员自己控制的东西，统统标记为 <code>unsafe</code>，出了问题（比如，把不是线程安全的对象加上 <code>Sync</code> 约定）由程序员自行负责。</p>
<p>它们的定义如下：</p>
<p>如果 <code>T: Send</code>，那么将 <code>T</code> 传到另一个线程中时（按值传送），不会导致数据竞争或其它不安全情况。</p>
<ol>
<li><code>Send</code> 是对象可以安全发送到另一个执行体中；</li>
<li><code>Send</code> 使被发送对象可以和产生它的线程解耦，防止原线程将此资源释放后，在目标线程中使用出错（use after free）。</li>
</ol>
<p>如果 <code>T: Sync</code>，那么将 <code>&amp;T</code> 传到另一个线程中时，不会导致数据竞争或其它不安全情况。</p>
<ol>
<li><code>Sync</code> 是可以被同时多个执行体访问而不出错；</li>
<li><code>Sync</code> 防止的是竞争；</li>
</ol>
<p>推论：</p>
<ol>
<li><code>T: Sync</code> 意味着 <code>&amp;T: Send</code>；</li>
<li><code>Sync + Copy = Send</code>；</li>
<li>当 <code>T: Send</code> 时，可推导出 <code>&amp;mut T: Send</code>；</li>
<li>当 <code>T: Sync</code> 时，可推导出 <code>&amp;mut T: Sync</code>；</li>
<li>当 <code>&amp;mut T: Send</code> 时，不能推导出 <code>T: Send</code>；</li>
</ol>
<p>（注：<code>T</code>, <code>&amp;T</code>, <code>&amp;mut T</code>，<code>Box&lt;T&gt;</code> 等都是不同的类型）</p>
<p>具体的类型：</p>
<ol>
<li>原始类型（比如： u8, f64），都是 <code>Sync</code>，都是 <code>Copy</code>，因此都是 <code>Send</code>；</li>
<li>只包含原始类型的复合类型，都是 <code>Sync</code>，都是 <code>Copy</code>，因此都是 <code>Send</code>；</li>
<li>当 <code>T: Sync</code>，<code>Box&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code> 等集合类型是 <code>Sync</code>；</li>
<li>具有内部可变性的的指针，不是 <code>Sync</code> 的，比如 <code>Cell</code>, <code>RefCell</code>, <code>UnsafeCell</code>；</li>
<li><code>Rc</code> 不是 <code>Sync</code>。因为只要一做 <code>&amp;Rc&lt;T&gt;</code> 操作，就会克隆一个新引用，它会以非原子性的方式修改引用计数，所以是不安全的；</li>
<li>被 <code>Mutex</code> 和 <code>RWLock</code> 锁住的类型 <code>T: Send</code>，是 <code>Sync</code> 的；</li>
<li>原始指针（<code>*mut</code>, <code>*const</code>）既不是 <code>Send</code> 也不是 <code>Sync</code>；</li>
</ol>
<p>Rust 正是通过这两大武器：<code>所有权和生命周期</code> + <code>Send 和 Sync</code>（本质上为类型系统）来为并发编程提供了安全可靠的基础设施。使得程序员可以放心在其上构建稳健的并发模型。这也正是 Rust 的核心设计观的体现：内核只提供最基础的原语，真正的实现能分离出去就分离出去。并发也是如此。</p>
<a class="header" href="print.html#a并发并行多线程编程" id="a并发并行多线程编程"><h1>并发，并行，多线程编程</h1></a>
<p>本章讲解 Rust 中，并发，并行，多线程编程的相关知识。</p>
<a class="header" href="print.html#a并发编程" id="a并发编程"><h1>并发编程</h1></a>
<p>并发是什么？引用Rob Pike的经典描述:</p>
<blockquote>
<p>并发是同一时间应对多件事情的能力</p>
</blockquote>
<p>其实在我们身边就有很多并发的事情，比如一边上课，一边发短信；一边给小孩喂奶，一边看电视，只要你细心留意，就会发现许多类似的事。相应地，在软件的世界里，我们也会发现这样的事，比如一边写博客，一边听音乐；一边看网页，一边下载软件等等。显而易见这样会节约不少时间，干更多的事。然而一开始计算机系统并不能同时处理两件事，这明显满足不了我们的需要，后来慢慢提出了多进程，多线程的解决方案，再后来，硬件也发展到了多核多CPU的地步。在硬件和系统底层对并发的支持也来越多，相应地，各大编程语言也对并发处理提供了强力的支持，作为新兴语言的Rust，自然也支持并发编程。那么本章就将引领大家一览Rust并发编程的相关知识，从线程开始，逐步尝试进行数据交互，同步协作，最后进入到并行实现，一步一步揭开Rust并发编程的神秘面纱。由于本书主要介绍的是Rust语言的使用，所以本章不会对并发编程相关理论知识进行全面而深入地探讨——要真那样地话，一本书都不够介绍的，而是更侧重于介绍用Rust语言怎么实现基本的并发。</p>
<p>首先我们会介绍线程的使用，线程是基本的执行单元，其重要性不言而喻，Rust程序就是由一堆线程组成的。在当今多核多CPU已经普及的情况下，各种大数据分析和并行计算又让线程焕发出了更耀眼的光芒。如果对线程不甚了解，请先参阅操作系统相关的书籍，此处不过多介绍。然后介绍一些在解决并发问题时，需要处理的数据传递和协作的实现，比如消息传递，同步和共享内存。最后简要介绍Rust中并行的实现。</p>
<a class="header" href="print.html#a241-线程创建与结束" id="a241-线程创建与结束"><h2>24.1 线程创建与结束</h2></a>
<p>相信线程对大家而言，一点也不陌生，在当今多CPU多核已经普及的情况下，大数据分析与并行计算都离不开它，几乎所有的语言都支持它，所有的进程都是由一个或多个线程所组成的。既然如此重要，接下来我们就先来看一下在Rust中如何创建一个线程，然后线程又是如何结束的。</p>
<p>Rust对于线程的支持，和<code>C++11</code>一样，都是放在标准库中来实现的，详情请参见<a href="https://doc.rust-lang.org/std/thread/index.html"><code>std::thread</code></a>，好在Rust从一开始就这样做了，不用像C++那样等呀等。在语言层面支持后，开发者就不用那么苦兮兮地处理各平台的移植问题。通过Rust的源码可以看到，<code>std::thread</code>其实就是对不同平台的线程操作的封装，相关API的实现都是调用操作系统的API来实现的，从而提供了线程操作的统一接口。对于我而言，能够这样简单快捷地操作原生线程，身上的压力一下轻了不少。</p>
<a class="header" href="print.html#a创建线程" id="a创建线程"><h3>创建线程</h3></a>
<p>首先，我们看一下在Rust中如何创建一个原生线程(native thread)。<code>std::thread</code>提供了两种创建方式，都非常简单，第一种方式是通过<code>spawn</code>函数来创建，参见下面的示例代码：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    // 创建一个线程
    let new_thread = thread::spawn(move || {
        println!(&quot;I am a new thread.&quot;);
    });
    // 等待新建线程执行完成
    new_thread.join().unwrap();
}
</code></pre></pre>
<p>执行上面这段代码，将会看到下面的输出结果：</p>
<pre><code>I am a new thread.
</code></pre>
<p>就5行代码，少得不能再少，最关键的当然就是调用<code>spawn</code>函数的那行代码。使用这个函数，记得要先<code>use std::thread</code>。注意<code>spawn</code>函数需要一个函数作为参数，且是<code>FnOnce</code>类型，如果已经忘了这种类型的函数，请学习或回顾一下函数和闭包章节。<code>main</code>函数最后一行代码即使不要，也能创建线程（关于<code>join</code>函数的作用和使用在后续小节详解，此处你只要知道它可以用来等待线程执行完成即可），可以去掉或者注释该行代码试试。这样的话，运行结果可能没有任何输出，具体原因后面详解。</p>
<p>接下来我们使用第二种方式创建线程，它比第一种方式稍微复杂一点，因为功能强大一点，可以在创建之前设置线程的名称和堆栈大小，参见下面的代码：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    // 创建一个线程，线程名称为 thread1, 堆栈大小为4k
    let new_thread_result = thread::Builder::new()
                            .name(&quot;thread1&quot;.to_string())
                            .stack_size(4*1024*1024).spawn(move || {
        println!(&quot;I am thread1.&quot;);
    });
    // 等待新创建的线程执行完成
    new_thread_result.unwrap().join().unwrap();
}
</code></pre></pre>
<p>执行上面这段代码，将会看到下面的输出结果：</p>
<pre><code>I am thread1.
</code></pre>
<p>通过和第一种方式的实现代码比较可以发现，这种方式借助了一个<code>Builder</code>类来设置线程名称和堆栈大小，除此之外，<code>Builder</code>的<code>spawn</code>函数的返回值是一个<code>Result</code>，在正式的代码编写中，可不能像上面这样直接<code>unwrap.join</code>，应该判定一下。后面也会有很多类似的演示代码，为了简单说明不会做的很严谨。</p>
<p>以上就是Rust创建原生线程的两种不同方式，示例代码有点然并卵的意味，但是你可以稍加修改，就可以变得更加有用，试试吧。</p>
<a class="header" href="print.html#a线程结束" id="a线程结束"><h3>线程结束</h3></a>
<p>此时，我们已经知道如何创建一个新线程了，创建后，不管你见或者不见，它就在那里，那么它什么时候才会消亡呢？自生自灭，亦或者被干掉？如果接触过一些系统编程，应该知道有些操作系统提供了粗暴地干掉线程的接口，看它不爽，直接干掉，完全可以不理会新建线程的感受。是否感觉很爽，但是Rust不会再让这样爽了，因为<code>std::thread</code>并没有提供这样的接口，为什么呢？如果深入接触过并发编程或多线程编程，就会知道强制终止一个运行中的线程，会出现诸多问题。比如资源没有释放，引起状态混乱，结果不可预期。强制干掉那一刻，貌似很爽地解决问题了，然而可能后患无穷。Rust语言的一大特性就是安全，是绝对不允许这样不负责任的做法的。即使在其他语言提供了类似的接口，也不应该滥用。</p>
<p>那么在Rust中，新建的线程就只能让它自身自灭了吗？其实也有两种方式，首先介绍大家都知道的自生自灭的方式，线程执行体执行完成，线程就结束了。比如上面创建线程的第一种方式，代码执行完<code>println!(&quot;I am a new thread.&quot;);</code>就结束了。 如果像下面这样：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    // 创建一个线程
    let new_thread = thread::spawn(move || {
        loop {
            println!(&quot;I am a new thread.&quot;);
        }
    });
    // 等待新创建的线程执行完成
    new_thread.join().unwrap();
}
</code></pre></pre>
<p>线程就永远都不会结束，如果你用的还是古董电脑，运行上面的代码之前，请做好心理准备。在实际代码中，要时刻警惕该情况的出现（单核情况下，CPU占用率会飙升到100%），除非你是故意为之。</p>
<p>线程结束的另一种方式就是，线程所在进程结束了。我们把上面这个例子稍作修改：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    // 创建一个线程
    thread::spawn(move || {
        loop {
            println!(&quot;I am a new thread.&quot;);
        }
    });

    // 不等待新创建的线程执行完成
    // new_thread.join().unwrap();
}
</code></pre></pre>
<p>同上面的代码相比，唯一的差别在于<code>main</code>函数的最后一行代码被注释了，这样主线程就不用等待新建线程了，在创建线程之后就执行完了，其所在进程也就结束了，从而新建的线程也就结束了。此处，你可能有疑问：为什么一定是进程结束导致新建线程结束？也可能是创建新线程的主线程结束而导致的？事实到底如何，我们不妨验证一下：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    // 创建一个线程
    let new_thread = thread::spawn(move || {
        // 再创建一个线程
        thread::spawn(move || {
            loop {
                println!(&quot;I am a new thread.&quot;);
            }
        })
    });

    // 等待新创建的线程执行完成
    new_thread.join().unwrap();
    println!(&quot;Child thread is finish!&quot;);

    // 睡眠一段时间，看子线程创建的子线程是否还在运行
    thread::sleep_ms(100);
}
</code></pre></pre>
<p>这次我们在新建线程中还创建了一个线程，从而第一个新建线程是父线程，主线程在等待该父线程结束后，主动睡眠一段时间。这样做有两个目的，一是确保整个程序不会马上结束；二是如果子线程还存在，应该会获得执行机会，以此来检验子线程是否还在运行，下面是输出结果：</p>
<pre><code>Child thread is finish!
I am a new thread.
I am a new thread.
......
</code></pre>
<p>结果表明，在父线程结束后，其创建的子线程还活着，这并不会因为父线程结束而结束。这个还是比较符合自然规律的，要不然真会断子绝孙，人类灭绝。所以导致线程结束的第二种方式，是结束其所在进程。到此为止，我们已经把线程的创建和结束都介绍完了，那么接下来我们会介绍一些更有趣的东西。但是在此之前，请先考虑一下下面的练习题。</p>
<p><strong>练习题：</strong></p>
<p>有一组学生的成绩，我们需要对它们评分，90分及以上是A，80分及以上是B，70分及以上是C，60分及以上为D,60分以下为E。现在要求用Rust语言编写一个程序来评分，且评分由新建的线程来做，最终输出每个学生的学号，成绩，评分。学生成绩单随机产生，学生人数100位，成绩范围为[0,100]，学号依次从1开始，直到100。</p>
<a class="header" href="print.html#a消息传递" id="a消息传递"><h2>消息传递</h2></a>
<p>稍加考虑，上一节的练习题其实是不完整的，它只是评分系统中的一环，一个评分系统是需要先把信息从数据库或文件中读取出来，然后才是评分，最后还需要把评分结果再保存到数据库或文件中去。如果一步一步串行地做这三个步骤，是完全没有问题的。那么我们是否可以用三个线程来分别做这三个步骤呢？上一节练习题我们已经用了一个线程来实现评分，那么我们是否也可以再用一个线程来读取成绩，再用另个线程来实现保存呢？ 如果能这样的话，那么我们就可以利用上多核多cpu的优势，加快整个评分的效率。既然在此提出这个问题，答案就很明显了。问题在于我们要怎么在Rust中来实现，关键在于三个线程怎么交换信息，以达到串行的逻辑处理顺序？</p>
<p>为了解决这个问题，下面将介绍一种Rust在标准库中支持的消息传递技术。<strong>消息传递</strong>是并发模型里面大家比较推崇的模式，不仅仅是因为使用起来比较简单，关键还在于它可以减少数据竞争，提高并发效率，为此值得深入学习。Rust是通过一个叫做通道(<code>channel</code>)的东西来实现这种模式的，下面直接进入主题。</p>
<a class="header" href="print.html#a初试通道channel" id="a初试通道channel"><h3>初试通道(channel)</h3></a>
<p>Rust的通道(<code>channel</code>)可以把一个线程的消息(数据)传递到另一个线程，从而让信息在不同的线程中流动，从而实现协作。详情请参见<a href="https://doc.rust-lang.org/std/sync/mpsc/index.html"><code>std::sync::mpsc</code></a>。通道的两端分别是发送者(<code>Sender</code>)和接收者(<code>Receiver</code>)，发送者负责从一个线程发送消息，接收者则在另一个线程中接收该消息。下面我们来看一个简单的例子：</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    // 创建一个通道
    let (tx, rx): (mpsc::Sender&lt;i32&gt;, mpsc::Receiver&lt;i32&gt;) = 
        mpsc::channel();

    // 创建线程用于发送消息
    thread::spawn(move || {
        // 发送一个消息，此处是数字id
        tx.send(1).unwrap();
    });

    // 在主线程中接收子线程发送的消息并输出
    println!(&quot;receive {}&quot;, rx.recv().unwrap());
}
</code></pre></pre>
<p>程序说明参见代码中的注释，程序执行结果为：</p>
<pre><code>receive 1
</code></pre>
<p>结果表明<code>main</code>所在的主线程接收到了新建线程发送的消息，用Rust在线程间传递消息就是这么简单！</p>
<p>虽然简单，但使用过其他语言就会知道，通道有多种使用方式，且比较灵活，为此我们需要进一步考虑关于<code>Rust</code>的<code>Channel</code>的几个问题：</p>
<ol>
<li>通道能保证消息的顺序吗？是否先发送的消息，先接收？</li>
<li>通道能缓存消息吗？如果能的话能缓存多少？</li>
<li>通道的发送者和接收者支持N:1，1:N，N:M模式吗？</li>
<li>通道能发送任何数据吗？</li>
<li>发送后的数据，在线程中继续使用没有问题吗？</li>
</ol>
<p>让我们带着这些问题和思考进入下一个小节，那里有相关的答案。</p>
<a class="header" href="print.html#a消息类型" id="a消息类型"><h3>消息类型</h3></a>
<p>上面的例子中，我们传递的消息类型为<code>i32</code>，除了这种类型之外，是否还可以传递更多的原始类型，或者更复杂的类型，和自定义类型？下面我们尝试发送一个更复杂的<code>Rc</code>类型的消息：</p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;
use std::sync::mpsc;
use std::thread;
use std::rc::Rc;

pub struct Student {
    id: u32
}

impl fmt::Display for Student {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;student {}&quot;, self.id)
    }
}

fn main() {
    // 创建一个通道
    let (tx, rx): (mpsc::Sender&lt;Rc&lt;Student&gt;&gt;, mpsc::Receiver&lt;Rc&lt;Student&gt;&gt;) = 
        mpsc::channel();

    // 创建线程用于发送消息
    thread::spawn(move || {
        // 发送一个消息，此处是数字id
        tx.send(Rc::new(Student{
            id: 1,
        })).unwrap();
    });

    // 在主线程中接收子线程发送的消息并输出
    println!(&quot;receive {}&quot;, rx.recv().unwrap());
}
</code></pre></pre>
<p>编译代码，奇迹没有出现，编译时错误，错误提示：</p>
<pre><code>error: the trait `core::marker::Send` is not 
implemented for the type `alloc::rc::Rc&lt;Student&gt;` [E0277]
note: `alloc::rc::Rc&lt;Student&gt;` cannot be sent between threads safely
</code></pre>
<p>看来并不是所有类型的消息都可以通过通道发送，消息类型必须实现<code>marker trait Send</code>。Rust之所以这样强制要求，主要是为了解决并发安全的问题，再一次强调，<strong>安全</strong>是Rust考虑的重中之重。如果一个类型是<code>Send</code>，则表明它可以在线程间安全的转移所有权(<code>ownership</code>)，当所有权从一个线程转移到另一个线程后，同一时间就只会存在一个线程能访问它，这样就避免了数据竞争，从而做到线程安全。<code>ownership</code>的强大又一次显示出来了。通过这种做法，在编译时即可要求所有的代码必须满足这一约定，这种方式方法值得借鉴，<code>trait</code>也是非常强大。</p>
<p>看起来问题得到了完美的解决，然而由于<code>Send</code>本身是一个不安全的<code>marker trait</code>，并没有实际的<code>API</code>，所以实现它很简单，但没有强制保障，就只能靠开发者自己约束，否则还是可能引发并发安全问题。对于这一点，也不必太过担心，因为Rust中已经存在的类，都已经实现了<code>Send</code>或<code>!Send</code>，我们只要使用就行。<code>Send</code>是一个默认应用到所有Rust已存在类的trait，所以我们用<code>!Send</code>显式标明该类没有实现<code>Send</code>。目前几乎所有的原始类型都是<code>Send</code>，例如前面例子中发送的<code>i32</code>。对于开发者而言，我们可能会更关心哪些是非<code>Send</code>，也就是实现了<code>!Send</code>，因为这会导致线程不安全。更全面的信息参见<a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code>官网API</a>。</p>
<p>对于不是<code>Send</code>的情况（<code>!Send</code>），大致分为两类：</p>
<ol>
<li>原始指针，包括<code>*mut T</code>和<code>*const T</code>，因为不同线程通过指针都可以访问数据，从而可能引发线程安全问题。</li>
<li><code>Rc</code>和<code>Weak</code>也不是，因为引用计数会被共享，但是并没有做并发控制。</li>
</ol>
<p>虽然有这些<code>!Send</code>的情况，但是逃不过编译器的火眼金睛，只要你错误地使用了消息类型，编译器都会给出类似于上面的错误提示。我们要担心的不是这些，因为错误更容易出现在新创建的自定义类，有下面两点需要注意：</p>
<ol>
<li>
<p>如果自定义类的所有字段都是<code>Send</code>，那么这个自定义类也是<code>Send</code>。
反之，如果有一个字段是<code>!Send</code>，那么这个自定义类也是<code>!Send</code>。
如果类的字段存在递归包含的情况，按照该原则以此类推来推论类是<code>Send</code>还是<code>!Send</code>。</p>
</li>
<li>
<p>在为一个自定义类实现<code>Send</code>或者<code>!Send</code>时，必须确保符合它的约定。</p>
</li>
</ol>
<p>到此，消息类型的相关知识已经介绍完了，说了这么久，也该让大家自己练习一下了：请实现一个自定义类，该类包含一个Rc字段，让这个类变成可以在通道中发送的消息类型。</p>
<a class="header" href="print.html#a异步通道channel" id="a异步通道channel"><h3>异步通道(Channel)</h3></a>
<p>在粗略地尝试通道之后，是时候更深入一下了。Rust的标准库其实提供了两种类型的通道：异步通道和同步通道。上面的例子都是使用的异步通道，为此这一小节我们优先进一步介绍异步通道，后续再介绍同步通道。异步通道指的是：不管接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞。为了验证这一点，我们尝试多增加一个线程来发送消息：</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;
use std::thread;

// 线程数量
const THREAD_COUNT :i32 = 2;

fn main() {
    // 创建一个通道
    let (tx, rx): (mpsc::Sender&lt;i32&gt;, mpsc::Receiver&lt;i32&gt;) = mpsc::channel();

    // 创建线程用于发送消息
    for id in 0..THREAD_COUNT {
        // 注意Sender是可以clone的，这样就可以支持多个发送者
        let thread_tx = tx.clone();
        thread::spawn(move || {
            // 发送一个消息，此处是数字id
            thread_tx.send(id + 1).unwrap();
            println!(&quot;send {}&quot;, id + 1);
        });
    }

    thread::sleep_ms(2000);
    println!(&quot;wake up&quot;);
    // 在主线程中接收子线程发送的消息并输出
    for _ in 0..THREAD_COUNT {
        println!(&quot;receive {}&quot;, rx.recv().unwrap());
    }
}
</code></pre></pre>
<p>运行结果:</p>
<pre><code>send 1
send 2
wake up
receive 1
receive 2
</code></pre>
<p>在代码中，我们故意让<code>main</code>所在的主线程睡眠2秒，从而让发送者所在线程优先执行，通过结果可以发现，发送者发送消息时确实没有阻塞。还记得在前面提到过很多关于通道的问题吗？从这个例子里面还发现什么没？除了不阻塞之外，我们还能发现另外的三个特征：</p>
<p>1.通道是可以同时支持多个发送者的，通过<code>clone</code>的方式来实现。
这类似于<code>Rc</code>的共享机制。
其实从<code>Channel</code>所在的库名<code>std::sync::mpsc</code>也可以知道这点。
因为<code>mpsc</code>就是多生产者单消费者(Multiple Producers Single Consumer)的简写。
可以有多个发送者,但只能有一个接收者，即支持的N:1模式。</p>
<p>2.异步通道具备消息缓存的功能，因为1和2是在没有接收之前就发了的，在此之后还能接收到这两个消息。</p>
<p>那么通道到底能缓存多少消息？在理论上是无穷的，尝试一下便知：</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    // 创建一个通道
    let (tx, rx): (mpsc::Sender&lt;i32&gt;, mpsc::Receiver&lt;i32&gt;) = mpsc::channel();

    // 创建线程用于发送消息
    let new_thread = thread::spawn(move || {
        // 发送无穷多个消息
        let mut i = 0;
        loop {
            i = i + 1;
            // add code here
            println!(&quot;send {}&quot;, i);
            match tx.send(i) {
                Ok(_) =&gt; (),
                Err(e) =&gt; {
                    println!(&quot;send error: {}, count: {}&quot;, e, i);
                    return;
                },
            }
        }
    });

    // 在主线程中接收子线程发送的消息并输出
    new_thread.join().unwrap();
    println!(&quot;receive {}&quot;, rx.recv().unwrap());
}
</code></pre></pre>
<p>最后的结果就是耗费内存为止。</p>
<p>3.消息发送和接收的顺序是一致的，满足先进先出原则。</p>
<p>上面介绍的内容大多是关于发送者和通道的，下面开始考察一下接收端。通过上面的几个例子，细心一点的可能已经发现接收者的<code>recv</code>方法应该会阻塞当前线程，如果不阻塞，在多线程的情况下，发送的消息就不可能接收完全。所以没有发送者发送消息，那么接收者将会一直等待，这一点要谨记。在某些场景下，一直等待是符合实际需求的。但某些情况下并不需一直等待，那么就可以考虑释放通道，只要通道释放了，<code>recv</code>方法就会立即返回。</p>
<p>异步通道的具有良好的灵活性和扩展性，针对业务需要，可以灵活地应用于实际项目中，实在是必备良药！</p>
<a class="header" href="print.html#a同步通道" id="a同步通道"><h3>同步通道</h3></a>
<p>同步通道在使用上同异步通道一样，接收端也是一样的，唯一的区别在于发送端，我们先来看下面的例子：</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    // 创建一个同步通道
    let (tx, rx): (mpsc::SyncSender&lt;i32&gt;, mpsc::Receiver&lt;i32&gt;) = mpsc::sync_channel(0);

    // 创建线程用于发送消息
    let new_thread = thread::spawn(move || {
        // 发送一个消息，此处是数字id
        println!(&quot;before send&quot;);
        tx.send(1).unwrap();
        println!(&quot;after send&quot;);
    });

    println!(&quot;before sleep&quot;);
    thread::sleep_ms(5000);
    println!(&quot;after sleep&quot;);
    // 在主线程中接收子线程发送的消息并输出
    println!(&quot;receive {}&quot;, rx.recv().unwrap());
    new_thread.join().unwrap();
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>before sleep
before send
after sleep
receive 1
after send
</code></pre>
<p>除了多了一些输出代码之外，上面这段代码几乎和前面的异步通道的没有什么区别，唯一不同的在于创建同步通道的那行代码。同步通道是<code>sync_channel</code>，对应的发送者也变成了<code>SyncSender</code>。为了显示出同步通道的区别，故意添加了一些打印。和异步通道相比，存在两点不同：</p>
<ol>
<li>同步通道是需要指定缓存的消息个数的，但需要注意的是，最小可以是0，表示没有缓存。</li>
<li>发送者是会被阻塞的。当通道的缓存队列不能再缓存消息时，发送者发送消息时，就会被阻塞。</li>
</ol>
<p>对照上面两点和运行结果来分析，由于主线程在接收消息前先睡眠了，从而子线程这个时候会被调度执行发送消息，由于通道能缓存的消息为0，而这个时候接收者还没有接收，所以<code>tx.send(1).unwrap()</code>就会阻塞子线程，直到主线程接收消息，即执行<code>println!(&quot;receive {}&quot;, rx.recv().unwrap());</code>。运行结果印证了这点，要是没阻塞，那么在<code>before send</code>之后就应该是<code>after send</code>了。</p>
<p>相比较而言，异步通道更没有责任感一些，因为消息发送者一股脑的只管发送，不管接收者是否能快速处理。这样就可能出现通道里面缓存大量的消息得不到处理，从而占用大量的内存，最终导致内存耗尽。而同步通道则能避免这种问题，把接受者的压力能传递到发送者，从而一直传递下去。</p>
<a class="header" href="print.html#a共享内存" id="a共享内存"><h2>共享内存</h2></a>
<p>在消息传递之外，还存在一种广为人知的并发模型，那就是共享内存。其实如果不能共享内存，消息传递也是不能在不同的线程间传递消息，也谈不上在不同的线程间等待和通知了。共享内存是这一切得以发生的基础。如果查看源码，你会发现消息传递的内部实现就是借用了共享内存机制。相对于消息传递而言，共享内存会有更多的竞争，但是不用进行多次拷贝，在某些情况下，也需要考虑使用这种方式来处理。在Rust中，能共享内存的情况，主要体现在下面两个方面：</p>
<a class="header" href="print.html#static" id="static"><h3>static</h3></a>
<p>Rust语言中也存在static变量，其生命周期是整个应用程序，并且在内存中某个固定地址处只存在一份实例。所有线程都能够访问到它。这种方式也是最简单和直接的共享方式。几乎大多数语言都存在这种机制。下面简单看一下Rust中多个线程访问static变量的用法：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

static VAR: i32 = 5;

fn main() {
    // 创建一个新线程
    let new_thread = thread::spawn(move|| {
        println!(&quot;static value in new thread: {}&quot;, VAR);
    });

    // 等待新线程先运行
    new_thread.join().unwrap();
    println!(&quot;static value in main thread: {}&quot;, VAR);
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>static value in new thread: 5
static value in main thread: 5
</code></pre>
<p><code>VAR</code>这个<code>static</code>变量在各线程中可以直接使用，非常方便。当然上面只是读取，那么要修改也是很简单的：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

static mut VAR: i32 = 5;

fn main() {
    // 创建一个新线程
    let new_thread = thread::spawn(move|| {
        unsafe {
            println!(&quot;static value in new thread: {}&quot;, VAR);
            VAR = VAR + 1;
        }
    });

    // 等待新线程先运行
    new_thread.join().unwrap();
    unsafe {
        println!(&quot;static value in main thread: {}&quot;, VAR);
    }
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>static value in new thread: 5
static value in main thread: 6
</code></pre>
<p>从结果来看<code>VAR</code>的值变了，从代码上来看，除了在<code>VAR</code>变量前面加了<code>mut</code>关键字外，更加明显的是在使用<code>VAR</code>的地方都添加了<code>unsafe</code>代码块。为什么？所有的线程都能访问<code>VAR</code>，且它是可以被修改的，自然就是不安全的。上面的代码比较简单，同一时间只会有一个线程读写<code>VAR</code>，不会有什么问题，所以用<code>unsafe</code>来标记就可以。如果是更多的线程，还是请使用接下来要介绍的同步机制来处理。</p>
<p>static如此，那const呢？ const会在编译时内联到代码中，所以不会存在某个固定的内存地址上，也不存在可以修改的情况，并不是内存共享的。</p>
<a class="header" href="print.html#a堆" id="a堆"><h3>堆</h3></a>
<p>由于现代操作系统的设计，线程寄生于进程，可以共享进程的资源，如果要在各个线程中共享一个变量，那么除了上面的static，还有就是把变量保存在堆上了。当然Rust也不例外，遵从这一设计。只是我们知道Rust在安全性上肯定又会做一些考量，从而在语言设计和使用上稍有不同。</p>
<p>为了在堆上分配空间，Rust提供了<code>std::boxed::Box</code>，由于堆的特点，存活时间比较长，所以除了我们这个地方介绍的线程间共享外，还有其他的用处，此处不详细说明，若不甚了解，请学习或回顾<strong>堆、栈与Box</strong>章节的介绍。下面我们来看一下如何在多个线程间访问<code>Box</code>创建的变量：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::Arc;

fn main() {
    let var : Arc&lt;i32&gt; = Arc::new(5);
    let share_var = var.clone();

    // 创建一个新线程
    let new_thread = thread::spawn(move|| {
        println!(&quot;share value in new thread: {}, address: {:p}&quot;, share_var, &amp;*share_var);
    });

    // 等待新建线程先执行
    new_thread.join().unwrap();
    println!(&quot;share value in main thread: {}, address: {:p}&quot;, var, &amp;*var);
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>share value in new thread: 5, address: 0x2825070
share value in main thread: 5, address: 0x2825070
</code></pre>
<p>你可能会觉得很奇怪，上面怎么没有看到Box创建的变量啊，这明明就是<code>Arc</code>的使用呀？<code>Box</code>创建的变量要想在多个线程中安全使用，我们还需要实现很多功能才行，需要是<code>Sync</code>，而<code>Arc</code>正是利用<code>Box</code>来实现的一个通过引用计数来共享状态的包裹类。下面引用一段<code>Arc::new</code>的源码即可看出它是通过<code>Box</code>来实现的：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn new(data: T) -&gt; Arc&lt;T&gt; {
    // Start the weak pointer count as 1 which is the weak pointer that's
    // held by all the strong pointers (kinda), see std/rc.rs for more info
    let x: Box&lt;_&gt; = box ArcInner {
        strong: atomic::AtomicUsize::new(1),
        weak: atomic::AtomicUsize::new(1),
        data: data,
    };
    Arc { _ptr: unsafe { NonZero::new(Box::into_raw(x)) } }
}
#}</code></pre></pre>
<p>通过上面的运行结果，我们也可以发现新建线程和主线程中打印的<code>address</code>是一样的，说明状态确实是在同一个内存地址处。</p>
<p>如果<code>Box</code>在堆上分配的资源仅在一个线程中使用，那么释放时，就非常简单，使用完，及时释放即可。如果是要在多个线程中使用，就需要面临两个关键问题：</p>
<ol>
<li>资源何时释放？</li>
<li>线程如何安全的并发修改和读取？</li>
</ol>
<p>由于上面两个问题的存在，这就是为什么我们不能直接用<code>Box</code>变量在线程中共享的原因，可以看出来，共享内存比消息传递机制似乎要复杂许多。Rust用了引用计数的方式来解决第一个问题，在标准库中提供了两个包裹类，除了上面一个用于多线程的<code>std::sync::Arc</code>之外，还有一个不能用于多线程的<code>std::rc::Rc</code>。在使用时，可以根据需要进行选择。如果你一不小心把<code>std::rc::Rc</code>用于多线程中，编译器会毫不客气地纠正你的。</p>
<p>关于上面的第二个问题，Rust语言及标准库提供了一系列的同步手段来解决。下面的章节我们将详细讲解这些方式和用法。</p>
<a class="header" href="print.html#a同步" id="a同步"><h2>同步</h2></a>
<p>同步指的是线程之间的协作配合，以共同完成某个任务。在整个过程中，需要注意两个关键点：一是共享资源的访问， 二是访问资源的顺序。通过前面的介绍，我们已经知道了如何让多个线程访问共享资源，但并没介绍如何控制访问顺序，才不会出现错误。如果两个线程同时访问同一内存地址的数据，一个写，一个读，如果不加控制，写线程只写了一半，读线程就开始读，必然读到的数据是错误的，不可用的，从而造成程序错误，这就造成了并发安全问题，为此我们必须要有一套控制机制来避免这样的事情发生。就好比两个人喝一瓶可乐，只有一根吸管，那肯定也得商量出一个规则，才能相安无事地都喝到可乐。本节就将具体介绍在Rust中，我们要怎么做，才能解决这个问题。</p>
<p>继续上面喝可乐的例子，一人一口的方式，就是一种解决方案，只要不是太笨，几乎都能想到这个方案。具体实施时，A在喝的时候，B一直在旁边盯着，要是A喝完一口，B马上拿过来喝，此时A肯定也是在旁边盯着。在现实生活中，这样的示例比比皆是。细想一下，貌似同步中都可能涉及到等待。诸葛先生在万事具备，只欠东风时，也只能等，因为条件不成熟啊。依照这个逻辑，在操作系统和各大编程语言中，几乎都支持当前线程等待，当然Rust也不例外。</p>
<a class="header" href="print.html#a等待" id="a等待"><h3>等待</h3></a>
<p>Rust中线程等待和其他语言在机制上并无差异，大致有下面几种：</p>
<ul>
<li>等待一段时间后，再接着继续执行。看起来就像一个人工作累了，休息一会再工作。通过调用相关的API可以让当前线程暂停执行进入睡眠状态，此时调度器不会调度它执行，等过一段时间后，线程自动进入就绪状态，可以被调度执行，继续从之前睡眠时的地方执行。对应的API有<code>std::thread::sleep</code>，<code>std::thread::sleep_ms</code>，<code>std::thread::park_timeout</code>，<code>std::thread::park_timeout_ms</code>，还有一些类似的其他API，由于太多，详细信息就请参见官网<a href="https://doc.rust-lang.org/stable/std/thread/index.html"><code>std::thread</code></a>。</li>
<li>这一种方式有点特殊，时间非常短，就一个时间片，当前线程自己主动放弃当前时间片的调度，让调度器重新选择线程来执行，这样就把运行机会给了别的线程，但是要注意的是，如果别的线程没有更好的理由执行，当然最后执行机会还是它的。在实际的应用业务中，比如生产者制造出一个产品后，可以放弃一个时间片，让消费者获得执行机会，从而快速地消费才生产的产品。这样的控制粒度非常小，需要合理使用，如果需要连续放弃多个时间片，可以借用循环实现。对应的API是<code>std::thread::yield_now</code>，详细信息参见官网<a href="https://doc.rust-lang.org/stable/std/thread/index.html"><code>std::thread</code></a>。</li>
<li>1和2的等待都无须其他线程的协助，即可在一段时间后继续执行。最后我们还遇到一种等待，是需要其他线程参与，才能把等待的线程叫醒，否则，线程会一直等待下去。好比一个女人，要是没有遇到一个男人，就永远不可能摆脱单身的状态。相关的API包括<code>std::thread::JoinHandle::join</code>，<code>std::thread::park</code>，<code>std::sync::Mutex::lock</code>等，还有一些同步相关的类的API也会导致线程等待。详细信息参见官网<a href="https://doc.rust-lang.org/stable/std/thread/index.html"><code>std::thread</code></a>和<a href="https://doc.rust-lang.org/stable/std/sync/index.html"><code>std::sync</code></a>。</li>
</ul>
<p>第一种和第三种等待方式，其实我们在上面的介绍中，都已经遇到过了，它们也是使用的最多的两种方式。在此，也可以回过头去看看前面的使用方式和使用效果，结合自己的理解，做一些简单的练习。</p>
<p>毫无疑问，第三种方式稍显复杂，要将等待的线程叫醒，必然基于一定的规则，比如早上7点必须起床，那么就定一个早上7点的闹钟，到时间了就响，没到时间别响。不管基于什么规则，要触发叫醒这个事件，就肯定是某个条件已经达成了。基于这样的逻辑，在操作系统和编程语言中，引入了一种叫着<strong>条件变量</strong>的东西。可以模拟现实生活中的闹钟的行为，条件达成就通知等待条件的线程。Rust的条件变量就是<code>std::sync::Condvar</code>，详情参见官网<a href="https://doc.rust-lang.org/std/sync/struct.Condvar.html">条件变量</a>。但是通知也并不只是条件变量的专利，还有其他的方式也可以触发通知，下面我们就来瞧一瞧。</p>
<a class="header" href="print.html#a通知" id="a通知"><h3>通知</h3></a>
<p>看是简单的通知，在编程时也需要注意以下几点：</p>
<ul>
<li>通知必然是因为有等待，所以通知和等待几乎都是成对出现的，比如<code>std::sync::Condvar::wait</code>和<code>std::sync::Condvar::notify_one</code>，<code>std::sync::Condvar::notify_all</code>。</li>
<li>等待所使用的对象，与通知使用的对象是同一个对象，从而该对象需要在多个线程之间共享，参见下面的例子。</li>
<li>除了<code>Condvar</code>之外，其实<em>锁</em>也是具有自动通知功能的，当持有锁的线程释放锁的时候，等待锁的线程就会自动被唤醒，以抢占锁。关于锁的介绍，在下面有详解。</li>
<li>通过条件变量和锁，还可以构建更加复杂的自动通知方式，比如<code>std::sync::Barrier</code>。</li>
<li>通知也可以是1:1的，也可以是1:N的，<code>Condvar</code>可以控制通知一个还是N个，而锁则不能控制，只要释放锁，所有等待锁的其他线程都会同时醒来，而不是只有最先等待的线程。</li>
</ul>
<p>下面我们分析一个简单的例子：</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Arc, Mutex, Condvar};
use std::thread;

fn main() {

    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    // 创建一个新线程
    thread::spawn(move|| {
        let &amp;(ref lock, ref cvar) = &amp;*pair2;
        let mut started = lock.lock().unwrap();
        *started = true;
        cvar.notify_one();
        println!(&quot;notify main thread&quot;);
    });

    // 等待新线程先运行
    let &amp;(ref lock, ref cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        println!(&quot;before wait&quot;);
        started = cvar.wait(started).unwrap();
        println!(&quot;after wait&quot;);
    }
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>before wait
notify main thread
after wait
</code></pre>
<p>这个例子展示了如何通过条件变量和锁来控制新建线程和主线程的同步，让主线程等待新建线程执行后，才能继续执行。从结果来看，功能上是实现了。对于上面这个例子，还有下面几点需要说明：</p>
<ul>
<li><code>Mutex</code>是Rust中的一种锁。</li>
<li><code>Condvar</code>需要和<code>Mutex</code>一同使用，因为有<code>Mutex</code>保护，<code>Condvar</code>并发才是安全的。</li>
<li><code>Mutex::lock</code>方法返回的是一个<code>MutexGuard</code>，在离开作用域的时候，自动销毁，从而自动释放锁，从而避免锁没有释放的问题。</li>
<li><code>Condvar</code>在等待时，时会释放锁的，被通知唤醒时，会重新获得锁，从而保证并发安全。</li>
</ul>
<p>到此，你应该对锁比较感兴趣了，为什么需要锁？锁存在的目的就是为了保证资源在同一个时间，能有序地被访问，而不会出现异常数据。但其实要做到这一点，也并不是只有锁，包括锁在内，主要涉及两种基本方式：</p>
<a class="header" href="print.html#a原子类型" id="a原子类型"><h3>原子类型</h3></a>
<p>原子类型是最简单的控制共享资源访问的一种机制，相比较于后面将介绍的锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，从硬件到操作系统，到各个语言，基本都支持。在标准库<code>std::sync::atomic</code>中，你将在里面看到Rust现有的原子类型，包括<code>AtomicBool</code>，<code>AtomicIsize</code>，<code>AtomicPtr</code>，<code>AtomicUsize</code>。这4个原子类型基本能满足百分之九十的共享资源安全访问的需要。下面我们就用原子类型，结合共享内存的知识，来展示一下一个线程修改，一个线程读取的情况：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

fn main() {
    let var : Arc&lt;AtomicUsize&gt; = Arc::new(AtomicUsize::new(5));
    let share_var = var.clone();

    // 创建一个新线程
    let new_thread = thread::spawn(move|| {
        println!(&quot;share value in new thread: {}&quot;, share_var.load(Ordering::SeqCst));
        // 修改值
        share_var.store(9, Ordering::SeqCst);
    });

    // 等待新建线程先执行
    new_thread.join().unwrap();
    println!(&quot;share value in main thread: {}&quot;, var.load(Ordering::SeqCst));
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>share value in new thread: 5
share value in main thread: 9
</code></pre>
<p>结果表明新建线程成功的修改了值，并在主线程中获取到了最新值，你也可以尝试使用其他的原子类型。此处我们可以思考一下，如果我们用<code>Arc::new(*mut Box&lt;u32&gt;)</code>是否也可以做到？ 为什么？ 思考后，大家将体会到Rust在多线程安全方面做的有多么的好。除了原子类型，我们还可以使用锁来实现同样的功能。</p>
<a class="header" href="print.html#a锁" id="a锁"><h3>锁</h3></a>
<p>在多线程中共享资源，除了原子类型之外，还可以考虑用锁来实现。在操作之前必须先获得锁，一把锁同时只能给一个线程，这样能保证同一时间只有一个线程能操作共享资源，操作完成后，再释放锁给等待的其他线程。在Rust中<code>std::sync::Mutex</code>就是一种锁。下面我们用<code>Mutex</code>来实现一下上面的原子类型的例子：</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let var : Arc&lt;Mutex&lt;u32&gt;&gt; = Arc::new(Mutex::new(5));
    let share_var = var.clone();

    // 创建一个新线程
    let new_thread = thread::spawn(move|| {
        let mut val = share_var.lock().unwrap();
        println!(&quot;share value in new thread: {}&quot;, *val);
        // 修改值
        *val = 9;
    });

    // 等待新建线程先执行
    new_thread.join().unwrap();
    println!(&quot;share value in main thread: {}&quot;, *(var.lock().unwrap()));
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>share value in new thread: 5
share value in main thread: 9
</code></pre>
<p>结果都一样，看来用<code>Mutex</code>也能实现，但如果从效率上比较，原子类型会更胜一筹。暂且不论这点，我们从代码里面看到，虽然有<code>lock</code>，但是并么有看到有类似于<code>unlock</code>的代码出现，并不是不需要释放锁，而是Rust为了提高安全性，已然在<code>val</code>销毁的时候，自动释放锁了。同时我们发现，为了修改共享的值，开发者必须要调用<code>lock</code>才行，这样就又解决了一个安全问题。不得不再次赞叹一下Rust在多线程方面的安全性做得真是太好了。如果是其他语言，我们要做到安全，必然得自己来实现这些。</p>
<p>为了保障锁使用的安全性问题，Rust做了很多工作，但从效率来看还不如原子类型，那么锁是否就没有存在的价值了？显然事实不可能是这样的，既然存在，那必然有其价值。它能解决原子类型锁不能解决的那百分之十的问题。我们再来看一下之前的一个例子：</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Arc, Mutex, Condvar};
use std::thread;

fn main() {

    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    // 创建一个新线程
    thread::spawn(move|| {
        let &amp;(ref lock, ref cvar) = &amp;*pair2;
        let mut started = lock.lock().unwrap();
        *started = true;
        cvar.notify_one();
        println!(&quot;notify main thread&quot;);
    });

    // 等待新线程先运行
    let &amp;(ref lock, ref cvar) = &amp;*pair;
    let mut started = lock.lock().unwrap();
    while !*started {
        println!(&quot;before wait&quot;);
        started = cvar.wait(started).unwrap();
        println!(&quot;after wait&quot;);
    }
}
</code></pre></pre>
<p>代码中的<code>Condvar</code>就是条件变量，它提供了<code>wait</code>方法可以主动让当前线程等待，同时提供了<code>notify_one</code>方法，让其他线程唤醒正在等待的线程。这样就能完美实现顺序控制了。看起来好像条件变量把事都做完了，要<code>Mutex</code>干嘛呢？为了防止多个线程同时执行条件变量的<code>wait</code>操作，因为条件变量本身也是需要被保护的，这就是锁能做，而原子类型做不到的地方。</p>
<p>在Rust中，<code>Mutex</code>是一种独占锁，同一时间只有一个线程能持有这个锁。这种锁会导致所有线程串行起来，这样虽然保证了安全，但效率并不高。对于写少读多的情况来说，如果在没有写的情况下，都是读取，那么应该是可以并发执行的，为了达到这个目的，几乎所有的编程语言都提供了一种叫读写锁的机制，Rust中也存在，叫<a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>std::sync::RwLock</code></a>，在使用上同<code>Mutex</code>差不多，在此就留给大家自行练习了。</p>
<p>同步是多线程编程的永恒主题，Rust已经为我们提供了良好的编程范式，并强加检查，即使你之前没有怎么接触过，用Rust也能编写出非常安全的多线程程序。</p>
<a class="header" href="print.html#a并行" id="a并行"><h2>并行</h2></a>
<p>理论上并行和语言并没有什么关系，所以在理论上的并行方式，都可以尝试用Rust来实现。本小节不会详细全面地介绍具体的并行理论知识，只介绍用Rust如何来实现相关的并行模式。</p>
<p>Rust的一大特点是，可以保证“线程安全”。而且，没有性能损失。更有意思的是，Rust编译器实际上只有<code>Send</code> <code>Sync</code>等基本抽象，而对“线程” “锁” “同步” 等基本的并行相关的概念一无所知，这些概念都是由库实现的。这意味着Rust实现并行编程可以有比较好的扩展性，可以很轻松地用库来支持那些常见的并行编程模式。
下面，我们以一个例子来演示一下，Rust如何将线程安全/执行高效/使用简单结合起来的。</p>
<p>在图形编程中，我们经常要处理归一化的问题： 即把一个范围内的值，转换到范围1内的值。比如把一个颜色值255归一后就是1。假设我们有一个表示颜色值的数组要进行归一，用非并行化的方式来处理非常简单，可以自行尝试。下面我们将采用并行化的方式来处理，把数组中的值同时分开给多个线程一起并行归一化处理。</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut colors = [-20.0f32, 0.0, 20.0, 40.0,
        80.0, 100.0, 150.0, 180.0, 200.0, 250.0, 300.0];
    println!(&quot;original:    {:?}&quot;, &amp;colors);

    colors.par_iter_mut().for_each(|color| {
        let c : f32 = if *color &lt; 0.0 {
                0.0
            } else if *color &gt; 255.0 {
                255.0
            } else {
                *color
            };
        *color = c / 255.0;
    });
    println!(&quot;transformed: {:?}&quot;, &amp;colors);
}
</code></pre></pre>
<p>运行结果：</p>
<pre><code>original:    [-20, 0, 20, 40, 80, 100, 150, 180, 200, 250, 300]
transformed: [0, 0, 0.078431375, 0.15686275, 0.3137255, 0.39215687, 0.5882353, 0.7058824, 0.78431374, 0.98039216, 1]
</code></pre>
<p>以上代码是不是很简单。调用<code>par_iter_mut</code>获得一个并行执行的具有写权限的迭代器，<code>for_each</code>对每个元素执行一个操作。仅此而已。
我们能这么轻松地完成这个任务，原因是我们引入了 <a href="https://github.com/nikomatsakis/rayon/">rayon</a> 这个库。它把所有的脏活累活都干完了，把清晰安全易用的接口暴露出来给了我们。Rust还可以完全以库的形式，实现异步IO、协程等更加高阶的并行程序开发模式。</p>
<p>为了更深入的加深对Rust并发编程的理解和实践，还安排了一个挑战任务：实现一个Rust版本的MapReduce模式。值得你挑战。</p>
<a class="header" href="print.html#unsafe原始指针" id="unsafe原始指针"><h1>Unsafe、原始指针</h1></a>
<p>本章开始讲解 Rust 中的 <code>Unsafe</code> 部分。</p>
<a class="header" href="print.html#unsafe" id="unsafe"><h1>unsafe</h1></a>
<p><strong>Rust</strong>的内存安全依赖于强大的类型系统和编译时检测，不过它并不能适应所有的场景。
首先，所有的编程语言都需要跟外部的“不安全”接口打交道，调用外部库等，在“安全”的Rust下是无法实现的; 其次，“安全”的Rust无法高效表示复杂的数据结构，特别是数据结构内部有各种指针互相引用的时候；再次，
事实上还存在着一些操作，这些操作是安全的，但不能通过编译器的验证。</p>
<p>因此在安全的Rust背后，还需要<code>unsafe</code>的支持。</p>
<p><code>unsafe</code>块能允许程序员做的额外事情有：</p>
<ul>
<li>解引用一个裸指针<code>*const T</code>和<code>*mut T</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let raw = &amp;x as *const i32;
let points_at = unsafe { *raw };
println!(&quot;raw points at {}&quot;, points_at);
#}</code></pre></pre>
<ul>
<li>读写一个可变的静态变量<code>static mut</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
static mut N: i32 = 5;
unsafe {
    N += 1;
    println!(&quot;N: {}&quot;, N);
}
#}</code></pre></pre>
<ul>
<li>调用一个不安全函数</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">unsafe fn foo() {
    //实现
}
fn main() {
    unsafe {
        foo();
    }
}
</code></pre></pre>
<a class="header" href="print.html#a使用unsafe" id="a使用unsafe"><h2>使用<code>unsafe</code></h2></a>
<p><code>unsafe fn</code>不安全函数标示如果调用它可能会违反<strong>Rust</strong>的内存安全语意：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn danger_will_robinson() {
    // 实现
}
#}</code></pre></pre>
<p><code>unsafe block</code>不安全块可以在其中调用不安全的代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe {
    // 实现
}
#}</code></pre></pre>
<p><code>unsafe trait</code>不安全trait及它们的实现，所有实现它们的具体类型有可能是不安全的:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Scary { }
unsafe impl Scary for i32 {}
#}</code></pre></pre>
<a class="header" href="print.html#safe--no-bug" id="safe--no-bug"><h2>safe != no bug</h2></a>
<p>对于<strong>Rust</strong>来说禁止你做任何不安全的事是它的本职，不过有些是编写代码时的<code>bug</code>，它们并不属于“内存安全”的范畴：</p>
<ul>
<li>死锁</li>
<li>内存或其他资源溢出</li>
<li>退出未调用析构函数</li>
<li>整型溢出</li>
</ul>
<p>使用<code>unsafe</code>时需要注意一些特殊情形：</p>
<ul>
<li>数据竞争</li>
<li>解引用空裸指针和悬垂裸指针</li>
<li>读取未初始化的内存</li>
<li>使用裸指针打破指针重叠规则</li>
<li><code>&amp;mut T</code>和<code>&amp;T</code>遵循LLVM范围的<code>noalias</code>模型，除了如果<code>&amp;T</code>包含一个<code>UnsafeCell&lt;U&gt;</code>的话。不安全代码必须不能违反这些重叠（aliasing）保证</li>
<li>不使用<code>UnsafeCell&lt;U&gt;</code>改变一个不可变值/引用</li>
<li>通过编译器固有功能调用未定义行为：
<ul>
<li>使用<code>std::ptr::offset</code>（offset功能）来索引超过对象边界的值，除了允许的末位超出一个字节</li>
<li>在重叠（overlapping）缓冲区上使用<code>std::ptr::copy_nonoverlapping_memory</code>（memcpy32/memcpy64功能）</li>
</ul>
</li>
<li>原生类型的无效值，即使是在私有字段/本地变量中：
<ul>
<li>空/悬垂引用或装箱</li>
<li><code>bool</code>中一个不是<code>false</code>（0）或<code>true</code>（1）的值</li>
<li><code>enum</code>中一个并不包含在类型定义中判别式</li>
<li><code>char</code>中一个代理字（surrogate）或超过char::MAX的值</li>
<li><code>str</code>中非UTF-8字节序列</li>
</ul>
</li>
<li>在外部代码中使用Rust或在Rust中使用外部语言</li>
</ul>
<a class="header" href="print.html#a裸指针" id="a裸指针"><h1>裸指针</h1></a>
<p><strong>Rust</strong>通过限制智能指针的行为保障了编译时安全，不过仍需要对指针做一些额外的操作。</p>
<p><code>*const T</code>和<code>*mut T</code>在<strong>Rust</strong>中被称为“裸指针”。它允许别名，允许用来写共享所有权的类型，甚至是内存安全的共享内存类型如：<code>Rc&lt;T&gt;</code>和<code>Arc&lt;T&gt;</code>，但是赋予你更多权利的同时意味着你需要担当更多的责任：</p>
<ul>
<li>不能保证指向有效的内存，甚至不能保证是非空的</li>
<li>没有任何自动清除，所以需要手动管理资源</li>
<li>是普通旧式类型，也就是说，它不移动所有权，因此<strong>Rust</strong>编译器不能保证不出像释放后使用这种bug</li>
<li>缺少任何形式的生命周期，不像<code>&amp;</code>，因此编译器不能判断出悬垂指针</li>
<li>除了不允许直接通过<code>*const T</code>改变外，没有别名或可变性的保障</li>
</ul>
<a class="header" href="print.html#a使用" id="a使用"><h2>使用</h2></a>
<p>创建一个裸指针：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = 1;
let b = &amp;a as *const i32;

let mut x = 2;
let y = &amp;mut x as *mut i32;
#}</code></pre></pre>
<p>解引用需要在<code>unsafe</code>中进行：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = 1;
let b = &amp;a as *const i32;
let c = unsafe { *b };
println!(&quot;{}&quot;, c);
#}</code></pre></pre>
<p><code>Box&lt;T&gt;</code>的<code>into_raw</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: Box&lt;i32&gt; = Box::new(10);
// 我们需要先解引用a，再隐式把 &amp; 转换成 *
let b: *const i32 = &amp;*a;
// 使用 into_raw 方法
let c: *const i32 = Box::into_raw(a);
#}</code></pre></pre>
<p>如上说所，引用和裸指针之间可以隐式转换，但隐式转换后再解引用需要使用<code>unsafe</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 显式
let a = 1;
let b: *const i32 = &amp;a as *const i32; //或者let b = &amp;a as *const i32；
// 隐式
let c: *const i32 = &amp;a;
unsafe {
    println!(&quot;{}&quot;, *c);
}

#}</code></pre></pre>
<a class="header" href="print.html#ffi" id="ffi"><h1>FFI</h1></a>
<p>FFI(<a href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign Function Interface</a>)是用来与其它语言交互的接口，在有些语言里面称为语言绑定(language bindings)，Java 里面一般称为 JNI(Java Native Interface) 或 JNA(Java Native Access)。由于现实中很多程序是由不同编程语言写的，必然会涉及到跨语言调用，比如 A 语言写的函数如果想在 B 语言里面调用，这时一般有两种解决方案：一种是将函数做成一个服务，通过进程间通信(<a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a>)或网络协议通信(<a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a>, <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a>等)；另一种就是直接通过 FFI 调用。前者需要至少两个独立的进程才能实现，而后者直接将其它语言的接口内嵌到本语言中，所以调用效率比前者高。</p>
<p>当前的系统编程领域大部分被 C/C++ 占领，而 Rust 定位为系统编程语言，少不了与现有的 C/C++ 代码交互，另外为了给那些&quot;慢&quot;脚本语言调用，Rust 必然得对 FFI 有完善的支持，本章我们就来谈谈 Rust 的 FFI 系统。</p>
<a class="header" href="print.html#a调用ffi函数" id="a调用ffi函数"><h1>调用ffi函数</h1></a>
<blockquote>
<p>下文提到的ffi皆指cffi。</p>
</blockquote>
<p><strong>Rust</strong>作为一门<strong>系统</strong>级语言，自带对ffi调用的支持。</p>
<a class="header" href="print.html#getting-start" id="getting-start"><h2>Getting Start</h2></a>
<a class="header" href="print.html#a引入libc库" id="a引入libc库"><h3>引入libc库</h3></a>
<p>由于<code>cffi</code>的数据类型与<code>rust</code>不完全相同，我们需要引入<code>libc</code>库来表达对应<code>ffi</code>函数中的类型。</p>
<p>在<code>Cargo.toml</code>中添加以下行:</p>
<pre><code class="language-toml">[dependencies]
libc = &quot;0.2.9&quot;
</code></pre>
<p>在你的rs文件中引入库:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate libc
#}</code></pre></pre>
<p>在以前<code>libc</code>库是和<code>rust</code>一起发布的，后来libc被移入了<code>crates.io</code>通过cargo安装。</p>
<a class="header" href="print.html#a声明你的ffi函数" id="a声明你的ffi函数"><h3>声明你的<code>ffi</code>函数</h3></a>
<p>就像<code>c语言</code>需要<code>#include</code>声明了对应函数的头文件一样，<code>rust</code>中调用<code>ffi</code>也需要对对应函数进行声明。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use libc::c_int;
use libc::c_void;
use libc::size_t;

#[link(name = &quot;yourlib&quot;)]
extern {
    fn your_func(arg1: c_int, arg2: *mut c_void) -&gt; size_t; // 声明ffi函数
    fn your_func2(arg1: c_int, arg2: *mut c_void) -&gt; size_t;
    static ffi_global: c_int; // 声明ffi全局变量
}
#}</code></pre></pre>
<p>声明一个<code>ffi</code>库需要一个标记有<code>#[link(name = &quot;yourlib&quot;)]</code>的<code>extern</code>块。<code>name</code>为对应的库(<code>so</code>/<code>dll</code>/<code>dylib</code>/<code>a</code>)的名字。
如：如果你需要<code>snappy</code>库(<code>libsnappy.so</code>/<code>libsnappy.dll</code>/<code>libsnappy.dylib</code>/<code>libsnappy.a</code>), 则对应的<code>name</code>为<code>snappy</code>。
在一个<code>extern块</code>中你可以声明任意多的函数和变量。</p>
<a class="header" href="print.html#a调用ffi函数-1" id="a调用ffi函数-1"><h3>调用ffi函数</h3></a>
<p>声明完成后就可以进行调用了。
由于此函数来自外部的c库，所以rust并不能保证该函数的安全性。因此，调用任何一个<code>ffi</code>函数需要一个<code>unsafe</code>块。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let result: size_t = unsafe {
    your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void)
};
#}</code></pre></pre>
<a class="header" href="print.html#a封装unsafe暴露安全接口" id="a封装unsafe暴露安全接口"><h3>封装<code>unsafe</code>，暴露安全接口</h3></a>
<p>作为一个库作者，对外暴露不安全接口是一种非常不合格的做法。在做c库的<code>rust binding</code>时，我们做的最多的将是将不安全的c接口封装成一个安全接口。
通常做法是：在一个叫<code>ffi.rs</code>之类的文件中写上所有的<code>extern块</code>用以声明ffi函数。在一个叫<code>wrapper.rs</code>之类的文件中进行包装：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ffi.rs
#[link(name = &quot;yourlib&quot;)]
extern {
    fn your_func(arg1: c_int, arg2: *mut c_void) -&gt; size_t;
}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// wrapper.rs
fn your_func_wrapper(arg1: i32, arg2: &amp;mut i32) -&gt; isize {
    unsafe { your_func(1 as c_int, Box::into_raw(Box::new(3)) as *mut c_void) } as isize
}
#}</code></pre></pre>
<p>对外暴露(pub use) <code>your_func_wrapper</code>函数即可。</p>
<a class="header" href="print.html#a数据结构对应" id="a数据结构对应"><h2>数据结构对应</h2></a>
<p><code>libc</code>为我们提供了很多原始数据类型，比如<code>c_int</code>, <code>c_float</code>等，但是对于自定义类型，如结构体，则需要我们自行定义。</p>
<a class="header" href="print.html#a结构体-1" id="a结构体-1"><h3>结构体</h3></a>
<p><code>rust</code>中结构体默认的内存表示和c并不兼容。如果要将结构体传给ffi函数，请为<code>rust</code>的结构体打上标记：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(C)]
struct RustObject {
    a: c_int,
    // other members
}
#}</code></pre></pre>
<p>此外，如果使用<code>#[repr(C, packed)]</code>将不为此结构体填充空位用以对齐。</p>
<a class="header" href="print.html#union" id="union"><h3>Union</h3></a>
<p>比较遗憾的是，rust到目前为止(2016-03-31)还没有一个很好的应对c的union的方法。只能通过一些hack来实现。(<a href="https://github.com/rust-lang/rfcs/pull/1444">对应rfc</a>)</p>
<a class="header" href="print.html#enum" id="enum"><h3>Enum</h3></a>
<p>和<code>struct</code>一样，添加<code>#[repr(C)]</code>标记即可。</p>
<a class="header" href="print.html#a回调函数" id="a回调函数"><h3>回调函数</h3></a>
<p>和c库打交道时，我们经常会遇到一个函数接受另一个回调函数的情况。将一个<code>rust</code>函数转变成c可执行的回调函数非常简单：在函数前面加上<code>extern &quot;C&quot;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">extern &quot;C&quot; fn callback(a: c_int) { // 这个函数是传给c调用的
    println!(&quot;hello {}!&quot;, a);
}

#[link(name = &quot;yourlib&quot;)]
extern {
   fn run_callback(data: i32, cb: extern fn(i32));
}

fn main() {
    unsafe {
        run_callback(1 as i32, callback); // 打印 1
    }
}
</code></pre></pre>
<p>对应c库代码:</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);

void run_callback(int32_t data, rust_callback callback) {
    callback(data); // 调用传过来的回调函数
}
</code></pre>
<a class="header" href="print.html#a字符串-1" id="a字符串-1"><h3>字符串</h3></a>
<p>rust为了应对不同的情况，有很多种字符串类型。其中<code>CStr</code>和<code>CString</code>是专用于<code>ffi</code>交互的。</p>
<a class="header" href="print.html#cstr" id="cstr"><h4>CStr</h4></a>
<p>对于产生于c的字符串(如在c程序中使用<code>malloc</code>产生)，rust使用<code>CStr</code>来表示，和<code>str</code>类型对应，表明我们并不拥有这个字符串。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ffi::CStr;
use libc::c_char;
#[link(name = &quot;yourlib&quot;)]
extern {
    fn char_func() -&gt; *mut c_char;
}

fn get_string() -&gt; String {
    unsafe {
        let raw_string: *mut c_char = char_func();
        let cstr = CStr::from_ptr(my_string());
        cstr.to_string_lossy().into_owned()
    }
}
#}</code></pre></pre>
<p>在这里<code>get_string</code>使用<code>CStr::from_ptr</code>从c的<code>char*</code>获取一个字符串，并且转化成了一个String.</p>
<ul>
<li>注意to_string_lossy()的使用：因为在rust中一切字符都是采用utf8表示的而c不是，
因此如果要将c的字符串转换到rust字符串的话，需要检查是否都为有效<code>utf-8</code>字节。<code>to_string_lossy</code>将返回一个<code>Cow&lt;str&gt;</code>类型，
即如果c字符串都为有效<code>utf-8</code>字节，则将其0开销地转换成一个<code>&amp;str</code>类型，若不是，rust会将其拷贝一份并且将非法字节用<code>U+FFFD</code>填充。</li>
</ul>
<a class="header" href="print.html#cstring" id="cstring"><h4>CString</h4></a>
<p>和<code>CStr</code>表示从c中来，rust不拥有归属权的字符串相反，<code>CString</code>表示由rust分配，用以传给c程序的字符串。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::ffi::CString;
use std::os::raw::c_char;

extern {
    fn my_printer(s: *const c_char);
}

let c_to_print = CString::new(&quot;Hello, world!&quot;).unwrap();
unsafe {
    my_printer(c_to_print.as_ptr()); // 使用 as_ptr 将CString转化成char指针传给c函数
}
#}</code></pre></pre>
<p>注意c字符串中并不能包含<code>\0</code>字节(因为<code>\0</code>用来表示c字符串的结束符),因此<code>CString::new</code>将返回一个<code>Result</code>，
如果输入有<code>\0</code>的话则为<code>Error(NulError)</code>。</p>
<a class="header" href="print.html#a不透明结构体" id="a不透明结构体"><h3>不透明结构体</h3></a>
<p>C库存在一种常见的情况：库作者并不想让使用者知道一个数据类型的具体内容，因此常常提供了一套工具函数，并使用<code>void*</code>或不透明结构体传入传出进行操作。
比较典型的是<code>ncurse</code>库中的<code>WINDOW</code>类型。</p>
<p>当参数是<code>void*</code>时，在rust中可以和c一样，使用对应类型<code>*mut libc::c_void</code>进行操作。如果参数为不透明结构体，rust中可以使用空白<code>enum</code>进行代替:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum OpaqueStruct {}

extern &quot;C&quot; {
    pub fn foo(arg: *mut OpaqueStruct);
}
#}</code></pre></pre>
<p>C代码：</p>
<pre><code class="language-c">struct OpaqueStruct;
void foo(struct OpaqueStruct *arg);
</code></pre>
<a class="header" href="print.html#a空指针" id="a空指针"><h3>空指针</h3></a>
<p>另一种很常见的情况是需要一个空指针。请使用<code>0 as *const _</code> 或者 <code>std::ptr::null()</code>来生产一个空指针。</p>
<a class="header" href="print.html#a内存安全" id="a内存安全"><h2>内存安全</h2></a>
<p>由于<code>ffi</code>跨越了rust边界，rust编译器此时无法保障代码的安全性，所以在涉及ffi操作时要格外注意。</p>
<a class="header" href="print.html#a析构问题" id="a析构问题"><h3>析构问题</h3></a>
<p>在涉及ffi调用时最常见的就是析构问题：这个对象由谁来析构？是否会泄露或use after free？
有些情况下c库会把一类类型<code>malloc</code>了以后传出来，然后不再关系它的析构。因此在做ffi操作时请为这些类型实现析构(<code>Drop Trait</code>).</p>
<a class="header" href="print.html#a可空指针优化" id="a可空指针优化"><h3>可空指针优化</h3></a>
<p>当<code>rust</code>的一个<code>enum</code>为一种特殊结构：它有两种实例，一种为空，另一种只有一个数据域的时候，rustc会开启空指针优化将其优化成一个指针。
比如<code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code>会被优化成一个可空的函数指针。</p>
<a class="header" href="print.html#ownership处理" id="ownership处理"><h3>ownership处理</h3></a>
<p>在rust中，由于编译器会自动插入析构代码到块的结束位置，在使用<code>owned</code>类型时要格外的注意。</p>
<pre><pre class="playpen"><code class="language-rust">extern {
    pub fn foo(arg: extern fn() -&gt; *const c_char);
}

extern &quot;C&quot; fn danger() -&gt; *const c_char {
    let cstring = CString::new(&quot;I'm a danger string&quot;).unwrap();
    cstring.as_ptr()
}  // 由于CString是owned类型，在这里cstring被rust free掉了。USE AFTER FREE! too young!

fn main() {
  unsafe {
        foo(danger); // boom !!
    }
}
</code></pre></pre>
<p>由于<code>as_ptr</code>接受一个<code>&amp;self</code>作为参数(<code>fn as_ptr(&amp;self) -&gt; *const c_char</code>)，<code>as_ptr</code>以后<code>ownership</code>仍然归rust所有。因此rust会在函数退出时进行析构。
正确的做法是使用<code>into_raw()</code>来代替<code>as_ptr()</code>。由于<code>into_raw</code>的签名为<code>fn into_raw(self) -&gt; *mut c_char</code>，接受的是<code>self</code>,产生了<code>ownership</code>转移，
因此<code>danger</code>函数就不会将<code>cstring</code>析构了。</p>
<a class="header" href="print.html#panic" id="panic"><h3>panic</h3></a>
<p>由于在<code>ffi</code>中<code>panic</code>是未定义行为，切忌在<code>cffi</code>时<code>panic</code>包括直接调用<code>panic!</code>,<code>unimplemented!</code>,以及强行<code>unwrap</code>等情况。
当你写<code>cffi</code>时，记住：你写下的每个单词都可能是发射<strong>核弹</strong>的密码！</p>
<a class="header" href="print.html#a静态库动态库" id="a静态库动态库"><h2>静态库/动态库</h2></a>
<p>前面提到了声明一个外部库的方式--<code>#[link]</code>标记，此标记默认为动态库。但如果是静态库，可以使用<code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>来标记。
此外，对于osx的一种特殊库--<code>framework</code>, 还可以这样标记<code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code>.</p>
<a class="header" href="print.html#a调用约定" id="a调用约定"><h2>调用约定</h2></a>
<p>前面看到，声明一个被c调用的函数时，采用<code>extern &quot;C&quot; fn</code>的语法。此处的<code>&quot;C&quot;</code>即为c调用约定的意思。此外，rust还支持：</p>
<ul>
<li>stdcall</li>
<li>aapcs</li>
<li>cdecl</li>
<li>fastcall</li>
<li>vectorcall //这种call约定暂时需要开启abi_vectorcall feature gate.</li>
<li>Rust</li>
<li>rust-intrinsic</li>
<li>system</li>
<li>C</li>
<li>win64</li>
</ul>
<a class="header" href="print.html#bindgen" id="bindgen"><h2>bindgen</h2></a>
<p>是不是觉得把一个个函数和全局变量在<code>extern块</code>中去声明，对应的数据结构去手动创建特别麻烦？没关系，<code>rust-bindgen</code>来帮你搞定。
<code>rust-bindgen</code>是一个能从对应c头文件自动生成函数声明和数据结构的工具。创建一个绑定只需要<code>./bindgen [options] input.h</code>即可。
<a href="https://github.com/crabtw/rust-bindgen">项目地址</a></p>
<a class="header" href="print.html#a将rust编译成库" id="a将rust编译成库"><h1>将Rust编译成库</h1></a>
<p>上一章讲述了如何从rust中调用c库，这一章我们讲如何把rust编译成库让别的语言通过cffi调用。</p>
<a class="header" href="print.html#a调用约定和mangle" id="a调用约定和mangle"><h2>调用约定和mangle</h2></a>
<p>正如上一章讲述的，为了能让rust的函数通过ffi被调用，需要加上<code>extern &quot;C&quot;</code>对函数进行修饰。</p>
<p>但由于rust支持重载，所以函数名会被编译器进行混淆，就像c++一样。因此当你的函数被编译完毕后，函数名会带上一串表明函数签名的字符串。</p>
<p>比如：<code>fn test() {}</code>会变成<code>_ZN4test20hf06ae59e934e5641haaE</code>.
这样的函数名为ffi调用带来了困难，因此，rust提供了<code>#[no_mangle]</code>属性为函数修饰。
对于带有<code>#[no_mangle]</code>属性的函数，rust编译器不会为它进行函数名混淆。如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
extern &quot;C&quot; fn test() {}
#}</code></pre></pre>
<p>在nm中观察到为</p>
<pre><code>...
00000000001a7820 T test
...
</code></pre>
<p>至此，<code>test</code>函数将能够被正常的由<code>cffi</code>调用。</p>
<a class="header" href="print.html#a指定crate类型" id="a指定crate类型"><h2>指定<code>crate</code>类型</h2></a>
<p><code>rustc</code>默认编译产生<code>rust</code>自用的<code>rlib</code>格式库，要让<code>rustc</code>产生动态链接库或者静态链接库，需要显式指定。</p>
<ol>
<li>方法1: 在文件中指定。
在文件头加上<code>#![crate_type = &quot;foo&quot;]</code>, 其中<code>foo</code>的可选类型有<code>bin</code>, <code>lib</code>, <code>rlib</code>, <code>dylib</code>, <code>staticlib</code>.分别对应可执行文件，
默认(将由<code>rustc</code>自己决定), <code>rlib</code>格式，动态链接库，静态链接库。</li>
<li>方法2: 编译时给rustc 传<code>--crate-type</code>参数。参数内容同上。</li>
<li>方法3: 使用cargo，指定<code>crate-type = [&quot;foo&quot;]</code>, <code>foo</code>可选类型同1</li>
</ol>
<a class="header" href="print.html#a小技巧-any" id="a小技巧-any"><h2>小技巧: <code>Any</code></h2></a>
<p>由于在跨越<code>ffi</code>过程中，<code>rust</code>类型信息会丢失，比如当用<code>rust</code>提供一个<code>OpaqueStruct</code>给别的语言时：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::mem::transmute;

#[derive(Debug)]
struct Foo&lt;T&gt; {
  t: T
}

#[no_mangle]
extern &quot;C&quot; fn new_foo_vec() -&gt; *const c_void {
    Box::into_raw(Box::new(Foo {t: vec![1,2,3]})) as *const c_void
}

#[no_mangle]
extern &quot;C&quot; fn new_foo_int() -&gt; *const c_void {
    Box::into_raw(Box::new(Foo {t: 1})) as *const c_void
}

fn push_foo_element(t: &amp;mut Foo&lt;Vec&lt;i32&gt;&gt;) {
    t.t.push(1);
}

#[no_mangle]
extern &quot;C&quot; fn push_foo_element_c(foo: *mut c_void){
    let foo2 = unsafe {
        &amp;mut *(foo as *mut Foo&lt;Vec&lt;i32&gt;&gt;) // 这么确定是Foo&lt;Vec&lt;i32&gt;&gt;? 万一foo是Foo&lt;i32&gt;怎么办？
    };
    push_foo_element(foo3);
}
#}</code></pre></pre>
<p>以上代码中完全不知道<code>foo</code>是一个什么东西。安全也无从说起了，只能靠文档。
因此在<code>ffi</code>调用时往往会丧失掉<code>rust</code>类型系统带来的方便和安全。在这里提供一个小技巧:使用<code>Box&lt;Box&lt;Any&gt;&gt;</code>来包装你的类型。</p>
<p><code>rust</code>的<code>Any</code>类型为<code>rust</code>带来了运行时反射的能力，使用<code>Any</code>跨越<code>ffi</code>边界将极大提高程序安全性。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::any::Any;

#[derive(Debug)]
struct Foo&lt;T&gt; {
  t: T
}

#[no_mangle]
extern &quot;C&quot; fn new_foo_vec() -&gt; *const c_void {
    Box::into_raw(Box::new(Box::new(Foo {t: vec![1,2,3]}) as Box&lt;Any&gt;)) as *const c_void
}

#[no_mangle]
extern &quot;C&quot; fn new_foo_int() -&gt; *const c_void {
    Box::into_raw(Box::new(Box::new(Foo {t: 1}) as Box&lt;Any&gt;)) as *const c_void
}

fn push_foo_element(t: &amp;mut Foo&lt;Vec&lt;i32&gt;&gt;) {
    t.t.push(1);
}

#[no_mangle]
extern &quot;C&quot; fn push_foo_element_c(foo: *mut c_void){
    let foo2 = unsafe {
        &amp;mut *(foo as *mut Box&lt;Any&gt;)
    };
    let foo3: Option&lt;&amp;mut Foo&lt;Vec&lt;i32&gt;&gt;&gt; = foo2.downcast_mut(); // 如果foo2不是*const Box&lt;Foo&lt;Vec&lt;i32&gt;&gt;&gt;, 则foo3将会是None
    if let Some(value) = foo3 {
      push_foo_element(value);
    }
}
#}</code></pre></pre>
<p>这样一来，就非常不容易出错了。</p>
<a class="header" href="print.html#a属性和编译器参数" id="a属性和编译器参数"><h1>属性和编译器参数</h1></a>
<p>本章将介绍Rust语言中的属性（Attribute）和编译器参数（Compiler Options）。</p>
<a class="header" href="print.html#a属性" id="a属性"><h2>属性</h2></a>
<p>属性（Attribute）是一种通用的用于表达元数据的特性，借鉴ECMA-334(C#)的语法来实现ECMA-335中描述的Attributes。属性只能应用于Item（元素、项），
例如 <code>use</code> 声明、模块、函数等。</p>
<a class="header" href="print.html#a元素" id="a元素"><h3>元素</h3></a>
<p>在Rust中，Item是Crate（库）的一个组成部分。它包括</p>
<ul>
<li><code>extern crate</code>声明</li>
<li><code>use</code>声明</li>
<li>模块（模块是一个Item的容器）</li>
<li>函数</li>
<li><code>type</code>定义</li>
<li>结构体定义</li>
<li>枚举类型定义</li>
<li>常量定义</li>
<li>静态变量定义</li>
<li>Trait定义</li>
<li>实现（Impl）</li>
</ul>
<p>这些Item是可以互相嵌套的，比如在一个函数中定义一个静态变量、在一个模块中使用<code>use</code>声明或定义一个结构体。这些定义在某个作用域里面的Item跟你把
它写到最外层作用域所实现的功能是一样的，只不过你要访问这些嵌套的Item就必须使用路径（Path），如<code>a::b::c</code>。但一些外层的Item不允许你使用路径去
访问它的子Item，比如函数，在函数中定义的静态变量、结构体等，是不可以通过路径来访问的。</p>
<a class="header" href="print.html#a属性的语法" id="a属性的语法"><h3>属性的语法</h3></a>
<p>属性的语法借鉴于C#，看起来像是这样子的</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[name(arg1, arg2 = &quot;param&quot;)]
#}</code></pre></pre>
<p>它是由一个<code>#</code>开启，后面紧接着一个<code>[]</code>，里面便是属性的具体内容，它可以有如下几种写法：</p>
<ul>
<li>单个标识符代表的属性名，如<code>#[unix]</code></li>
<li>单个标识符代表属性名，后面紧跟着一个<code>=</code>，然后再跟着一个字面量（Literal），组成一个键值对，如<code>#[link(name = &quot;openssl&quot;)]</code></li>
<li>单个标识符代表属性名，后面跟着一个逗号隔开的子属性的列表，如<code>#[cfg(and(unix, not(windows)))]</code></li>
</ul>
<p>在<code>#</code>后面还可以紧跟一个<code>!</code>，比如<code>#![feature(box_syntax)]</code>，这表示这个属性是应用于它所在的这个Item。而如果没有<code>!</code>则表示这个属性仅应用于紧接着的那个Item。</p>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 为这个crate开启box_syntax这个新特性
#![feature(box_syntax)]

// 这是一个单元测试函数
#[test]
fn test_foo() {
    /* ... */
}

// 条件编译，只会在编译目标为Linux时才会生效
#[cfg(target_os=&quot;linux&quot;)]
mod bar {
    /* ... */
}

// 为以下的这个type定义关掉non_camel_case_types的编译警告
#[allow(non_camel_case_types)]
type int8_t = i8;
#}</code></pre></pre>
<a class="header" href="print.html#a应用于crate的属性" id="a应用于crate的属性"><h3>应用于Crate的属性</h3></a>
<ul>
<li>
<p><code>crate_name</code> - 指定Crate的名字。如<code>#[crate_name = &quot;my_crate&quot;]</code>则可以让编译出的库名字为<code>libmy_crate.rlib</code>。</p>
</li>
<li>
<p><code>crate_type</code> - 指定Crate的类型，有以下几种选择</p>
<ul>
<li><code>&quot;bin&quot;</code> - 编译为可执行文件；</li>
<li><code>&quot;lib&quot;</code> - 编译为库；</li>
<li><code>&quot;dylib&quot;</code> - 编译为动态链接库；</li>
<li><code>&quot;staticlib&quot;</code> - 编译为静态链接库；</li>
<li><code>&quot;rlib&quot;</code> - 编译为Rust特有的库文件，它是一种特殊的静态链接库格式，它里面会含有一些元数据供编译器使用，最终会静态链接到目标文件之中。</li>
</ul>
<p>例<code>#![crate_type = &quot;dylib&quot;]</code>。</p>
</li>
<li>
<p><code>feature</code> - 可以开启一些不稳定特性，只可在nightly版的编译器中使用。</p>
</li>
<li>
<p><code>no_builtins</code> - 去掉内建函数。</p>
</li>
<li>
<p><code>no_main</code>- 不生成<code>main</code>这个符号，当你需要链接的库中已经定义了<code>main</code>函数时会用到。</p>
</li>
<li>
<p><code>no_start</code> - 不链接自带的<code>native</code>库。</p>
</li>
<li>
<p><code>no_std</code> - 不链接自带的<code>std</code>库。</p>
</li>
<li>
<p><code>plugin</code> - 加载编译器插件，一般用于加载自定义的编译器插件库。用法是</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 加载foo, bar两个插件
#![plugin(foo, bar)]
// 或者给插件传入必要的初始化参数
#![plugin(foo(arg1, arg2))]
#}</code></pre></pre>
</li>
<li>
<p><code>recursive_limit</code> - 设置在编译期最大的递归层级。比如自动解引用、递归定义的宏等。默认设置是<code>#![recursive_limit = &quot;64&quot;]</code></p>
</li>
</ul>
<a class="header" href="print.html#a应用于模块的属性" id="a应用于模块的属性"><h3>应用于模块的属性</h3></a>
<ul>
<li>
<p><code>no_implicit_prelude</code> - 取消自动插入<code>use std::prelude::*</code>。</p>
</li>
<li>
<p><code>path</code> - 设置此<code>mod</code>的文件路径。</p>
<p>如声明<code>mod a;</code>，则寻找</p>
<ul>
<li>本文件夹下的<code>a.rs</code>文件</li>
<li>本文件夹下的<code>a/mod.rs</code>文件</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(unix)]
#[path = &quot;sys/unix.rs&quot;]
mod sys;

#[cfg(windows)]
#[path = &quot;sys/windows.rs&quot;]
mod sys;
#}</code></pre></pre>
</li>
</ul>
<a class="header" href="print.html#a应用于函数的属性" id="a应用于函数的属性"><h3>应用于函数的属性</h3></a>
<ul>
<li><code>main</code> - 把这个函数作为入口函数，替代<code>fn main</code>，会被入口函数（Entry Point）调用。</li>
<li><code>plugin_registrar</code> - 编写编译器插件时用，用于定义编译器插件的入口函数。</li>
<li><code>start</code> - 把这个函数作为入口函数（Entry Point），改写 <code>start</code> language item。</li>
<li><code>test</code> - 指明这个函数为单元测试函数，在非测试环境下不会被编译。</li>
<li><code>should_panic</code> - 指明这个单元测试函数必然会panic。</li>
<li><code>cold</code> - 指明这个函数很可能是不会被执行的，因此优化的时候特别对待它。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 把`my_main`作为主函数
#[main]
fn my_main() {

}

// 把`plugin_registrar`作为此编译器插件的入口函数
#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_macro(&quot;rn&quot;, expand_rn);
}

// 把`entry_point`作为入口函数，不再执行标准库中的初始化流程
#[start]
fn entry_point(argc: isize, argv: *const *const u8) -&gt; isize {

}

// 定义一个单元测试
// 这个单元测试一定会panic
#[test]
#[should_panic]
fn my_test() {
    panic!(&quot;I expected to be panicked&quot;);
}

// 这个函数很可能是不会执行的，
// 所以优化的时候就换种方式
#[cold]
fn unlikely_to_be_executed() {

}
#}</code></pre></pre>
<a class="header" href="print.html#a应用于全局静态变量的属性" id="a应用于全局静态变量的属性"><h3>应用于全局静态变量的属性</h3></a>
<ul>
<li><code>thread_local</code> - 只可用于<code>static mut</code>，表示这个变量是thread local的。</li>
</ul>
<a class="header" href="print.html#a应用于ffi的属性" id="a应用于ffi的属性"><h3>应用于FFI的属性</h3></a>
<p><code>extern</code>块可以应用以下属性</p>
<ul>
<li>
<p><code>link_args</code> - 指定链接时给链接器的参数，平台和实现相关。</p>
</li>
<li>
<p><code>link</code> - 说明这个块需要链接一个native库，它有以下参数：</p>
<ul>
<li><code>name</code> - 库的名字，比如<code>libname.a</code>的名字是<code>name</code>；</li>
<li><code>kind</code> - 库的类型，它包括
<ul>
<li><code>dylib</code> - 动态链接库</li>
<li><code>static</code> - 静态库</li>
<li><code>framework</code> - OS X里的Framework</li>
</ul>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[link(name = &quot;readline&quot;)]
extern {

}

#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]
extern {

}
#}</code></pre></pre>
</li>
</ul>
<p>在<code>extern</code>块里面，可以使用</p>
<ul>
<li><code>link_name</code> - 指定这个链接的外部函数的名字或全局变量的名字；</li>
<li><code>linkage</code> - 对于全局变量，可以指定一些LLVM的链接类型（ http://llvm.org/docs/LangRef.html#linkage-types ）。</li>
</ul>
<p>对于<code>enum</code>类型，可以使用</p>
<ul>
<li><code>repr</code> - 目前接受<code>C</code>，<code>C</code>表示兼容C ABI。</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(C)]
enum eType {
    Operator,
    Indicator,
}
#}</code></pre></pre>
<p>对于<code>struct</code>类型，可以使用</p>
<ul>
<li><code>repr</code> - 目前只接受<code>C</code>和<code>packed</code>，<code>C</code>表示结构体兼容C ABI，<code>packed</code>表示移除字段间的padding。</li>
</ul>
<a class="header" href="print.html#a用于宏的属性" id="a用于宏的属性"><h3>用于宏的属性</h3></a>
<ul>
<li>
<p><code>macro_use</code> - 把模块或库中定义的宏导出来</p>
<ul>
<li>
<p>应用于<code>mod</code>上，则把此模块内定义的宏导出到它的父模块中</p>
</li>
<li>
<p>应用于<code>extern crate</code>上，则可以接受一个列表，如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use(debug, trace)]
extern crate log;
#}</code></pre></pre>
<p>则可以只导入列表中指定的宏，若不指定则导入所有的宏。</p>
</li>
</ul>
</li>
<li>
<p><code>macro_reexport</code> - 应用于<code>extern crate</code>上，可以再把这些导入的宏再输出出去给别的库使用。</p>
</li>
<li>
<p><code>macro_export</code> - 应于在宏上，可以使这个宏可以被导出给别的库使用。</p>
</li>
<li>
<p><code>no_link</code> - 应用于<code>extern crate</code>上，表示即使我们把它里面的库导入进来了，但是不要把这个库链接到目标文件中。</p>
</li>
</ul>
<a class="header" href="print.html#a其它属性" id="a其它属性"><h3>其它属性</h3></a>
<ul>
<li>
<p><code>export_function</code> - 用于静态变量或函数，指定它们在目标文件中的符号名。</p>
</li>
<li>
<p><code>link_section</code> - 用于静态变量或函数，表示应该把它们放到哪个段中去。</p>
</li>
<li>
<p><code>no_mangle</code> - 可以应用于任意的Item，表示取消对它们进行命名混淆，直接把它们的名字作为符号写到目标文件中。</p>
</li>
<li>
<p><code>simd</code> - 可以用于元组结构体上，并自动实现了数值运算符，这些操作会生成相应的SIMD指令。</p>
</li>
<li>
<p><code>doc</code> - 为这个Item绑定文档，跟<code>///</code>的功能一样，用法是</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[doc = &quot;This is a doc&quot;]
struct Foo {}
#}</code></pre></pre>
</li>
</ul>
<a class="header" href="print.html#a条件编译" id="a条件编译"><h3>条件编译</h3></a>
<p>有时候，我们想针对不同的编译目标来生成不同的代码，比如在编写跨平台模块时，针对Linux和Windows分别使用不同的代码逻辑。</p>
<p>条件编译基本上就是使用<code>cfg</code>这个属性，直接看例子</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(target_os = &quot;macos&quot;)]
fn cross_platform() {
    // Will only be compiled on Mac OS, including Mac OS X
}

#[cfg(target_os = &quot;windows&quot;)]
fn cross_platform() {
    // Will only be compiled on Windows
}

// 若条件`foo`或`bar`任意一个成立，则编译以下的Item
#[cfg(any(foo, bar))]
fn need_foo_or_bar() {

}

// 针对32位的Unix系统
#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
fn on_32bit_unix() {

}

// 若`foo`不成立时编译
#[cfg(not(foo))]
fn needs_not_foo() {

}
#}</code></pre></pre>
<p>其中，<code>cfg</code>可接受的条件有</p>
<ul>
<li>
<p><code>debug_assertions</code> - 若没有开启编译优化时就会成立。</p>
</li>
<li>
<p><code>target_arch = &quot;...&quot;</code> - 目标平台的CPU架构，包括但不限于<code>x86</code>, <code>x86_64</code>, <code>mips</code>, <code>powerpc</code>, <code>arm</code>或<code>aarch64</code>。</p>
</li>
<li>
<p><code>target_endian = &quot;...&quot;</code> - 目标平台的大小端，包括<code>big</code>和<code>little</code>。</p>
</li>
<li>
<p><code>target_env = &quot;...&quot;</code> - 表示使用的运行库，比如<code>musl</code>表示使用的是MUSL的libc实现, <code>msvc</code>表示使用微软的MSVC，<code>gnu</code>表示使用GNU的实现。
但在部分平台这个数据是空的。</p>
</li>
<li>
<p><code>target_family = &quot;...&quot;</code> - 表示目标操作系统的类别，比如<code>windows</code>和<code>unix</code>。这个属性可以直接作为条件使用，如<code>#[unix]</code>，<code>#[cfg(unix)]</code>。</p>
</li>
<li>
<p><code>target_os = &quot;...&quot;</code> - 目标操作系统，包括但不限于<code>windows</code>, <code>macos</code>, <code>ios</code>, <code>linux</code>, <code>android</code>, <code>freebsd</code>, <code>dragonfly</code>, <code>bitrig</code>, <code>openbsd</code>, <code>netbsd</code>。</p>
</li>
<li>
<p><code>target_pointer_width = &quot;...&quot;</code> - 目标平台的指针宽度，一般就是<code>32</code>或<code>64</code>。</p>
</li>
<li>
<p><code>target_vendor = &quot;...&quot;</code> - 生产商，例如<code>apple</code>, <code>pc</code>或大多数Linux系统的<code>unknown</code>。</p>
</li>
<li>
<p><code>test</code> - 当启动了单元测试时（即编译时加了<code>--test</code>参数，或使用<code>cargo test</code>）。</p>
</li>
</ul>
<p>还可以根据一个条件去设置另一个条件，使用<code>cfg_attr</code>，如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg_attr(a, b)]
#}</code></pre></pre>
<p>这表示若<code>a</code>成立，则这个就相当于<code>#[cfg(b)]</code>。</p>
<p>条件编译属性只可以应用于Item，如果想应用在非Item中怎么办呢？可以使用<code>cfg!</code>宏，如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if cfg!(target_arch = &quot;x86&quot;) {

} else if cfg!(target_arch = &quot;x86_64&quot;) {

} else if cfg!(target_arch = &quot;mips&quot;) {

} else {

}
#}</code></pre></pre>
<p>这种方式不会产生任何运行时开销，因为不成立的条件相当于里面的代码根本不可能被执行，编译时会直接被优化掉。</p>
<a class="header" href="print.html#linter参数" id="linter参数"><h3>Linter参数</h3></a>
<p>目前的Rust编译器已自带的Linter，它可以在编译时静态帮你检测不用的代码、死循环、编码风格等等。Rust提供了一系列的属性用于控制Linter的行为</p>
<ul>
<li><code>allow(C)</code> - 编译器将不会警告对于<code>C</code>条件的检查错误。</li>
<li><code>deny(C)</code> - 编译器遇到违反<code>C</code>条件的错误将直接当作编译错误。</li>
<li><code>forbit(C)</code> - 行为与<code>deny(C)</code>一样，但这个将不允许别人使用<code>allow(C)</code>去修改。</li>
<li><code>warn(C)</code> - 编译器将对于<code>C</code>条件的检查错误输出警告。</li>
</ul>
<p>编译器支持的Lint检查可以通过执行<code>rustc -W help</code>来查看。</p>
<a class="header" href="print.html#a内联参数" id="a内联参数"><h3>内联参数</h3></a>
<p>内联函数即建议编译器可以考虑把整个函数拷贝到调用者的函数体中，而不是生成一个<code>call</code>指令调用过去。这种优化对于短函数非常有用，有利于提高性能。</p>
<p>编译器自己会根据一些默认的条件来判断一个函数是不是应该内联，若一个不应该被内联的函数被内联了，实际上会导致整个程序更慢。</p>
<p>可选的属性有：</p>
<ul>
<li><code>#[inline]</code> - 建议编译器内联这个函数</li>
<li><code>#[inline(always)]</code> - 要求编译器必须内联这个函数</li>
<li><code>#[inline(never)]</code> - 要求编译器不要内联这个函数</li>
</ul>
<p>内联会导致在一个库里面的代码被插入到另一个库中去。</p>
<a class="header" href="print.html#a自动实现trait" id="a自动实现trait"><h3>自动实现Trait</h3></a>
<p>编译器提供一个编译器插件叫作<code>derive</code>，它可以帮你去生成一些代码去实现（impl）一些特定的Trait，如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(PartialEq, Clone)]
struct Foo&lt;T&gt; {
    a: i32,
    b: T,
}
#}</code></pre></pre>
<p>编译器会自动为你生成以下的代码</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;T: PartialEq&gt; PartialEq for Foo&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a == other.a &amp;&amp; self.b == other.b
    }

    fn ne(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a != other.a || self.b != other.b
    }
}

impl&lt;T: Clone&gt; Clone for Foo&lt;T&gt; {
    fn clone(&amp;self) -&gt; Foo&lt;T&gt; {
        Foo {
            a: self.a.clone(),
            b: self.b.clone(),
        }
    }
}
#}</code></pre></pre>
<p>目前<code>derive</code>仅支持标准库中部分的Trait。</p>
<a class="header" href="print.html#a编译器特性" id="a编译器特性"><h3>编译器特性</h3></a>
<p>在非稳定版的Rust编译器中，可以使用一些不稳定的功能，比如一些还在讨论中的新功能、正在实现中的功能等。Rust编译器提供一个应用于Crate的属性<code>feature</code>来启用这些不稳定的功能，如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(advanced_slice_patterns, box_syntax, asm)]
#fn main() {
#}</code></pre></pre>
<p>具体可使用的编译器特性会因编译器版本的发布而不同，具体请阅读官方文档。</p>
<a class="header" href="print.html#a编译器参数" id="a编译器参数"><h1>编译器参数</h1></a>
<p>本章将介绍Rust编译器的参数。</p>
<p>Rust编译器程序的名字是<code>rustc</code>，使用它的方法很简单：</p>
<pre><code class="language-bash">$ rustc [OPTIONS] INPUT
</code></pre>
<p>其中，<code>[OPTIONS]</code>表示编译参数，而<code>INPUT</code>则表示输入文件。而编译参数有以下可选：</p>
<ul>
<li>
<p><code>-h, --help</code> - 输出帮助信息到标准输出；</p>
</li>
<li>
<p><code>--cfg SPEC</code> - 传入自定义的条件编译参数，使用方法如</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if cfg!(hello) {
        println!(&quot;world!&quot;);
    }
}
</code></pre></pre>
<p>如上例所示，若<code>cfg!(hello)</code>成立，则运行程序就会输出<code>&quot;world&quot;</code>到标准输出。我们把这个文件保存为<code>hello.rs</code>然后编译它</p>
<pre><code class="language-bash">$ rustc --cfg hello hello.rs
</code></pre>
<p>运行它就会看到屏幕中输出了<code>world!</code>。</p>
</li>
<li>
<p><code>-L [KIND=]PATH</code> - 往链接路径中加入一个文件夹，并且可以指定这个路径的类型（Kind），这些类型包括</p>
<ul>
<li><code>dependency</code> - 在这个路径下找依赖的文件，比如说<code>mod</code>；</li>
<li><code>crate</code> - 只在这个路径下找<code>extern crate</code>中定义的库；</li>
<li><code>native</code> - 只在这个路径下找Native库；</li>
<li><code>framework</code> - 只在OS X下有用，只在这个路径下找Framework；</li>
<li><code>all</code> - 默认选项。</li>
</ul>
</li>
<li>
<p><code>-l [KIND=]NAME</code> - 链接一个库，这个库可以指定类型（Kind）</p>
<ul>
<li><code>static</code> - 静态库；</li>
<li><code>dylib</code> - 动态库；</li>
<li><code>framework</code> - OS X的Framework。</li>
</ul>
<p>如果不传，默认为<code>dylib</code>。</p>
<p>此处举一个例子如何手动链接一个库，我们先创建一个文件叫<code>myhello.rs</code>，在里面写一个函数</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// myhello.rs

/// 这个函数仅仅向标签输出打印 Hello World!
/// 不要忘记要把它标记为 pub 哦。
pub fn print_hello() {
    println!(&quot;Hello World!&quot;);
}
#}</code></pre></pre>
<p>然后把这个文件编译成一个静态库，<code>libmyhello.a</code></p>
<pre><code class="language-bash">$ rustc --crate-type staticlib myhello.rs
</code></pre>
<p>然后再创建一个<code>main.rs</code>，链接这个库并打印出&quot;Hello World!&quot;</p>
<pre><pre class="playpen"><code class="language-rust">// main.rs

// 指定链接库 myhello
extern crate myhello;

fn main() {
    // 调用库函数
    myhello::print_hello();
}
</code></pre></pre>
<p>编译<code>main.rs</code></p>
<pre><code class="language-bash">$ rustc -L. -lmyhello main.rs
</code></pre>
<p>运行<code>main</code>，就会看到屏幕输出&quot;Hello World!&quot;啦。</p>
</li>
<li>
<p><code>--crate-type</code> - 指定编译输出类型，它的参数包括</p>
<ul>
<li><code>bin</code> - 二进行可执行文件</li>
<li><code>lib</code> - 编译为库</li>
<li><code>rlib</code> - Rust库</li>
<li><code>dylib</code> - 动态链接库</li>
<li><code>staticlib</code> - 静态链接库</li>
</ul>
</li>
<li>
<p><code>--crate-name</code> - 指定这个Crate的名字，默认是文件名，如<code>main.rs</code>编译成可执行文件时默认是<code>main</code>，但你可以指定它为<code>foo</code></p>
<pre><code class="language-bash">$ rustc --crate-name foo main.rs
</code></pre>
<p>则会输出<code>foo</code>可执行文件。</p>
</li>
<li>
<p><code>--emit</code> - 指定编译器的输出。编译器默认是输出一个可执行文件或库文件，但你可以选择输出一些其它的东西用于Debug</p>
<ul>
<li><code>asm</code> - 输出汇编</li>
<li><code>llvm-bc</code> - <a href="http://llvm.org/docs/BitCodeFormat.html">LLVM Bitcode</a>；</li>
<li><code>llvm-ir</code> - <a href="http://llvm.org/docs/LangRef.html">LLVM IR</a>，即LLVM中间码（LLVM Intermediate Representation）；</li>
<li><code>obj</code> - Object File（就是<code>*.o</code>文件）；</li>
<li><code>link</code> - 这个是要结合其它<code>--emit</code>参数使用，会执行Linker再输出结果；</li>
<li><code>dep-info</code> - 文件依赖关系（Debug用，类似于Makefile一样的依赖）。</li>
</ul>
<p>以上参数可以同时使用，使用逗号分割，如</p>
<pre><code class="language-bash">$ rustc --emit asm,llvm-ir,obj main.rs
</code></pre>
<p>同时，在最后可以加一个<code>=PATH</code>来指定输出到一个特定文件，如</p>
<pre><code class="language-bash">$ rustc --emit asm=output.S,llvm-ir=output.ir main.rs
</code></pre>
<p>这样会把汇编生成到<code>output.S</code>文件中，把LLVM中间码输出到<code>output.ir</code>中。</p>
</li>
<li>
<p><code>--print</code> - 打印一些信息，参数有</p>
<ul>
<li><code>crate-name</code> - 编译目标名；</li>
<li><code>file-names</code> - 编译的文件名；</li>
<li><code>sysroot</code> - 打印Rust工具链的根目录地址。</li>
</ul>
</li>
<li>
<p><code>-g</code> - 在目标文件中保存符号，这个参数等同于<code>-C debuginfo=2</code>。</p>
</li>
<li>
<p><code>-O</code> - 开启优化，这个参数等同于<code>-C opt-level=2</code>。</p>
</li>
<li>
<p><code>-o FILENAME</code> - 指定输出文件名，同样适用于<code>--emit</code>的输出。</p>
</li>
<li>
<p><code>--out-dir DIR</code> - 指定输出的文件夹，默认是当前文件夹，且会忽略<code>-o</code>配置。</p>
</li>
<li>
<p><code>--explain OPT</code> - 解释某一个编译错误，比如</p>
<p>若你写了一个<code>main.rs</code>，使用了一个未定义变量<code>f</code></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    f
}
</code></pre></pre>
<p>编译它时编译器会报错：</p>
<pre><code>main.rs:2:5: 2:6 error: unresolved name `f` [E0425]
main.rs:2     f
              ^
main.rs:2:5: 2:6 help: run `rustc --explain E0425` to see a detailed explanation
error: aborting due to previous error
</code></pre>
<p>虽然错误已经很明显，但是你也可以让编译器解释一下，什么是<code>E0425</code>错误：</p>
<pre><code class="language-bash">$ rustc --explain E0425
// 编译器打印的说明
</code></pre>
</li>
<li>
<p><code>--test</code> - 编译成一个单元测试可执行文件</p>
</li>
<li>
<p><code>--target TRIPLE</code> - 指定目标平台，基本格式是<code>cpu-manufacturer-kernel[-os]</code>，例如</p>
<pre><code class="language-bash">## 64位OS X
$ rustc --target x86_64-apple-darwin
</code></pre>
</li>
<li>
<p><code>-W help</code> - 打印Linter的所有可配置选项和默认值。</p>
</li>
<li>
<p><code>-W OPT, --warn OPT</code> - 设置某一个Linter选项为Warning。</p>
</li>
<li>
<p><code>-A OPT, --allow OPT</code> - 设置某一个Linter选项为Allow。</p>
</li>
<li>
<p><code>-D OPT, --deny OPT</code> - 设置某一个Linter选项为Deny。</p>
</li>
<li>
<p><code>-F OPT, --forbit OPT</code> - 设置某一个Linter选项为Forbit。</p>
</li>
<li>
<p><code>-C FLAG[=VAL], --codegen FLAG[=VAL]</code> - 目标代码生成的的相关参数，可以用<code>-C help</code>来查看配置，值得关注的几个是</p>
<ul>
<li><code>linker=val</code> - 指定链接器；</li>
<li><code>linker-args=val</code> - 指定链接器的参数；</li>
<li><code>prefer-dynamic</code> - 默认Rust编译是静态链接，选择这个配置将改为动态链接；</li>
<li><code>debug-info=level</code> - Debug信息级数，<code>0</code> = 不生成，<code>1</code> = 只生成文件行号表，<code>2</code> = 全部生成；</li>
<li><code>opt-level=val</code> - 优化级数，可选<code>0-3</code>；</li>
<li><code>debug_assertion</code> - 显式开启<code>cfg(debug_assertion)</code>条件。</li>
</ul>
</li>
<li>
<p><code>-V, --version</code> - 打印编译器版本号。</p>
</li>
<li>
<p><code>-v, --verbose</code> - 开启啰嗦模式（打印编译器执行的日志）。</p>
</li>
<li>
<p><code>--extern NAME=PATH</code> - 用来指定外部的Rust库（<code>*.rlib</code>）名字和路径，名字应该与<code>extern crate</code>中指定的一样。</p>
</li>
<li>
<p><code>--sysroot PATH</code> - 指定工具链根目录。</p>
</li>
<li>
<p><code>-Z flag</code> - 编译器Debug用的参数，可以用<code>-Z help</code>来查看可用参数。</p>
</li>
<li>
<p><code>--color auto|always|never</code> - 输出时对日志加颜色</p>
<ul>
<li><code>auto</code> - 自动选择加还是不加，如果输出目标是虚拟终端（TTY）的话就加，否则就不加；</li>
<li><code>always</code> - 给我加！</li>
<li><code>never</code> - 你敢加？</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#a测试与评测" id="a测试与评测"><h1>测试与评测</h1></a>
<p>本章讲解 Rust 中内建的测试与评测相关知识。</p>
<a class="header" href="print.html#a测试-1" id="a测试-1"><h1>测试</h1></a>
<blockquote>
<p>程序测试是一种找到缺陷的有效方式，但是它对证明没有缺陷却无能为力。</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<p>作为软件工程质量保障体系的重要一环，测试是应该引起我们充分注意并重视的事情。前面说过，Rust 语言的设计集成了最近十多年中总结出来的大量最佳工程实践，而对测试的原生集成也正体现了这一点。下面来看 Rust 是怎么设计测试特性的。</p>
<p>Rust 的测试特性按精细度划分，分为 3 个层次：</p>
<ol>
<li>函数级；</li>
<li>模块级；</li>
<li>工程级；</li>
</ol>
<p>另外，Rust 还支持对文档进行测试。</p>
<a class="header" href="print.html#a函数级测试" id="a函数级测试"><h2>函数级测试</h2></a>
<p>在本章中，我们用创建一个库的实操来讲解测试的内容。我们先用 cargo 建立一个库工程：<code>adder</code></p>
<pre><code>$ cargo new adder
$ cd adder
</code></pre>
<a class="header" href="print.html#test-标识" id="test-标识"><h3><code>#[test]</code> 标识</h3></a>
<p>打开 <code>src/lib.rs</code> 文件，可以看到如下代码</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    // do test work
}
#}</code></pre></pre>
<p>Rust 中，只需要在一个函数的上面，加上 <code>#[test]</code> 就标明这是一个测试用的函数。</p>
<p>有了这个属性之后，在使用 <code>cargo build</code> 编译时，就会忽略这些函数。使用 <code>cargo test</code> 可以运行这些函数。类似于如下效果：</p>
<pre><code>$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust 提供了两个宏来执行测试断言：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
assert!(expr)               测试表达式是否为 true 或 false
assert_eq!(expr, expr)      测试两个表达式的结果是否相等
#}</code></pre></pre>
<p>比如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert!(false);
}
#}</code></pre></pre>
<p>运行 <code>cargo test</code>，你会得到类似下面这样的提示</p>
<pre><code>$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<a class="header" href="print.html#should_panic-标识" id="should_panic-标识"><h3><code>#[should_panic]</code> 标识</h3></a>
<p>如果你的测试函数没完成，或没有更新，或是故意让它崩溃，但为了让测试能够顺利完成，我们主动可以给测试函数加上 <code>#[should_panic]</code> 标识，就不会让 <code>cargo test</code> 报错了。</p>
<p>如</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}
#}</code></pre></pre>
<p>运行 <code>cargo test</code>，结果类似如下：</p>
<pre><code>$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<a class="header" href="print.html#ignore-标识" id="ignore-标识"><h3><code>#[ignore]</code> 标识</h3></a>
<p>有时候，某个测试函数非常耗时，或暂时没更新，我们想不让它参与测试，但是又不想删除它，这时， <code>#[ignore]</code> 就派上用场了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
#}</code></pre></pre>
<p>写上这个，运行 <code>cargo test</code> 的时候，就不会测试这个函数。</p>
<a class="header" href="print.html#a模块级测试" id="a模块级测试"><h2>模块级测试</h2></a>
<p>有时，我们会组织一批测试用例，这时，模块化的组织结构就有助于建立结构性的测试体系。Rust 中，可以类似如下写法：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
#}</code></pre></pre>
<p>也即在 <code>mod</code> 的上面写上 <code>#[cfg(test)]</code> ，表明这个模块是个测试模块。一个测试模块中，可以包含若干测试函数，测试模块中还可以继续包含测试模块，即模块的嵌套。</p>
<p>如此，就形式了结构化的测试体系，甚是方便。</p>
<a class="header" href="print.html#a工程级测试" id="a工程级测试"><h2>工程级测试</h2></a>
<p>函数级和模块级的测试，代码是与要测试的模块（编译单元）写在相同的文件中，一般做的是白盒测试。工程级的测试，一般做的就是黑盒集成测试了。</p>
<p>我们看一个工程的目录，在这个目录下，有一个 <code>tests</code> 文件夹（没有的话，就手动建立）</p>
<pre><code>Cargo.toml
Cargo.lock
examples
src
tests
</code></pre>
<p>我们在 tests 目录下，建立一个文件 <code>testit.rs</code> ，名字随便取皆可。内容为：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
#}</code></pre></pre>
<p>这里，比如，我们 src 中，写了一个库，提供了一个 <code>add_two</code> 函数，现在进行集成测试。</p>
<p>首先，用 <code>extern crate</code> 的方式，引入这个库，由于是同一个项目，cargo 会自动找。引入后，就按模块的使用方法调用就行了，其它的测试标识与前面相同。</p>
<p>写完后，运行一下 <code>cargo test</code>，提示类似如下：</p>
<pre><code>$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<a class="header" href="print.html#a文档级测试" id="a文档级测试"><h2>文档级测试</h2></a>
<p>Rust 对文档的哲学，是不要单独写文档，一是代码本身是文档，二是代码的注释就是文档。Rust 不但可以自动抽取代码中的文档，形成标准形式的文档集合，还可以对文档中的示例代码进行测试。</p>
<p>比如，我们给上面库加点文档：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! The `adder` crate provides functions that add numbers to other numbers.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```

pub fn add_two(a: i32) -&gt; i32 {
   a + 2
}

#[cfg(test)]
mod tests {
   use super::*;

   #[test]
   fn it_works() {
      assert_eq!(4, add_two(2));
   }
}
#}</code></pre></pre>
<p>运行 <code>cargo test</code>，结果如下：</p>
<pre><code>$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>看到了吧，多了些测试结果。</p>
<a class="header" href="print.html#a结语" id="a结语"><h2>结语</h2></a>
<p>我们可以看到，Rust 对测试，对文档，对文档中的示例代码测试，都有特性支持。从这些细节之处，可以看出 Rust 设计的周密性和严谨性。</p>
<p>但是，光有好工具是不够的，工程的质量更重要的是写代码的人决定的。我们应该在 Rust 严谨之风的熏陶下，养成良好的编码和编写测试的习惯，掌握一定的分析方法，把质量要求贯彻到底。</p>
<a class="header" href="print.html#a性能测试" id="a性能测试"><h1>性能测试</h1></a>
<p>单元测试是用来校验程序的正确性的，然而，程序能正常运行后，往往还需要测试程序（一部分）的执行速度，这时，f就需要用到性能测试。
通常来讲，所谓性能测试，指的是测量程序运行的速度，即运行一次要多少时间（通常是执行多次求平均值）。Rust 竟然连这个特性都集成在语言基础特性中，真的是一门很重视工程性的语言。</p>
<p>下面直接说明如何使用。</p>
<pre><code>cargo new benchit
cd benchit
</code></pre>
<p>编辑 <code>src/lib.rs</code> 文件，在里面添加如下代码：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(test)]

#fn main() {
extern crate test;

pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &amp;mut Bencher) {
        b.iter(|| add_two(2));
    }
}
#}</code></pre></pre>
<p>注意：</p>
<ol>
<li>这里虽然使用了 <code>extern crate test;</code>，但是项目的 <code>Cargo.toml</code> 文件中依赖区并不需要添加对 <code>test</code> 的依赖；</li>
<li>评测函数 <code>fn bench_add_two(b: &amp;mut Bencher) {}</code> 上面使用 <code>#[bench]</code> 做标注，同时函数接受一个参数，<code>b</code> 就是 Rust 提供的评测器。这个写法是固定的。</li>
</ol>
<p>然后，在工程根目录下，执行</p>
<pre><code>cargo bench
</code></pre>
<p>输出结果类似如下：</p>
<pre><code>$ cargo bench
   Compiling benchit v0.0.1 (file:///home/mike/tmp/benchit)
     Running target/release/benchit-91b3e234d4ed382a

running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured
</code></pre>
<p>可以看到，Rust 的性能测试是以纳秒 ns 为单位。</p>
<p>写测评代码的时候，需要注意以下一些点：</p>
<ol>
<li>只把你需要做性能测试的代码（函数）放在评测函数中；</li>
<li>对于参与做性能测试的代码（函数），要求每次测试做同样的事情，不要做累积和改变外部状态的操作；</li>
<li>参数性能测试的代码（函数），执行时间不要太长。太长的话，最好分成几个部分测试。这也方便找出性能瓶颈所在地方。</li>
</ol>
<a class="header" href="print.html#a代码风格" id="a代码风格"><h1>代码风格</h1></a>
<a class="header" href="print.html#a空白" id="a空白"><h2>空白</h2></a>
<ul>
<li>每行不能超出99个字符。</li>
<li>缩进只用空格，不用TAB。</li>
<li>行和文件末尾不要有空白。</li>
</ul>
<a class="header" href="print.html#a空格" id="a空格"><h3>空格</h3></a>
<ul>
<li>二元运算符左右加空格，包括属性里的等号：</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[deprecated = &quot;Use `bar` instead.&quot;]
fn foo(a: usize, b: usize) -&gt; usize {
    a + b
}
#}</code></pre></pre>
<ul>
<li>在分号和逗号后面加空格：</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(a: Bar);

MyStruct { foo: 3, bar: 4 }

foo(bar, baz);
#}</code></pre></pre>
<ul>
<li>在单行语句块或<code>struct</code>表达式的开始大括号之后和结束大括号之前加空格：</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
spawn(proc() { do_something(); })

Point { x: 0.1, y: 0.3 }
#}</code></pre></pre>
<a class="header" href="print.html#a折行" id="a折行"><h3>折行</h3></a>
<ul>
<li>对于多行的函数签名，每个新行和第一个参数对齐。允许每行多个参数：</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn frobnicate(a: Bar, b: Bar,
              c: Bar, d: Bar)
              -&gt; Bar {
    ...
}

fn foo&lt;T: This,
       U: That&gt;(
       a: Bar,
       b: Bar)
       -&gt; Baz {
    ...
}
#}</code></pre></pre>
<ul>
<li>多行函数调用一般遵循和签名统一的规则。然而，如果最后的参数开始了一个语句块，块的内容可以开始一个新行，缩进一层：</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo_bar(a: Bar, b: Bar,
           c: |Bar|) -&gt; Bar {
    ...
}

// 可以在同一行：
foo_bar(x, y, |z| { z.transpose(y) });

// 也可以在新一行缩进函数体：
foo_bar(x, y, |z| {
    z.quux();
    z.rotate(x)
})
#}</code></pre></pre>
<a class="header" href="print.html#a对齐" id="a对齐"><h3>对齐</h3></a>
<p>常见代码不必在行中用多余的空格来对齐。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 好
struct Foo {
    short: f64,
    really_long: f64,
}

// 坏
struct Bar {
    short:       f64,
    really_long: f64,
}

// 好
let a = 0;
let radius = 7;

// 坏
let b        = 0;
let diameter = 7;
#}</code></pre></pre>
<a class="header" href="print.html#a避免块注释" id="a避免块注释"><h3>避免块注释</h3></a>
<p>使用行注释：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 等待主线程返回，并设置过程错误码
// 明显地。
#}</code></pre></pre>
<p>而不是：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/*
 * 等待主线程返回，并设置过程错误码
 * 明显地。
 */
#}</code></pre></pre>
<a class="header" href="print.html#a文档注释-1" id="a文档注释-1"><h2>文档注释</h2></a>
<p>文档注释前面加三个斜线(<code>///</code>)而且提示你希望将注释包含在 Rustdoc 的输出里。
它们支持 <a href="https://en.wikipedia.org/wiki/Markdown">Markdown 语言</a>
而且是注释你的公开API的主要方式。</p>
<p>支持的 markdown 功能包括列在 <a href="https://help.github.com/articles/github-flavored-markdown">GitHub Flavored Markdown</a> 文档中的所有扩展，加上上角标。</p>
<a class="header" href="print.html#a总结行" id="a总结行"><h3>总结行</h3></a>
<p>任何文档注释中的第一行应该是一行总结代码的单行短句。该行用于在 Rustdoc 输出中的一个简短的总结性描述，所以，让它短比较好。</p>
<a class="header" href="print.html#a句子结构" id="a句子结构"><h3>句子结构</h3></a>
<p>所有的文档注释，包括总结行，一个以大写字母开始，以句号、问号，或者感叹号结束。最好使用完整的句子而不是片段。</p>
<p>总结行应该以 <a href="http://en.wikipedia.org/wiki/English_verbs#Third_person_singular_present">第三人称单数陈述句形式</a> 来写。
基本上，这意味着用 &quot;Returns&quot; 而不是 &quot;Return&quot;。</p>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// 根据编译器提供的参数，设置一个缺省的运行时配置。
///
/// 这个函数将阻塞直到整个 M:N 调度器池退出了。
/// 这个函数也要求一个本地的线程可用。
///
/// # 参数
///
/// * `argc` 和 `argv` - 参数向量。在 Unix 系统上，该信息被`os::args`使用。
///
/// * `main` - 运行在 M:N 调度器池内的初始过程。
///            一旦这个过程退出，调度池将开始关闭。
///            整个池（和这个函数）将只有在所有子线程完成执行后。
///
/// # 返回值
///
/// 返回值被用作进程返回码。成功是 0，101 是错误。
#}</code></pre></pre>
<a class="header" href="print.html#a避免文档内注释" id="a避免文档内注释"><h3>避免文档内注释</h3></a>
<p>内嵌文档注释 <em>只用于</em> 注释 crates 和文件级的模块：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! 核心库。
//!
//! 核心库是...
#}</code></pre></pre>
<a class="header" href="print.html#a解释上下文" id="a解释上下文"><h3>解释上下文</h3></a>
<p>Rust 没有特定的构造器，只有返回新实例的函数。
这些在自动生成的类型文档中是不可见的，因此你应该专门链接到它们：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// An iterator that yields `None` forever after the underlying iterator
/// yields `None` once.
///
/// These can be created through
/// [`iter.fuse()`](trait.Iterator.html#method.fuse).
pub struct Fuse&lt;I&gt; {
    // ...
}
#}</code></pre></pre>
<a class="header" href="print.html#a开始的大括号总是出现的同一行" id="a开始的大括号总是出现的同一行"><h3>开始的大括号总是出现的同一行。</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    ...
}

fn frobnicate(a: Bar, b: Bar,
              c: Bar, d: Bar)
              -&gt; Bar {
    ...
}

trait Bar {
    fn baz(&amp;self);
}

impl Bar for Baz {
    fn baz(&amp;self) {
        ...
    }
}

frob(|x| {
    x.transpose()
})
#}</code></pre></pre>
<a class="header" href="print.html#match-分支有大括号除非是单行表达式" id="match-分支有大括号除非是单行表达式"><h3><code>match</code> 分支有大括号，除非是单行表达式。</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
match foo {
    bar =&gt; baz,
    quux =&gt; {
        do_something();
        do_something_else()
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#return-语句有分号" id="return-语句有分号"><h3><code>return</code> 语句有分号。</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    do_something();

    if condition() {
        return;
    }

    do_something_else();
}
#}</code></pre></pre>
<a class="header" href="print.html#a行尾的逗号" id="a行尾的逗号"><h3>行尾的逗号</h3></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
Foo { bar: 0, baz: 1 }

Foo {
    bar: 0,
    baz: 1,
}

match a_thing {
    None =&gt; 0,
    Some(x) =&gt; 1,
}
#}</code></pre></pre>
<a class="header" href="print.html#a一般命名约定" id="a一般命名约定"><h3>一般命名约定</h3></a>
<p>通常，Rust 倾向于为“类型级”结构(类型和 traits)使用 <code>CamelCase</code> 而为“值级”结构使用 <code>snake_case</code> 。更确切的约定：</p>
<table><thead><tr><th> 条目 </th><th> 约定 </th></tr></thead><tbody>
<tr><td> Crates </td><td> <code>snake_case</code> (但倾向于单个词) </td></tr>
<tr><td> Modules </td><td> <code>snake_case</code> </td></tr>
<tr><td> Types </td><td> <code>CamelCase</code> </td></tr>
<tr><td> Traits </td><td> <code>CamelCase</code> </td></tr>
<tr><td> Enum variants </td><td> <code>CamelCase</code> </td></tr>
<tr><td> Functions </td><td> <code>snake_case</code> </td></tr>
<tr><td> Methods </td><td> <code>snake_case</code> </td></tr>
<tr><td> General constructors </td><td> <code>new</code> 或 <code>with_more_details</code> </td></tr>
<tr><td> Conversion constructors </td><td> <code>from_some_other_type</code> </td></tr>
<tr><td> Local variables </td><td> <code>snake_case</code> </td></tr>
<tr><td> Static variables </td><td> <code>SCREAMING_SNAKE_CASE</code> </td></tr>
<tr><td> Constant variables </td><td> <code>SCREAMING_SNAKE_CASE</code> </td></tr>
<tr><td> Type parameters </td><td> 简洁 <code>CamelCase</code>，通常单个大写字母：<code>T</code> </td></tr>
<tr><td> Lifetimes </td><td> 短的小写: <code>'a</code> </td></tr>
</tbody></table>
<p>
在 `CamelCase`中, 首字母缩略词被当成一个单词：用 `Uuid` 而不是
`UUID`。在 `snake_case` 中，首字母缩略词全部是小写： `is_xid_start`。
<p>在 <code>snake_case</code> 或 <code>SCREAMING_SNAKE_CASE</code> 中，“单词”永远不应该只包含一个字母，
除非是最后一个“单词”。所以，我们有<code>btree_map</code> 而不是 <code>b_tree_map</code>，<code>PI_2</code> 而不是 <code>PI2</code>。</p>
<a class="header" href="print.html#a引用函数方法名中的类型" id="a引用函数方法名中的类型"><h3>引用函数/方法名中的类型</h3></a>
<p>函数名经常涉及类型名，最常见的约定例子像 <code>as_slice</code>。如果类型有一个纯粹的文本名字（忽略参数），
在类型约定和函数约定之间转换是直截了当的：</p>
<table><thead><tr><th>类型名 </th><th> 方法中的文本</th></tr></thead><tbody>
<tr><td><code>String</code>  </td><td> <code>string</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code>  </td><td> <code>vec</code></td></tr>
<tr><td><code>YourType</code></td><td> <code>your_type</code></td></tr>
</tbody></table>
<p>涉及记号的类型遵循以下约定。这些规则有重叠；应用最适用的规则：</p>
<table><thead><tr><th>类型名 </th><th> 方法中的文本</th></tr></thead><tbody>
<tr><td><code>&amp;str</code>    </td><td> <code>str</code></td></tr>
<tr><td><code>&amp;[T]</code>    </td><td> <code>slice</code></td></tr>
<tr><td><code>&amp;mut [T]</code></td><td> <code>mut_slice</code></td></tr>
<tr><td><code>&amp;[u8]</code>   </td><td> <code>bytes</code></td></tr>
<tr><td><code>&amp;T</code>      </td><td> <code>ref</code></td></tr>
<tr><td><code>&amp;mut T</code>  </td><td> <code>mut</code></td></tr>
<tr><td><code>*const T</code></td><td> <code>ptr</code></td></tr>
<tr><td><code>*mut T</code>  </td><td> <code>mut_ptr</code></td></tr>
</tbody></table>
<a class="header" href="print.html#a避免冗余的前缀" id="a避免冗余的前缀"><h3>避免冗余的前缀</h3></a>
<p>一个模块中的条目的名字不应拿模块的名字做前缀：</p>
<p>倾向于</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    pub struct Error { ... }
}
#}</code></pre></pre>
<p>而不是</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    pub struct FooError { ... }
}
#}</code></pre></pre>
<p>这个约定避免了口吃（像 <code>io::IoError</code>）。库客户端可以在导入时重命名以避免冲突。</p>
<a class="header" href="print.html#gettersetter-方法" id="gettersetter-方法"><h3>Getter/setter 方法</h3></a>
<p>一些数据类型不希望提供对它们的域的直接访问，但是提供了 &quot;getter&quot; 和 &quot;setter&quot; 方法用于操纵域状态
（经常提供检查或其他功能）。</p>
<p>域 <code>foo: T</code> 的约定是：</p>
<ul>
<li>方法 <code>foo(&amp;self) -&gt; &amp;T</code> 用于获得该域的当前值。</li>
<li>方法 <code>set_foo(&amp;self, val: T)</code> 用于设置域。（这里的 <code>val</code> 参数可能取 <code>&amp;T</code> 或其他类型，取决于上下文。）</li>
</ul>
<p>请注意，这个约定是关于通常数据类型的 getters/setters， <em>不是</em> 关于构建者对象的。</p>
<a class="header" href="print.html#a断言" id="a断言"><h3>断言</h3></a>
<ul>
<li>简单的布尔断言应该加上 <code>is_</code> 或者其他的简短问题单词作为前缀，e.g.， <code>is_empty</code>。</li>
<li>常见的例外： <code>lt</code>， <code>gt</code>，和其他已经确认的断言名。</li>
</ul>
<a class="header" href="print.html#a导入" id="a导入"><h3>导入</h3></a>
<p>一个 crate/模块的导入应该按顺序包括下面各个部分，之间以空行分隔：</p>
<ul>
<li><code>extern crate</code> 指令</li>
<li>外部 <code>use</code> 导入</li>
<li>本地 <code>use</code> 导入</li>
<li><code>pub use</code> 导入</li>
</ul>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Crates.
extern crate getopts;
extern crate mylib;

// 标准库导入。
use getopts::{optopt, getopts};
use std::os;

// 从一个我们写的库导入。
use mylib::webserver;

// 当我们导入这个模块时会被重新导出。
pub use self::types::Webdata;
#}</code></pre></pre>
<a class="header" href="print.html#a避免-use-除非在测试里" id="a避免-use-除非在测试里"><h3>避免 <code>use *</code>，除非在测试里</h3></a>
<p>Glob 导入有几个缺点：</p>
<ul>
<li>更难知道名字在哪里绑定。</li>
<li>它们前向不兼容，因为新的上流导出可能与现存的名字冲突。</li>
</ul>
<p>在写 <code>test</code> 子模块时，为方便导入 <code>super::*</code> 是合适的。</p>
<a class="header" href="print.html#a当模块限定函数时倾向于完全导入类型traits" id="a当模块限定函数时倾向于完全导入类型traits"><h3>当模块限定函数时，倾向于完全导入类型/traits。</h3></a>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use option::Option;
use mem;

let i: isize = mem::transmute(Option(0));
#}</code></pre></pre>
<a class="header" href="print.html#a在-crate-级重新导出最重要的类型" id="a在-crate-级重新导出最重要的类型"><h3>在 crate 级重新导出最重要的类型。</h3></a>
<p>Crates <code>pub use</code> 最常见的类型为方便，因此，客户端不必记住或写 crate 的模块结构以使用这些类型。</p>
<a class="header" href="print.html#a类型和操作在一起定义" id="a类型和操作在一起定义"><h3>类型和操作在一起定义。</h3></a>
<p>类型定义和使用它们的函数/模块应该在同一模块中定义，类型出现在函数/模块前面。</p>
<a class="header" href="print.html#any和反射" id="any和反射"><h1>Any和反射</h1></a>
<p>熟悉Java的同学肯定对Java的反射能力记忆犹新，同样的，Rust也提供了运行时反射的能力。但是，这里有点小小的不同，因为 Rust 不带 VM 不带 Runtime ,因此，其提供的反射更像是一种编译时反射。</p>
<p>因为，Rust只能对 <code>'static</code> 生命周期的变量（常量）进行反射！</p>
<a class="header" href="print.html#a举个例子" id="a举个例子"><h2>举个例子</h2></a>
<p>我们会有这样的需求，去某些路径里加载配置文件。我们可能提供一个配置文件路径，好吧，这是个字符串(<code>String</code>)。但是，当我想要传入多个配置文件的路径的时候怎们办？理所应当的，我们传入了一个数组。</p>
<p>这下可坏了……Rust不支持重载啊！于是有人就很单纯的写了两个函数～～！</p>
<p>其实不用……我们只需要这么写……</p>
<pre><pre class="playpen"><code class="language-rust">use std::any::Any;
use std::fmt::Debug ;

fn load_config&lt;T:Any+Debug&gt;(value: &amp;T) -&gt; Vec&lt;String&gt;{
    let mut cfgs: Vec&lt;String&gt;= vec![];
    let value = value as &amp;Any;
    match value.downcast_ref::&lt;String&gt;() {
        Some(cfp) =&gt; cfgs.push(cfp.clone()),
        None =&gt; (),
    };

    match value.downcast_ref::&lt;Vec&lt;String&gt;&gt;() {
        Some(v) =&gt; cfgs.extend_from_slice(&amp;v),
        None =&gt;(),
    }

    if cfgs.len() == 0 {
        panic!(&quot;No Config File&quot;);
    }
    cfgs
}

fn main() {
    let cfp = &quot;/etc/wayslog.conf&quot;.to_string();
    assert_eq!(load_config(&amp;cfp), vec![&quot;/etc/wayslog.conf&quot;.to_string()]);
    let cfps = vec![&quot;/etc/wayslog.conf&quot;.to_string(),
                    &quot;/etc/wayslog_sec.conf&quot;.to_string()];
    assert_eq!(load_config(&amp;cfps),
               vec![&quot;/etc/wayslog.conf&quot;.to_string(),
                    &quot;/etc/wayslog_sec.conf&quot;.to_string()]);
}
</code></pre></pre>
<p>我们来重点分析一下中间这个函数：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn load_config&lt;T:Any+Debug&gt;(value: &amp;T) -&gt; Vec&lt;String&gt;{..}
#}</code></pre></pre>
<p>首先，这个函数接收一个泛型<code>T</code>类型，<code>T</code>必须实现了<code>Any</code>和<code>Debug</code>。</p>
<p>这里可能有同学疑问了，你不是说只能反射 <code>'static</code> 生命周期的变量么？我们来看一下<code>Any</code>限制：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Any: 'static + Reflect {
    fn get_type_id(&amp;self) -&gt; TypeId;
}
#}</code></pre></pre>
<p>看，<code>Any</code>在定义的时候就规定了其生命周期，而<code>Reflect</code>是一个Marker，默认所有的Rust类型都会实现他！注意，这里不是所有原生类型，而是所有类型。</p>
<p>好的，继续，由于我们无法判断出传入的参数类型，因此，只能从运行时候反射类型。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let value = value as &amp;Any;
#}</code></pre></pre>
<p>首先，我们需要将传入的类型转化成一个 <code>trait Object</code>, 当然了，你高兴的话用 <code>UFCS</code> 也是可以做的，参照本章最后的附录。</p>
<p>这样，value 就可以被堪称一个 Any 了。然后，我们通过 <code>downcast_ref</code> 来进行类型推断。如果类型推断成功，则 value 就会被转换成原来的类型。</p>
<p>有的同学看到这里有点懵，为什么你都转换成 Any 了还要转回来？</p>
<p>其实，转换成 Any 是为了有机会获取到他的类型信息，转换回来，则是为了去使用这个值本身。</p>
<p>最后，我们对不同的类型处以不同的处理逻辑。最终，一个反射函数就完成了。</p>
<a class="header" href="print.html#a说说注意的地方" id="a说说注意的地方"><h2>说说注意的地方</h2></a>
<p>需要注意的是，Rust本身提供的反射能力并不是很强大。相对而言只能作为一个辅助的手段。并且，其只能对<code>'static</code>周期进行反射的限制，的确限制了其发挥。还有一点需要注意的是，Rust的反射只能被用作类型推断，绝对不能被用作接口断言！</p>
<p>啥，你问原因？因为写不出来啊……</p>
<a class="header" href="print.html#a安全safety" id="a安全safety"><h1>安全（Safety）</h1></a>
<p>本章不讲解任何语言知识点，而是对 Rust 安全理念的一些总结性说明。</p>
<p>安全，本身是一个相当大的话题。安全性，本身也需要一个局部性的定义。</p>
<p>Rust 的定义中，凡是 <strong>可能</strong> 会导致程序内存使用出错的特性，都被认为是 <strong>不安全的（unsafe）</strong>。反之，则是 <strong>安全的（safe）</strong>。</p>
<p>基于这种定义，C 语言，基本是不安全的语言（它是众多不安全特性的集合。特别是指针相关特性，多线程相关特性）。</p>
<p>Rust 的这个定义，隐含了一个先决假设：人之初，性本恶。人是不可靠的，人是会犯错误的，即 Rust 不相信人的实施过程。在这一点上，C 语言的理念与之完全相反：C 语言完全相信人，人之初，性本善，由人进行完全地控制。</p>
<p>根据 Rust 的定义，C 语言几乎是不安全的代名字。但是，从本质上来说，一段程序是否安全，并不由开发它的语言决定。用 C 语言开发出的程序，不一定就是不安全的代码，只不过相对来说，需要花更多的精力进行良好的设计和长期的实际运行验证。Rust 使开发出安全可靠的代码相对容易了。</p>
<p>世界本身是肮脏的。正如，纯函数式语言中还必须有用于处理副作用的 <code>Monad</code> 存在一样，Rust 仅凭安全的特性集合，也是无法处理世界的所有结构和问题的。所以，Rust 中，还有 <code>unsafe</code> 部分的存在。实际上，Rust 的 std 本身也是建立在大量 <code>unsafe</code> 代码的基础之上的。所以，世界就是纯粹建立在不纯粹之上，“安全”建立在“不安全”之上。</p>
<p>因此，Rust 本身可以被认为是两种编程语言的混合：<code>Safe Rust</code> 和 <code>Unsafe Rust</code>。</p>
<p>只使用 <code>Safe Rust</code> 的情况下，你不需要担心任何类型安全性和内存安全性的问题。你永远不用忍受空指针，悬挂指针或其它可能的未定义行为的干扰。</p>
<p><code>Unsafe Rust</code> 在 <code>Safe Rust</code> 的所有特性上，只给程序员开放了以下四种能力：</p>
<ol>
<li>对原始指针进行解引（Dereference raw pointers）；</li>
<li>调用 <code>unsafe</code> 函数（包括 C 函数，内部函数，和原始分配器）；</li>
<li>实现 <code>unsafe</code> traits；</li>
<li>修改（全局）静态变量。</li>
</ol>
<p>上述这四种能力，如果误用的话，会导致一些未定义行为，具有不确定后果，很容易引起程序崩溃。</p>
<p>Rust 中定义的不确定性行为有如下一些：</p>
<ol>
<li>对空指针或悬挂指针进行解引用；</li>
<li>读取未初始化的内存；</li>
<li>破坏指针重命名规则（比如同一资源的 <code>&amp;mut</code> 引用不能出现多次，<code>&amp;mut</code> 与 <code>&amp;</code> 不能同时出现）；</li>
<li>产生无效的原生值：</li>
</ol>
<ul>
<li>空指针，悬挂指针；</li>
<li>bool 值不是 0 或 1；</li>
<li>未定义的枚举取值；</li>
<li>char 值超出取值范围 [0x0, 0xD7FF] 和 [0xE000, 0x10FFFF]；</li>
<li>非 utf-8 字符串；</li>
</ul>
<ol start="5">
<li>Unwinding 到其它语言中；</li>
<li>产生一个数据竞争。</li>
</ol>
<p>以下一些情况，Rust 认为不属于安全性的处理范畴，即认为它们是“安全”的：</p>
<ol>
<li>死锁；</li>
<li>存在竞争条件；</li>
<li>内存泄漏；</li>
<li>调用析构函数失败；</li>
<li>整数溢出；</li>
<li>程序被中断；</li>
<li>删除产品数据库（:D）；</li>
</ol>
<a class="header" href="print.html#a参考-1" id="a参考-1"><h2>参考</h2></a>
<p>下面一些链接，给出了安全性更详细的讲解（部分未来会有对应的中文翻译）。</p>
<ul>
<li><a href="http://doc.rust-lang.org/book/unsafe.html">Unsafe</a></li>
<li><a href="http://doc.rust-lang.org/nightly/nomicon/meet-safe-and-unsafe.html">Meet Safe and Unsafe</a></li>
<li><a href="http://doc.rust-lang.org/nightly/nomicon/safe-unsafe-meaning.html">How Safe and Unsafe Interact</a></li>
<li><a href="http://jimhuang.cn/2015/09/12/%E8%93%A6%E7%84%B6%E5%9B%9E%E9%A6%96%E4%B8%87%E4%BA%8B%E7%A9%BA%20%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%A9%BA%E6%8C%87%E9%92%88%E6%BC%AB%E8%B0%88/">蓦然回首万事空 ————空指针漫谈</a></li>
</ul>
<a class="header" href="print.html#a标准库示例" id="a标准库示例"><h1>标准库示例</h1></a>
<p>好了，本书到这里也接近完结了。相信你一在学习了这么多内容的之后，一定跃跃欲试了吧？
下面，我们将以代码为主，讲解几个利用<code>std</code>库，即标准库来做的例子。希望大家能从中学到一点写法，并开始自己的Rust之旅。</p>
<ul>
<li>注： 由于笔者的电脑是openSUSE Linux的，所以本章所有代码均只在 <code>openSUSE Leap 42.1 &amp;&amp; rustc 1.9.0-nightly (52e0bda64 2016-03-05)</code> 下编译通过，对Linux适配可能会更好一点，其他系统的同学请自行参照。</li>
</ul>
<p>另：本章原本设计的时候附加有时间api的处理，但是在本章写作的时候Rust的大部分时间API还处于Unstable状态，随时可能遭到删除或重写。因此，我们暂时删除了时间API的操作。等以后Rust的API稳定之后，再来补齐这一节。</p>
<ol>
<li><a href="process.md">系统命令:调用grep</a></li>
<li><a href="fs-and-path.md">目录操作:简单grep</a></li>
<li><a href="net.md">网络模块:W回音</a></li>
</ol>
<a class="header" href="print.html#a系统命令调用grep" id="a系统命令调用grep"><h1>系统命令:调用grep</h1></a>
<p>我们知道，Linux系统中有一个命令叫grep，他能对目标文件进行分析并查找相应字符串，并该字符串所在行输出。
今天，我们先来写一个Rust程序，来调用一下这个 grep 命令</p>
<pre><pre class="playpen"><code class="language-rust">use std::process::*;
use std::env::args;

// 实现调用grep命令搜索文件
fn main() {
    let mut arg_iter = args();
    // panic if there is no one
    arg_iter.next().unwrap();
    let pattern = arg_iter.next().unwrap_or(&quot;main&quot;.to_string());
    let pt =  arg_iter.next().unwrap_or(&quot;./&quot;.to_string());
    let output = Command::new(&quot;/usr/bin/grep&quot;)
        .arg(&quot;-n&quot;)
        .arg(&quot;-r&quot;)
        .arg(&amp;pattern)
        .arg(&amp;pt)
        .output()
        .unwrap_or_else(|e| panic!(&quot;wg panic because:{}&quot;, e));
    println!(&quot;output:&quot;);
    let st = String::from_utf8_lossy(&amp;output.stdout);
    let lines = st.split(&quot;\n&quot;);
    for line in lines {
        println!(&quot;{}&quot;, line);
    }
}

</code></pre></pre>
<p>看起来好像还不错，但是，以上的程序有一个比较致命的缺点——因为Output是同步的，因此，一旦调用的目录下有巨大的文件，grep的分析将占用巨量的时间。这对于一个高可用的程序来说是不被允许的。</p>
<p>那么如何改进呢？</p>
<p>其实在上面的代码中，我们隐藏了一个 <code>Child</code> 的概念，即——子进程。</p>
<p>下面我来演示怎么操作子进程：</p>
<pre><pre class="playpen"><code class="language-rust">use std::process::*;
use std::env::args;

// 实现调用grep命令搜索文件
fn main() {
    let mut arg_iter = args();
    // panic if there is no one
    arg_iter.next();
    let pattern = arg_iter.next().unwrap_or(&quot;main&quot;.to_string());
    let pt =  arg_iter.next().unwrap_or(&quot;./&quot;.to_string());
    let child = Command::new(&quot;grep&quot;)
        .arg(&quot;-n&quot;)
        .arg(&quot;-r&quot;)
        .arg(&amp;pattern)
        .arg(&amp;pt)
        .spawn().unwrap();
    // 做些其他的事情
    std::thread::sleep_ms(1000);
    println!(&quot;{}&quot;, &quot;计算很费时间……&quot;);
    let out = child.wait_with_output().unwrap();
    let out_str = String::from_utf8_lossy(&amp;out.stdout);
    for line in out_str.split(&quot;\n&quot;) {
        println!(&quot;{}&quot;, line);
    }
}

</code></pre></pre>
<p>但是，这个例子和我们预期的并不太一样！</p>
<pre><code>./demo main /home/wayslog/rust/demo/src
/home/wayslog/rust/demo/src/main.rs:5:fn main() {
/home/wayslog/rust/demo/src/main.rs:9:    let pattern = arg_iter.next().unwrap_or(&quot;main&quot;.to_string());
计算很费时间……

</code></pre>
<p>为什么呢？</p>
<p>很简单，我们知道，在Linux中，<code>fork</code>出来的函数会继承父进程的所有句柄。因此，子进程也就会继承父进程的标准输出，也就是造成了这样的问题。这也是最后我们用out无法接收到最后的输出也就知道了，因为在前面已经被输出出来了呀！</p>
<p>那么怎么做呢？给这个子进程一个pipeline就好了！</p>
<pre><pre class="playpen"><code class="language-rust">use std::process::*;
use std::env::args;

// 实现调用grep命令搜索文件
fn main() {
    let mut arg_iter = args();
    // panic if there is no one
    arg_iter.next();
    let pattern = arg_iter.next().unwrap_or(&quot;main&quot;.to_string());
    let pt =  arg_iter.next().unwrap_or(&quot;./&quot;.to_string());
    let child = Command::new(&quot;grep&quot;)
        .arg(&quot;-n&quot;)
        .arg(&quot;-r&quot;)
        .arg(&amp;pattern)
        .arg(&amp;pt)
        // 设置pipeline
        .stdout(Stdio::piped())
        .spawn().unwrap();
    // 做些其他的事情
    std::thread::sleep_ms(1000);
    println!(&quot;{}&quot;, &quot;计算很费时间……&quot;);
    let out = child.wait_with_output().unwrap();
    let out_str = String::from_utf8_lossy(&amp;out.stdout);
    for line in out_str.split(&quot;\n&quot;) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre></pre>
<p>这段代码相当于给了<code>stdout</code>一个缓冲区，这个缓冲区直到我们计算完成之后才被读取，因此就不会造成乱序输出的问题了。</p>
<p>这边需要注意的一点是，一旦你开启了一个子进程，那么，无论你程序是怎么处理的，最后一定要记得对这个<code>child</code>调用<code>wait</code>或者<code>wait_with_output</code>，除非你显式地调用<code>kill</code>。因为如果父进程不<code>wait</code>它的话，它将会变成一个僵尸进程！！！</p>
<p><em>注</em>： 以上问题为Linux下Python多进程的日常问题，已经见怪不怪了。</p>
<a class="header" href="print.html#a目录操作简单grep" id="a目录操作简单grep"><h1>目录操作:简单grep</h1></a>
<p>上一节我们实现了通过<code>Command</code>调用subprocess。这一节，我们将通过自己的代码去实现一个简单的grep。当然了，这种基础的工具你是能找到源码的，而我们的实现也并不像真正的grep那样注重效率，本节的主要作用就在于演示标准库API的使用。</p>
<p>首先，我们需要对当前目录进行递归，遍历，每当查找到文件的时候，我们回调一个函数。</p>
<p>于是，我们就有了这么个函数：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::env::args;
use std::io;
use std::fs::{self, File, DirEntry};
use std::path::Path;

fn visit_dirs(dir: &amp;Path, pattern: &amp;String, cb: &amp;Fn(&amp;DirEntry, &amp;String)) -&gt; io::Result&lt;()&gt; {
    if try!(fs::metadata(dir)).is_dir() {
        for entry in try!(fs::read_dir(dir)) {
            let entry = try!(entry);
            if try!(fs::metadata(entry.path())).is_dir() {
                try!(visit_dirs(&amp;entry.path(), pattern, cb));
            } else {
                cb(&amp;entry, pattern);
            }
        }
    }else{
        let entry = try!(try!(fs::read_dir(dir)).next().unwrap());
        cb(&amp;entry, pattern);
    }
    Ok(())
}

#}</code></pre></pre>
<p>我们有了这样的一个函数，有同学可能觉得这代码眼熟。这不是标准库里的例子改了一下么？</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>是啊！</p>
<p>好了，继续，我们需要读取每个查到的文件，同时判断每一行里有没有所查找的内容。
我们用一个BufferIO去读取各个文件，同时用String的自带方法来判断内容是否存在。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_back(de: &amp;DirEntry, pt: &amp;String) {
    let mut f = File::open(de.path()).unwrap();
    let mut buf = io::BufReader::new(f);
    for line in io::BufRead::lines(buf) {
        let line = line.unwrap_or(&quot;&quot;.to_string());
        if line.contains(pt) {
            println!(&quot;{}&quot;, &amp;line);
        }
    }
}
#}</code></pre></pre>
<p>最后，我们将整个函数调用起来，如下：</p>
<pre><pre class="playpen"><code class="language-rust">use std::env::args;
use std::io;
use std::fs::{self, File, DirEntry};
use std::path::Path;

fn visit_dirs(dir: &amp;Path, pattern: &amp;String, cb: &amp;Fn(&amp;DirEntry, &amp;String)) -&gt; io::Result&lt;()&gt; {
    if try!(fs::metadata(dir)).is_dir() {
        for entry in try!(fs::read_dir(dir)) {
            let entry = try!(entry);
            if try!(fs::metadata(entry.path())).is_dir() {
                try!(visit_dirs(&amp;entry.path(), pattern, cb));
            } else {
                cb(&amp;entry, pattern);
            }
        }
    }else{
        let entry = try!(try!(fs::read_dir(dir)).next().unwrap());
        cb(&amp;entry, pattern);
    }
    Ok(())
}

fn call_back(de: &amp;DirEntry, pt: &amp;String) {
    let mut f = File::open(de.path()).unwrap();
    let mut buf = io::BufReader::new(f);
    for line in io::BufRead::lines(buf) {
        let line = line.unwrap_or(&quot;&quot;.to_string());
        if line.contains(pt) {
            println!(&quot;{}&quot;, &amp;line);
        }
    }
}

// 实现调用grep命令搜索文件
fn main() {
    let mut arg_iter = args();
    arg_iter.next();
    // panic if there is no one
    let pattern = arg_iter.next().unwrap_or(&quot;main&quot;.to_string());
    let pt =  arg_iter.next().unwrap_or(&quot;./&quot;.to_string());
    let pt = Path::new(&amp;pt);
    visit_dirs(&amp;pt, &amp;pattern, &amp;call_back).unwrap();
}

</code></pre></pre>
<p>调用如下：</p>
<pre><code>➜  demo git:(master) ✗ ./target/debug/demo &quot;fn main()&quot; ../
fn main() {
fn main() { }
fn main() {
    pub fn main() {
    pub fn main() {}
fn main() {
    pub fn main() {
    pub fn main() {}
</code></pre>
<a class="header" href="print.html#a网络模块w猫的回音" id="a网络模块w猫的回音"><h1>网络模块:W猫的回音</h1></a>
<p>本例子中，W猫将带大家写一个大家都写过但是没什么人用过的TCP ECHO软件，作为本章的结尾。本程序仅作为实例程序，我个人估计也没有人在实际的生活中去使用她。不过，作为标准库的示例来说，已经足够。</p>
<p>首先，我们需要一个一个服务器端。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn server&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; io::Result&lt;()&gt; {
    // 建立一个监听程序
    let listener = try!(TcpListener::bind(&amp;addr)) ;
    // 这个程序一次只需处理一个链接就好
    for stream in listener.incoming() {
        // 通过match再次解包 stream到
        match stream {
            // 这里匹配的重点是如何将一个mut的匹配传给一个Result
            Ok(mut st) =&gt; {
                // 我们总是要求client端先发送数据
                // 准备一个超大的缓冲区
                // 当然了，在实际的生活中我们一般会采用环形缓冲来重复利用内存。
                // 这里仅作演示，是一种很低效的做法
                let mut buf: Vec&lt;u8&gt; = vec![0u8; 1024];
                // 通过try!方法来解包
                // try!方法的重点是需要有特定的Error类型与之配合
                let rcount = try!(st.read(&amp;mut buf));
                // 只输出缓冲区里读取到的内容
                println!(&quot;{:?}&quot;, &amp;buf[0..rcount]);
                // 回写内容
                let wcount = try!(st.write(&amp;buf[0..rcount]));
                // 以下代码实际上算是逻辑处理
                // 并非标准库的一部分了
                if rcount != wcount {
                    panic!(&quot;Not Fully Echo!, r={}, w={}&quot;, rcount, wcount);
                }
                // 清除掉已经读到的内容
                buf.clear();
            }
            Err(e) =&gt; {
                panic!(&quot;{}&quot;, e);
            }
        }
    }
    // 关闭掉Serve端的链接
    drop(listener);
    Ok(())
}

#}</code></pre></pre>
<p>然后，我们准备一个模拟TCP短链接的客户端：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn client&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; io::Result&lt;()&gt; {

    let mut buf = vec![0u8;1024];
    loop {
        // 对比Listener，TcpStream就简单很多了
        // 本次模拟的是tcp短链接的过程，可以看作是一个典型的HTTP交互的基础IO模拟
        // 当然，这个通讯里面并没有HTTP协议 XD！
        let mut stream = TcpStream::connect(&amp;addr).unwrap();
        let msg = &quot;WaySLOG comming!&quot;.as_bytes();
        // 避免发送数据太快而刷屏
        thread::sleep_ms(100);
        let rcount = try!(stream.write(&amp;msg));
        let _ = try!(stream.read(&amp;mut buf));
        println!(&quot;{:?}&quot;, &amp;buf[0..rcount]);
        buf.clear();
    }
    Ok(())
}

#}</code></pre></pre>
<p>将我们的程序拼接起来如下：</p>
<pre><pre class="playpen"><code class="language-rust">use std::net::*;
use std::io;
use std::io::{Read, Write};
use std::env;
use std::thread;

fn server&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; io::Result&lt;()&gt; { .. }


fn client&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; io::Result&lt;()&gt; { .. }


fn main() {
    let mut args = env::args();
    args.next();
    let action = args.next().unwrap();
    if action == &quot;s&quot; {
        server(&amp;args.next().unwrap()).unwrap();
    } else {
        client(&amp;args.next().unwrap()).unwrap();
    }
}

</code></pre></pre>
<p>各位可以自己试一下结果</p>
<p>写网络程序，注定了要处理各种神奇的条件和错误，定义自己的数据结构，粘包问题等都是需要我们去处理和关注的。相较而言，Rust本身在网络方面的基础设施建设并不尽如人意，甚至连网络I/O都只提供了如上的block I/O 。可能其团队更关注于语言基础语法特性和编译的改进，但其实，有着官方出品的这种网络库是非常重要的。同时，我也希望Rust能够涌现出更多的网络库方案，让Rust的明天更好更光明。</p>
<a class="header" href="print.html#a实战篇" id="a实战篇"><h1>实战篇</h1></a>
<p>本章举 3 个实际中的例子，来小小展示一下 Rust 在实际中的应用。它们分别是：</p>
<ul>
<li>Json处理</li>
<li>Web 应用开发入门</li>
<li>使用Postgresql数据库</li>
</ul>
<a class="header" href="print.html#rust-json处理" id="rust-json处理"><h1>Rust json处理</h1></a>
<p>JSON是一种比较重要的格式，尤其是现在的web开发领域，JSON相比于传统的XML更加容易操作和减小传输。</p>
<p>Rust中的JSON处理依赖 cargo 中的rustc-serialize模块</p>
<p>###先简单的创建一个Rust项目工程</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
$ cargo new json_data --bin
#}</code></pre></pre>
<p>生成文件树：</p>
<pre><code class="language-shell">vagrant@ubuntu-14:~/tmp/test/rustprimer$ tree
.
`-- json_data
    |-- Cargo.toml
    `-- src
        `-- main.rs


</code></pre>
<p>生成项目<code>json_data</code>,项目下文件介绍：</p>
<ul>
<li>Caogo.toml ，文件中填写一些项目的相关信息，比如版本号，联系人，项目名，文件的内容如下：</li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;json_data&quot;
version = &quot;0.1.0&quot;
authors = [&quot;wangxxx &lt;xxxxx@qq.com&gt;&quot;]

[dependencies]

</code></pre>
<ul>
<li>src 中放置项目的源代码，main.rs 为项目的入口文件。</li>
</ul>
<p>###一些必要的了解</p>
<p>rustc-serialize 这个是第三方的模块，需要从<a href="https://crates.io/crates/rustc-serialize">cargo</a>下载。
下载很简单，只需修改一下cargo.toml文件就行了.</p>
<pre><code class="language-toml">[package]
name = &quot;json_data&quot;
version = &quot;0.1.0&quot;
authors = [&quot;wangxxx &lt;xxxxx@qq.com&gt;&quot;]

[dependencies]
rustc-serialize = &quot;0.3.18&quot;

</code></pre>
<p>然后执行在当前目录执行:</p>
<pre><code>$ cargo build
</code></pre>
<p><em>注意一个问题由于国内网络访问github不稳定，这些第三方库很多托管在github上，所以可能需要修改你的
网络访问</em></p>
<ol>
<li>在安装Rust之后，会在你的用户目录之下生成一个<code>.cargo</code>文件夹，进入这个文件夹</li>
<li>在<code>.cargo</code>文件夹下，创建一个<code>config</code>文件，在文件中填写中科大软件源，可能以后会出现其他的源，先用这个</li>
<li><code>config</code>文件内容如下</li>
</ol>
<pre><code class="language-toml">[registry]
index = &quot;git://crates.mirrors.ustc.edu.cn/index&quot;

</code></pre>
<p>cargo build 执行之后的提示信息</p>
<pre><code>   Updating registry `git://crates.mirrors.ustc.edu.cn/index`
 Downloading rustc-serialize v0.3.18 (registry git://crates.mirrors.ustc.edu.cn/index)
   Compiling rustc-serialize v0.3.18 (registry git://crates.mirrors.ustc.edu.cn/index)
   Compiling json_data v0.1.0 (file:///home/vagrant/tmp/test/rustprimer/json_data)
</code></pre>
<p>再次执行tree命令:</p>
<pre><code>.
|-- Cargo.lock
|-- Cargo.toml
|-- src
|   `-- main.rs
`-- target
    `-- debug
        |-- build
        |-- deps
        |   `-- librustc_serialize-d27006e102b906b6.rlib
        |-- examples
        |-- json_data
        `-- native

</code></pre>
<p>可以看到多了很多文件，重点关注<code>cargo.lock</code>,开打文件:</p>
<pre><code class="language-toml">[root]
name = &quot;json_data&quot;
version = &quot;0.1.0&quot;
dependencies = [
 &quot;rustc-serialize 0.3.18 (registry+git://crates.mirrors.ustc.edu.cn/index)&quot;,
]

[[package]]
name = &quot;rustc-serialize&quot;
version = &quot;0.3.18&quot;
source = &quot;registry+git://crates.mirrors.ustc.edu.cn/index&quot;

</code></pre>
<p>是关于项目编译的一些依赖信息</p>
<p>还有生成了target文件夹，生成了可执行文件json_data,因为main.rs中的执行结果就是打印<code>hello world</code></p>
<pre><code>$ cargo run

Hello, world!
</code></pre>
<p>###开始写代码
直接使用官方的 <a href="https://doc.rust-lang.org/rustc-serialize/rustc_serialize/json/index.html#using-autoserialization">rustc_serialize 中的例子</a>：</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rustc_serialize;
// 引入rustc_serialize模块
use rustc_serialize::json;

// Automatically generate `RustcDecodable` and `RustcEncodable` trait
// implementations
// 定义TestStruct
#[derive(RustcDecodable, RustcEncodable)]
pub struct TestStruct  {
    data_int: u8,
    data_str: String,
    data_vector: Vec&lt;u8&gt;,
}

fn main() {
    // 初始化TestStruct
    let object = TestStruct {
        data_int: 1,
        data_str: &quot;homura&quot;.to_string(),
        data_vector: vec![2,3,4,5],
    };

    // Serialize using `json::encode`
    // 将TestStruct转意为字符串
    let encoded = json::encode(&amp;object).unwrap();
    println!(&quot;{}&quot;,encoded);
    // Deserialize using `json::decode`
    // 将json字符串中的数据转化成TestStruct对应的数据，相当于初始化
    let decoded: TestStruct = json::decode(&amp;encoded).unwrap();
    println!(&quot;{:?}&quot;,decoded.data_vector);
}

</code></pre></pre>
<p>当然我们也可以在文本中作为api的返回结果使用，下来的章节中，我们将讨论这个问题</p>
<a class="header" href="print.html#rust-web-开发" id="rust-web-开发"><h1>rust web 开发</h1></a>
<p>rust既然是系统级的编程语言，所以当然也能用来开发 web,不过想我这样凡夫俗子，肯定不能从头自己写一个 web
服务器，肯定要依赖已经存在的 rust web开发框架来完成 web 开发。</p>
<p>rust目前比较有名的框架是iron和nickel，我们两个都写一下简单的使用教程。</p>
<p>##iron</p>
<p>接上一篇，使用cargo获取第三方库。<code>cargo new mysite --bin</code></p>
<p>在cargo.toml中添加iron的依赖，</p>
<pre><code class="language-toml">[dependencies]
iron = &quot;*&quot;
</code></pre>
<p>然后build将依赖下载到本地 <code>cargo build</code></p>
<p>如果报ssl错误，那可能你需要安装linux的ssl开发库。</p>
<p>首先还是从 hello world 开始吧,继续抄袭官方的例子：</p>
<pre><pre class="playpen"><code class="language-rust">extern crate iron;

use iron::prelude::*;
use iron::status;

fn main() {
    Iron::new(|_: &amp;mut Request| {
        Ok(Response::with((status::Ok, &quot;Hello World!&quot;)))
    }).http(&quot;localhost:3000&quot;).unwrap();
}
</code></pre></pre>
<p>然后运行</p>
<p><code>cargo run</code></p>
<p>使用curl直接就可以访问你的网站了。</p>
<p><code>curl localhost:3000</code></p>
<p><code>Hello World!</code></p>
<p>仔细一看，发现这个例子很无厘头啊，对于习惯了写python的我来说，确实不习惯。
简单点看：</p>
<p><code>iron::new().http(&quot;localhost:3000&quot;).unwrap()</code>
这句是服务器的基本的定义，new内部是一个<a href="https://doc.rust-lang.org/book/closures.html">rust lambda 表达式</a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
#}</code></pre></pre>
<p>具体的怎么使用 ，可以暂时不用理会，因为你只要知道如何完成web，因为我也不会。。
结合之前一章节的json处理，我们来看看web接口怎么返回json,当然也要 rustc_serialize 放到 cargo.toml 中</p>
<p><em>下面的代码直接参考开源代码<a href="https://github.com/brson/httptest#lets-make-a-web-service-and-client-in-rust">地址</a></em></p>
<pre><pre class="playpen"><code class="language-rust">extern crate iron;
extern crate rustc_serialize;

use iron::prelude::*;
use iron::status;
use rustc_serialize::json;

#[derive(RustcEncodable)]
struct Greeting {
    msg: String
}

fn main() {
    fn hello_world(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
        let greeting = Greeting { msg: &quot;Hello, World&quot;.to_string() };
        let payload = json::encode(&amp;greeting).unwrap();
        Ok(Response::with((status::Ok, payload)))
    }

    Iron::new(hello_world).http(&quot;localhost:3000&quot;).unwrap();
    println!(&quot;On 3000&quot;);
}
</code></pre></pre>
<p>执行 cargo run 使用 curl 测试结果:</p>
<pre><code>curl localhost:3000
{&quot;msg&quot;:&quot;Hello, World&quot;}
</code></pre>
<p>当然可以可以实现更多的业务需求，通过控制自己的json。</p>
<p>既然有了json了，如果要多个路由什么的，岂不是完蛋了，所以不可能这样的，我们需要考虑一下怎么实现路由的定制</p>
<p>不说话直接上代码，同一样要在你的cargo.toml文件中添加对router的依赖</p>
<pre><pre class="playpen"><code class="language-rust">extern crate iron;
extern crate router;
extern crate rustc_serialize;

use iron::prelude::*;
use iron::status;
use router::Router;
use rustc_serialize::json;

#[derive(RustcEncodable, RustcDecodable)]
struct Greeting {
    msg: String
}

fn main() {
    let mut router = Router::new();

    router.get(&quot;/&quot;, hello_world);
    router.post(&quot;/set&quot;, set_greeting);

    fn hello_world(_: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
        let greeting = Greeting { msg: &quot;Hello, World&quot;.to_string() };
        let payload = json::encode(&amp;greeting).unwrap();
        Ok(Response::with((status::Ok, payload)))
    }

    // Receive a message by POST and play it back.
    fn set_greeting(request: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
        let payload = request.body.read_to_string();
        let request: Greeting = json::decode(payload).unwrap();
        let greeting = Greeting { msg: request.msg };
        let payload = json::encode(&amp;greeting).unwrap();
        Ok(Response::with((status::Ok, payload)))
    }

    Iron::new(router).http(&quot;localhost:3000&quot;).unwrap();
}
</code></pre></pre>
<p>这次添加了路由的实现和获取客户端发送过来的数据，有了get，post,所以现在一个基本的api网站已经完成了。不过
并不是所有的网站都是api来访问，同样需要html模版引擎和直接返回静态页面。等等</p>
<pre><code>vagrant@ubuntu-14:~/tmp/test/rustprimer/mysite$ cargo build
   Compiling mysite v0.1.0 (file:///home/vagrant/tmp/test/rustprimer/mysite)
src/main.rs:29:36: 29:52 error: no method named `read_to_string` found for type `iron::request::Body&lt;'_, '_&gt;` in the current scope
src/main.rs:29         let payload = request.body.read_to_string();
                                                  ^~~~~~~~~~~~~~~~
src/main.rs:29:36: 29:52 help: items from traits can only be used if the trait is in scope; the following trait is implemented but not in scope, perhaps add a `use` for it:
src/main.rs:29:36: 29:52 help: candidate #1: use `std::io::Read`
error: aborting due to previous error
Could not compile `mysite`.
</code></pre>
<p>编译出错了，太糟糕了，提示说没有read_to_string这个方法，然后我去文档查了一下，发现有<a href="http://ironframework.io/doc/iron/request/struct.Body.html">read_to_string方法</a>
再看提示信息</p>
<pre><code>src/main.rs:29:36: 29:52 help: items from traits can only be used if the trait is in scope; the following trait is implemented but not in scope, perhaps add a `use` for it:
src/main.rs:29:36: 29:52 help: candidate #1: use `std::io::Read`
</code></pre>
<p>让我们添加一个<code>std::io::Read</code>,这个如果操作过文件，你一定知道怎么写，添加一下，应该能过去了，还是继续出错了，看看报错</p>
<pre><code>   Compiling mysite v0.1.0 (file:///home/vagrant/tmp/test/rustprimer/mysite)
src/main.rs:30:36: 30:52 error: this function takes 1 parameter but 0 parameters were supplied [E0061]
src/main.rs:30         let payload = request.body.read_to_string();
                                                  ^~~~~~~~~~~~~~~~
src/main.rs:30:36: 30:52 help: run `rustc --explain E0061` to see a detailed explanation
src/main.rs:31:46: 31:53 error: mismatched types:
 expected `&amp;str`,
    found `core::result::Result&lt;usize, std::io::error::Error&gt;`
(expected &amp;-ptr,
    found enum `core::result::Result`) [E0308]
src/main.rs:31         let request: Greeting = json::decode(payload).unwrap();
                                                            ^~~~~~~
src/main.rs:31:46: 31:53 help: run `rustc --explain E0308` to see a detailed explanation
src/main.rs:30:36: 30:52 error: cannot infer an appropriate lifetime for lifetime parameter `'b` due to conflicting requirements [E0495]
src/main.rs:30         let payload = request.body.read_to_string();
                                                  ^~~~~~~~~~~~~~~~
src/main.rs:29:5: 35:6 help: consider using an explicit lifetime parameter as shown: fn set_greeting&lt;'a&gt;(request: &amp;mut Request&lt;'a, 'a&gt;) -&gt; IronResult&lt;Response&gt;
src/main.rs:29     fn set_greeting(request: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
src/main.rs:30         let payload = request.body.read_to_string();
src/main.rs:31         let request: Greeting = json::decode(payload).unwrap();
src/main.rs:32         let greeting = Greeting { msg: request.msg };
src/main.rs:33         let payload = json::encode(&amp;greeting).unwrap();
src/main.rs:34         Ok(Response::with((status::Ok, payload)))
               ...
error: aborting due to 3 previous errors
Could not compile `mysite`.

</code></pre>
<p>第一句提示我们，这个read_to_string(),至少要有一个参数，但是我们一个都没有提供。
我们看看<a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_to_string">read_to_string的用法</a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
se std::io;
use std::io::prelude::*;
use std::fs::File;

let mut f = try!(File::open(&quot;foo.txt&quot;));
let mut buffer = String::new();

try!(f.read_to_string(&amp;mut buffer));

#}</code></pre></pre>
<p>用法比较简单，我们修改一下刚刚的函数：</p>
<pre><code>fn set_greeting(request: &amp;mut Request) -&gt; IronResult&lt;Response&gt; {
        let mut payload = String::new();
        request.body.read_to_string(&amp;mut payload);
        let request: Greeting = json::decode(&amp;payload).unwrap();
        let greeting = Greeting { msg: request.msg };
        let payload = json::encode(&amp;greeting).unwrap();
        Ok(Response::with((status::Ok, payload)))
    }
</code></pre>
<p>从request中读取字符串，读取的结果存放到payload中，然后就可以进行操作了，编译之后运行，使用curl提交一个post数据</p>
<pre><code>$curl -X POST -d '{&quot;msg&quot;:&quot;Just trust the Rust&quot;}' http://localhost:3000/set
{&quot;msg&quot;:&quot;Just trust the Rust&quot;}
</code></pre>
<p>iron 基本告一段落
当然还有如何使用html模版引擎，那就是直接看文档就行了。</p>
<p>##<a href="http://nickel.rs/">nickel</a></p>
<p>当然既然是web框架肯定是iron能干的nicke也能干，所以那我们就看看如何做一个hello 和返回一个html
的页面</p>
<p>同样我们创建<code>cargo new site --bin</code>，然后添加nickel到cargo.toml中,<code>cargo build</code></p>
<pre><pre class="playpen"><code class="language-rust">
#[macro_use] extern crate nickel;

use nickel::Nickel;

fn main() {
    let mut server = Nickel::new();

    server.utilize(router! {
        get &quot;**&quot; =&gt; |_req, _res| {
            &quot;Hello world!&quot;
        }
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}
</code></pre></pre>
<p>简单来看，也就是这样回事。</p>
<ol>
<li>引入了nickel的宏</li>
<li>初始化Nickel</li>
<li>调用utilize来定义路由模块。</li>
<li><code>router!</code> 宏，传入的参数是 get 方法和对应的路径，&quot;**&quot;是全路径匹配。</li>
<li>listen启动服务器</li>
</ol>
<p><a href="http://nickel.rs/#easy-templating">当然我们要引入关于html模版相关的信息</a></p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use] extern crate nickel;

use std::collections::HashMap;
use nickel::{Nickel, HttpRouter};

fn main() {
    let mut server = Nickel::new();

    server.get(&quot;/&quot;, middleware! { |_, response|
        let mut data = HashMap::new();
        data.insert(&quot;name&quot;, &quot;user&quot;);
        return response.render(&quot;site/assets/template.tpl&quot;, &amp;data);
    });

    server.listen(&quot;127.0.0.1:6767&quot;);
}

</code></pre></pre>
<p>上面的信息你可以编译，使用curl看看发现出现</p>
<pre><code>$ curl http://127.0.0.1:6767
Internal Server Error
</code></pre>
<p>看看文档，没发现什么问题，我紧紧更换了一个文件夹的名字，这个文件夹我也创建了。
然后我在想难道是服务器将目录写死了吗？于是将上面的路径改正这个，问题解决。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
return response.render(&quot;examples/assets/template.tpl&quot;, &amp;data);
#}</code></pre></pre>
<p>我们看一下目录结构</p>
<pre><code>.
|-- Cargo.lock
|-- Cargo.toml
|-- examples
|   `-- assets
|       `-- template.tpl
|-- src
|   `-- main.rs

</code></pre>
<a class="header" href="print.html#rust数据库操作" id="rust数据库操作"><h1>rust数据库操作</h1></a>
<p>编程时，我们依赖数据库来存储相应的数据，很多编程语言都支持对数据库的操作，所以当然可以使用Rust操作数据库。</p>
<p>不过在我自己操作时，发现很多问题，主要因为我不了解Rust在操作数据库时，应该注意的事情，从而浪费了很多的时间，在进行数据查询时。
具体遇到的坑，我会做一些演示，从而让大家避免这些情况。</p>
<p>首先使用Rust操作PostgreSQL,因为PostgreSQL是我最喜欢的数据库。</p>
<p>首先创建新项目 <code>cargo new db --bin</code></p>
<p>在cargo.toml中添加 <code>postgres</code> 如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
[package]
name = &quot;db&quot;
version = &quot;0.1.0&quot;
authors = [&quot;vagrant&quot;]

[dependencies]
postgres=&quot;*&quot;
#}</code></pre></pre>
<p>当然我们还是进行最简单的操作，直接粘贴复制，<a href="https://github.com/sfackler/rust-postgres#overview">代码来源</a></p>
<pre><pre class="playpen"><code class="language-rust">
extern crate postgres;

use postgres::{Connection, SslMode};

struct Person {
    id: i32,
    name: String,
    data: Option&lt;Vec&lt;u8&gt;&gt;
}

fn main() {
    let conn = Connection::connect(&quot;postgres://postgres@localhost&quot;, SslMode::None)
            .unwrap();

    conn.execute(&quot;CREATE TABLE person (
                    id              SERIAL PRIMARY KEY,
                    name            VARCHAR NOT NULL,
                    data            BYTEA
                  )&quot;, &amp;[]).unwrap();
    let me = Person {
        id: 0,
        name: &quot;Steven&quot;.to_string(),
        data: None
    };
    conn.execute(&quot;INSERT INTO person (name, data) VALUES ($1, $2)&quot;,
                 &amp;[&amp;me.name, &amp;me.data]).unwrap();

    for row in &amp;conn.query(&quot;SELECT id, name, data FROM person&quot;, &amp;[]).unwrap() {
        let person = Person {
            id: row.get(0),
            name: row.get(1),
            data: row.get(2)
        };
        println!(&quot;Found person {}&quot;, person.name);
    }
}

</code></pre></pre>
<p>这些简单的，当然不是我们想要的东西，我们想要的是能够进行一些分层，也就是
基本的一些函数逻辑划分，而不是在一个main函数中，完成所有的一切。</p>
<p>##创建lib.rs文件</p>
<p>从上到下来看文件：</p>
<ol>
<li>首先导入postgres的各种库</li>
<li>创建一个Person 的struct，按照需求的字段和类型。</li>
<li>创建一个连接函数，返回连接对象。</li>
<li>创建一个插入函数，用来插入数据</li>
<li>创建一个查询函数，用来查询数据</li>
<li>创建一个查询函数，用来查询所有的数据。</li>
</ol>
<p>当然这些函数都是有一定的功能局限性。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
extern crate postgres;

use postgres::{Connection, SslMode};
use postgres::types::FromSql;
use postgres::Result as PgResult;


struct Person {
    id: i32,
    name: String,
    data: Option&lt;Vec&lt;u8&gt;&gt;
}


pub fn connect() -&gt; Connection{
    let dsn = &quot;postgresql://postgres:2015@localhost/rust_example&quot;;
    Connection::connect(dsn, SslMode::None).unwrap()
}

pub fn insert_info(conn : &amp;Connection,title : &amp;str, body: &amp;str){

    let stmt = match conn.prepare(&quot;insert into blog (title, body) values ($1, $2)&quot;) {
        Ok(stmt) =&gt; stmt,
        Err(e) =&gt; {
            println!(&quot;Preparing query failed: {:?}&quot;, e);
            return;
        }
    };
        stmt.execute(&amp;[&amp;title, &amp;body]).expect(&quot;Inserting blogposts failed&quot;);
}


pub fn query&lt;T&gt;(conn: &amp;Connection,query: &amp;str) -&gt;PgResult&lt;T&gt;
        where T: FromSql {
            println!(&quot;Executing query: {}&quot;, query);
            let stmt = try!(conn.prepare(query));
            let rows = try!(stmt.query(&amp;[]));
            &amp;rows.iter().next().unwrap();
            let row = &amp;rows.iter().next().unwrap();
                //rows.iter().next().unwrap()
            row.get_opt(2).unwrap()

}

pub fn query_all(conn: &amp;Connection,query: &amp;str){
            println!(&quot;Executing query: {}&quot;, query);
            for row in &amp;conn.query(query,&amp;[]).unwrap(){
                let person = Person{
                    id: row.get(0),
                    name: row.get(1),
                    data: row.get(2)
            };
            println!(&quot;Found person {}&quot;, person.name);
            }

}

#}</code></pre></pre>
<p>然后在main.rs 中调用相应的函数代码如下</p>
<ol>
<li>extern db ,引入db，也就是将项目本身引入</li>
<li>use db 使用db，中的可以被引入的函数</li>
<li>定义Blog,由于个人使用blog表，是自己创建，所以如果报错说不存在表，需要你自己去创建</li>
<li>使用lib中定义的函数，进行最基本的一些操作</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">extern crate postgres;
extern crate db;

use postgres::{Connection, SslMode};

use db::*;

struct Blog {
    title: String,
    body:  String,
}

fn main() {
    let conn:Connection=connect();

    let blog = Blog{
        title: String::from(&quot;title&quot;),
        body: String::from(&quot;body&quot;),
    };
    let title = blog.title.to_string();
    let body = blog.body.to_string();
    insert_info(&amp;conn,&amp;title,&amp;body);

   for row in query::&lt;String&gt;(&amp;conn,&quot;select * from blog&quot;){
        println!(&quot;{:?}&quot;,row);
    }
    let sql = &quot;select * from person&quot;;
    query_all(&amp;conn,&amp;sql);
}

</code></pre></pre>
<p>自己遇到的坑</p>
<ul>
<li>
<p>创建连接函数时，连接必须有一个返回值，所以必须指定返回值的类型，
对于一个写Python的人而言，我觉得是痛苦的，我想按照官方的写法match
一下，发现可能产生多个返回值。在编译时直接无法通过编译，所以最终
使用了unwrap,解决问题，不过我还是没有学会，函数多值返回时我如何
定义返回值</p>
</li>
<li>
<p>在使用<code>&amp;conn.query(query,&amp;[]).unwrap()</code>时，我按照文档操作，文档说
返回的是一个可迭代的数据，那也就是说，我可以使用for循环，将数据打印，
但是发现怎么也不能实现：</p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]

#fn main() {
pub fn query_all(conn: &amp;Connection,query: &amp;str){
            println!(&quot;Executing query: {}&quot;, query);
            for row in &amp;conn.query(query,&amp;[]).unwrap(){
                  println!(&quot;Found person {:?}&quot;, row.get_opt(1));
            }
}

#}</code></pre></pre>
<p>报错如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
vagrant@ubuntu-14:~/tmp/test/rustprimer/db$ cargo run
   Compiling db v0.1.0 (file:///home/vagrant/tmp/test/rustprimer/db)
src/lib.rs:53:37: 53:47 error: unable to infer enough type information about `_`; type annotations or generic parameter binding required [E0282]
src/lib.rs:53   println!(&quot;Found person {:?}&quot;, row.get_opt(1));
                                                  ^~~~~~~~~~
&lt;std macros&gt;:2:25: 2:56 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
src/lib.rs:53:3: 53:49 note: in this expansion of println! (defined in &lt;std macros&gt;)
src/lib.rs:53:37: 53:47 help: run `rustc --explain E0282` to see a detailed explanation
error: aborting due to previous error
Could not compile `db`.

#}</code></pre></pre>
<p>然后去查看了关于postgres模块的所有函数，尝试了无数种办法，依旧没有解决。</p>
<p>可能自己眼高手低，如果从头再把Rust的相关教程看一下，可能很早就发现这个问题，
也有可能是因为习惯了写Python，导致自己使用固有的思维来看待问题和钻牛角尖，才
导致出现这样的问题，浪费很多的时间。</p>
<ul>
<li>改变思维，把自己当作一个全新的新手，既要利用已有的思想来学习新的语言，同样不要
被自己很精通的语言，固化自己的思维。</li>
</ul>
<a class="header" href="print.html#a附录i-术语表" id="a附录i-术语表"><h1>附录I-术语表</h1></a>
<ul>
<li>ADT(Algebraic Data Type:代数数据类型):</li>
<li>ARC(Atomic Reference Counting:原子引用计数):</li>
<li>associated function(关联函数):</li>
<li>associated type(关联类型): Trait 里面可以有关联类型</li>
<li>AST(Abstract Syntax Tree:抽象语法树):</li>
<li>benchmark(基准测试):</li>
<li>bitwise copy:</li>
<li>borrow(借用):</li>
<li>bounds(约束):</li>
<li>box:</li>
<li>byte string():</li>
<li>cargo:</li>
<li>cast:</li>
<li>channel:</li>
<li>coercion:</li>
<li>constructor(构造器):</li>
<li>consumer:</li>
<li>copy:</li>
<li>crate:</li>
<li>dangling pointer:</li>
<li>deref(解引用):</li>
<li>derive:</li>
<li>designator(指示符):</li>
<li>destructor():</li>
<li>destructure(析构):</li>
<li>diverging function(发散函数):</li>
<li>drop:</li>
<li>DST(Dynamically Sized Type):</li>
<li>dynamic dispatch(动态分发):</li>
<li>enum():</li>
<li>feature gate(特性开关): nightly 版本中有特性开关可以启用一些实验性质的特性</li>
<li>FFI(Foreign Function Interface:外部函数接口):</li>
<li>guard:</li>
<li>hygiene:</li>
<li>inline function(内联函数):</li>
<li>item:</li>
<li>iterator(迭代器):</li>
<li>iterator adaptor(迭代器适配器):</li>
<li>lifetime(生命周期):</li>
<li>lifetime elision:</li>
<li>literal string():</li>
<li>macro by example:</li>
<li>memberwise copy:</li>
<li>module(模块)</li>
<li>move:</li>
<li>option:</li>
<li>ownership(所有权):</li>
<li>panic(崩溃):</li>
<li>phantom type:</li>
<li>primitive type(基本类型): 整型、浮点、布尔等基本类型</li>
<li>procedural macro:</li>
<li>RAII():</li>
<li>raw string:</li>
<li>raw pointer:</li>
<li>RC(Reference Counting:引用计数)</li>
<li>result:</li>
<li>shadowing:</li>
<li>static dispatch(静态分发):</li>
<li>slice(切片): 某种数据类型的视图，例如 string, vector</li>
<li>statement(): 与 expression 相区别</li>
<li>trait:</li>
<li>trait object:</li>
<li>tuple(元组):</li>
<li>UFCS(Universal Function Call Syntax)</li>
<li>unit():</li>
<li>unwind:</li>
<li>unwrap():</li>
<li>wrap:</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
